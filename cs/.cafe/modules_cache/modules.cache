{"dna":{"name":"dna","sources":"\n\n/*ZB: dna-lang */\nrequire.define('dna-lang', {\n\n/*ZB:  dna-lang/utils/Math.uuid */\n'utils/Math.uuid': function(exports, require, module) {(function() {\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n(function() {\n  // Private array of chars to use\n  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\n  Math.uuid = function (len, radix) {\n    var chars = CHARS, uuid = [], i;\n    radix = radix || chars.length;\n\n    if (len) {\n      // Compact form\n      for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];\n    } else {\n      // rfc4122, version 4 form\n      var r;\n\n      // rfc4122 requires these characters\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n      uuid[14] = '4';\n\n      // Fill in random data.  At i==19 set the high bits of clock sequence as\n      // per rfc4122, sec. 4.1.5\n      for (i = 0; i < 36; i++) {\n        if (!uuid[i]) {\n          r = 0 | Math.random()*16;\n          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n        }\n      }\n    }\n\n    return uuid.join('');\n  };\n\n  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance\n  // by minimizing calls to random()\n  Math.uuidFast = function() {\n    var chars = CHARS, uuid = new Array(36), rnd=0, r;\n    for (var i = 0; i < 36; i++) {\n      if (i==8 || i==13 ||  i==18 || i==23) {\n        uuid[i] = '-';\n      } else if (i==14) {\n        uuid[i] = '4';\n      } else {\n        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\n        r = rnd & 0xf;\n        rnd = rnd >> 4;\n        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n      }\n    }\n    return uuid.join('');\n  };\n\n  // A more compact, but less performant, RFC4122v4 solution:\n  Math.uuidCompact = function() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    });\n  };\n})();\n\nmodule.exports = Math\n}).call(this);},\n\n/*ZB:  dna-lang/index */\n'index': function(exports, require, module) {(function() {\nmodule.exports = require('lib-js/dna')\n}).call(this);},\n\n/*ZB:  dna-lang/lib-js/dna */\n'lib-js/dna': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var BQ, BUILTIN, DNA_DATATYPES, DNA_EXTEND, DNA_ID_PREFIX, DNA_PRIMITIVES, DNA_SUBSCRIBE, FLOAT, FUNCTION, HASHMAP, INTEGER, KEYWORD, MY_STATE, Math, NAN, NESTED_EXPR, NULL, PARTIAL_FN, QUOTED_NESTED_EXPR, RE, STRING, THIS, VECTOR, X, bind_handlers_to_event, bool, complement, compose3, cont_m, cont_t, create_cell, create_cell_by_id, debug, default_handlers_cont, dispatch_handler, dispatch_impl, distinct, domonad, error, find_cell, fun_with_meta, get_arity, get_cell, get_method_ns, get_primitive_value_handler, get_protocol, get_state, get_value_handler, info, is_array, is_async, is_function, is_just_function, is_nested_expr, is_null, is_object, is_partial_function, is_value, lazy_init_state, lift, lift_async, lift_sync, logger_m, logger_t, make_dynamic_handler, make_lambda, make_monadized_handler, make_nested_expr, maybe_m, maybe_t, nullog, observe_dom_added, parse_genome, partial, process_ast_handler_node, process_ast_vector, process_meta, process_subscribe, register_protocol_impl, repeat, save_cell, swap_state, synthesize_cell, synthesize_node, warn, watch_my_state, watch_state, _ref, _ref1, _ref2, _ref3, _ref4,\n    __slice = [].slice,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  DNA_EXTEND = 'extend';\n\n  DNA_SUBSCRIBE = 'subscribe';\n\n  DNA_ID_PREFIX = 'Z';\n\n  NAN = 'NaN';\n\n  NULL = 'null';\n\n  KEYWORD = 'keyword';\n\n  STRING = 'string';\n\n  INTEGER = 'integer';\n\n  FLOAT = 'float';\n\n  VECTOR = 'vector';\n\n  HASHMAP = 'hashmap';\n\n  BQ = 'bq';\n\n  RE = 're';\n\n  FUNCTION = 'fn';\n\n  PARTIAL_FN = 'partial';\n\n  NESTED_EXPR = 'nested';\n\n  QUOTED_NESTED_EXPR = 'quoted-nested';\n\n  DNA_PRIMITIVES = [NAN, NULL, KEYWORD, STRING, INTEGER, FLOAT, RE, BQ];\n\n  DNA_DATATYPES = [NAN, NULL, KEYWORD, STRING, INTEGER, FLOAT, VECTOR, HASHMAP, RE, BQ];\n\n  THIS = 'this';\n\n  BUILTIN = '*builtin*';\n\n  Math = require('../utils/Math.uuid');\n\n  _ref = require('libprotein'), partial = _ref.partial, is_array = _ref.is_array, is_object = _ref.is_object, bool = _ref.bool, make_lambda = _ref.make_lambda, complement = _ref.complement, compose3 = _ref.compose3, distinct = _ref.distinct, repeat = _ref.repeat;\n\n  observe_dom_added = require('dom-mutation-observer').observe_dom_added;\n\n  parse_genome = (require('genome-parser')).parse;\n\n  _ref1 = require('libprotocol'), register_protocol_impl = _ref1.register_protocol_impl, dispatch_impl = _ref1.dispatch_impl, get_protocol = _ref1.get_protocol, is_async = _ref1.is_async, get_arity = _ref1.get_arity;\n\n  _ref2 = require('libmonad'), cont_t = _ref2.cont_t, cont_m = _ref2.cont_m, maybe_t = _ref2.maybe_t, maybe_m = _ref2.maybe_m, logger_t = _ref2.logger_t, logger_m = _ref2.logger_m, domonad = _ref2.domonad, is_null = _ref2.is_null, lift_sync = _ref2.lift_sync, lift_async = _ref2.lift_async;\n\n  _ref3 = dispatch_impl('ILogger', 'DNA'), info = _ref3.info, warn = _ref3.warn, error = _ref3.error, debug = _ref3.debug, nullog = _ref3.nullog;\n\n  _ref4 = require('libstate'), get_state = _ref4.get_state, swap_state = _ref4.swap_state, watch_state = _ref4.watch_state;\n\n  MY_STATE = 'dna';\n\n  watch_my_state = function(old_state, new_state) {\n    return debug(\"state changed\", old_state, new_state);\n  };\n\n  lazy_init_state = function(state) {\n    state || (state = {});\n    state.CELLS || (state.CELLS = {});\n    watch_state(MY_STATE, watch_my_state);\n    return state;\n  };\n\n  process_ast_vector = function(vector, cell, ctx, cont) {\n    var count, local_cont, res;\n\n    res = [];\n    count = vector.length;\n    local_cont = function(idx) {\n      return function(r) {\n        res[idx] = r;\n        count--;\n        if (count === 0) {\n          return cont(res);\n        }\n      };\n    };\n    return vector.map(function(ast_node, idx) {\n      var c, h;\n\n      h = process_ast_handler_node(cell, ctx, ast_node);\n      c = local_cont(idx);\n      if (h.meta.async) {\n        return h.apply(null, (repeat(void 0, h.meta.arity - 1)).concat([c]));\n      } else {\n        return c(h.apply(null, repeat(void 0, h.meta.arity)));\n      }\n    });\n  };\n\n  default_handlers_cont = function() {\n    var args;\n\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  };\n\n  is_value = function(type) {\n    return __indexOf.call(DNA_DATATYPES, type) >= 0;\n  };\n\n  is_function = function(type) {\n    return type === FUNCTION || type === PARTIAL_FN;\n  };\n\n  is_just_function = function(type) {\n    return type === FUNCTION;\n  };\n\n  is_partial_function = function(type) {\n    return type === PARTIAL_FN;\n  };\n\n  is_nested_expr = function(type) {\n    return type === NESTED_EXPR;\n  };\n\n  lift = function(h) {\n    if (h.meta.async) {\n      return lift_async(h.meta.arity, h);\n    } else {\n      return lift_sync(h.meta.arity, h);\n    }\n  };\n\n  get_method_ns = function(name, cell) {\n    var method_invariants;\n\n    method_invariants = cell.receptors[name];\n    if ((method_invariants != null ? method_invariants.length : void 0) > 0) {\n      return method_invariants[0].ns;\n    } else {\n      error(\"No such method: \" + name + \" in the cell:\", cell);\n      throw \"Method missing in cell\";\n    }\n  };\n\n  dispatch_handler = function(ns, name, cell) {\n    var method_from_given_ns, method_invariants;\n\n    method_invariants = cell.receptors[name];\n    if (method_invariants) {\n      if (ns) {\n        method_from_given_ns = (method_invariants.filter(function(m) {\n          return m.ns === ns;\n        }))[0];\n        if (method_from_given_ns) {\n          return method_from_given_ns.impl;\n        } else {\n          error(\"Method not found: \" + ns + \"/\" + name + \" in cell\", cell);\n          throw \"Method not found: \" + ns + \"/\" + name + \" in cell id=`\" + cell.id + \"`\";\n        }\n      } else {\n        if (method_invariants.length === 1) {\n          return method_invariants[0].impl;\n        } else {\n          error(\"More then one method with name `\" + name + \"` found in cell and namespace not set\", cell);\n          throw \"More then one method with name `\" + name + \"` found in cell id=`\" + cell.id + \"` and namespace not set\";\n        }\n      }\n    } else {\n      error(\"Method with name `\" + name + \"` not found in cell\", {\n        ns: ns,\n        name: name,\n        cell: cell\n      });\n      throw \"Method with name `\" + name + \"` not found in cell id=`\" + cell.id + \"`\";\n    }\n  };\n\n  save_cell = function(cell) {\n    return swap_state(MY_STATE, function(old_state) {\n      var new_state;\n\n      new_state = lazy_init_state(old_state);\n      new_state.CELLS[cell.id] = cell;\n      return new_state;\n    });\n  };\n\n  get_cell = function(id) {\n    return (lazy_init_state(get_state(MY_STATE))).CELLS[id];\n  };\n\n  find_cell = function(scope_id, this_cell, ctx) {\n    var cell;\n\n    if ((scope_id === THIS || !scope_id) && this_cell) {\n      return this_cell;\n    } else if (cell = get_cell(scope_id)) {\n      return cell;\n    } else if (cell = create_cell_by_id(scope_id, ctx, this_cell.synthesis_id)) {\n      return cell;\n    } else {\n      return null;\n    }\n  };\n\n  create_cell_by_id = function(id, ctx, synthesis_id) {\n    var node;\n\n    if (node = ctx.dom_parser.get_by_id(id)) {\n      return create_cell(ctx, synthesis_id, node);\n    } else {\n      return null;\n    }\n  };\n\n  fun_with_meta = function(fn, meta) {\n    fn.meta = meta;\n    return fn;\n  };\n\n  get_primitive_value_handler = function(type, value) {\n    switch (type) {\n      case NAN:\n        return fun_with_meta((function() {\n          return NaN;\n        }), {\n          arity: 0,\n          async: false,\n          protocol: BUILTIN,\n          name: \"NaN\"\n        });\n      case NULL:\n        return fun_with_meta((function() {\n          return null;\n        }), {\n          arity: 0,\n          async: false,\n          protocol: BUILTIN,\n          name: \"null\"\n        });\n      case KEYWORD:\n        return fun_with_meta((function() {\n          return value;\n        }), {\n          arity: 0,\n          async: false,\n          protocol: BUILTIN,\n          name: \":Keyword \" + value\n        });\n      case STRING:\n        return fun_with_meta((function() {\n          return value;\n        }), {\n          arity: 0,\n          async: false,\n          ns: BUILTIN,\n          name: \"String '\" + value + \"'\"\n        });\n      case INTEGER:\n        return fun_with_meta((function() {\n          return value;\n        }), {\n          arity: 0,\n          async: false,\n          ns: BUILTIN,\n          name: \"Integer '\" + value + \"'\"\n        });\n      case FLOAT:\n        return fun_with_meta((function() {\n          return value;\n        }), {\n          arity: 0,\n          async: false,\n          ns: BUILTIN,\n          name: \"Float '\" + value + \"'\"\n        });\n      case BQ:\n        return fun_with_meta((function() {\n          return make_lambda(value);\n        }), {\n          arity: 0,\n          async: false,\n          ns: BUILTIN,\n          name: \"`Lambda '\" + value + \"'\"\n        });\n      case RE:\n        return fun_with_meta((function() {\n          return function(a) {\n            return value.test(a);\n          };\n        }), {\n          arity: 0,\n          async: false,\n          ns: BUILTIN,\n          name: \"/Regexp/ '\" + value + \"'\"\n        });\n      default:\n        throw \"Unknown primitive type: \" + type + \"/\" + value;\n    }\n  };\n\n  get_value_handler = function(type, value, cell, ctx) {\n    switch (type) {\n      case NAN:\n      case NULL:\n      case KEYWORD:\n      case STRING:\n      case INTEGER:\n      case FLOAT:\n      case BQ:\n      case RE:\n        return get_primitive_value_handler(type, value);\n      case VECTOR:\n        return fun_with_meta(function(cont) {\n          return process_ast_vector(value, cell, ctx, function(res) {\n            return cont(res);\n          });\n        }, {\n          async: true,\n          arity: 1,\n          protocol: BUILTIN,\n          name: \"Vector\"\n        });\n      case HASHMAP:\n        return fun_with_meta(function(key) {\n          if (key) {\n            return value[key];\n          } else {\n            return value;\n          }\n        }, {\n          arity: 1,\n          async: false,\n          protocol: BUILTIN,\n          name: \"Hashmap\"\n        });\n      default:\n        throw \"Unknown type: \" + type;\n    }\n  };\n\n  make_nested_expr = function(ctx, current_cell, handler) {\n    return fun_with_meta(function(arg, cont) {\n      var f;\n\n      f = make_monadized_handler(ctx, current_cell, cont, handler);\n      return f(arg);\n    }, {\n      async: true,\n      arity: 2,\n      protocol: BUILTIN,\n      name: NESTED_EXPR\n    });\n  };\n\n  process_ast_handler_node = function(current_cell, ctx, handler) {\n    var USE_LAZY_PARTIAL_ARGS, arity, h, vargs, _get_cell, _ref5;\n\n    _get_cell = function(id) {\n      var cell;\n\n      cell = find_cell(id, current_cell, ctx);\n      if (!cell) {\n        error(\"Unknown cell referenced in handler\", id, handler);\n        throw \"Unknown cell referenced in handler\";\n      }\n      return cell;\n    };\n    switch (handler.type) {\n      case FUNCTION:\n        return dispatch_handler(handler.ns, handler.name, _get_cell(handler.scope || THIS));\n      case PARTIAL_FN:\n        USE_LAZY_PARTIAL_ARGS = true;\n        h = dispatch_handler(handler.fn.ns, handler.fn.name, _get_cell(handler.fn.scope || THIS));\n        if (USE_LAZY_PARTIAL_ARGS) {\n          _ref5 = h.meta, vargs = _ref5.vargs, arity = _ref5.arity;\n          return fun_with_meta(function() {\n            var accepted_args, args;\n\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            accepted_args = args.slice(0, arity);\n            return process_ast_vector(handler.args, current_cell, ctx, function(calculated_args) {\n              var cont, raw_accepted_args, _i;\n\n              if (h.meta.async) {\n                return h.apply(null, calculated_args.concat(accepted_args));\n              } else {\n                raw_accepted_args = 2 <= accepted_args.length ? __slice.call(accepted_args, 0, _i = accepted_args.length - 1) : (_i = 0, []), cont = accepted_args[_i++];\n                return cont(h.apply(null, calculated_args.concat(raw_accepted_args)));\n              }\n            });\n          }, {\n            arity: arity,\n            async: true,\n            name: \"partial application of \" + h.meta.name,\n            protocol: h.meta.protocol\n          });\n        } else {\n          return partial.apply(null, [h].concat(__slice.call(handler.args.map(function(_arg) {\n            var type, value;\n\n            type = _arg.type, value = _arg.value;\n            if (__indexOf.call(DNA_PRIMITIVES, type) < 0) {\n              throw \"Only primitive datatypes accepted as partial args\";\n            }\n            return (get_primitive_value_handler(type, value))();\n          }))));\n        }\n        break;\n      case NESTED_EXPR:\n        return make_nested_expr(ctx, current_cell, handler.value);\n      case QUOTED_NESTED_EXPR:\n        throw \"QUOTED_NESTED_EXPR is not implemented yet\";\n        break;\n      case NAN:\n      case NULL:\n      case KEYWORD:\n      case STRING:\n      case INTEGER:\n      case FLOAT:\n      case VECTOR:\n      case HASHMAP:\n      case RE:\n      case BQ:\n        return get_value_handler(handler.type, handler.value, _get_cell(handler.scope || THIS), ctx);\n      default:\n        error(\"Unknown expression type: \" + handler.type, handler);\n        throw \"Unknown expression type: \" + handler.type;\n    }\n  };\n\n  process_meta = function(cell, h) {\n    return h;\n  };\n\n  make_monadized_handler = function(ctx, cell, cont, handlr) {\n    var ast_parser, do_meta, lifted_handlers_chain, wrapper_monad;\n\n    ast_parser = partial(process_ast_handler_node, cell, ctx);\n    do_meta = partial(process_meta, cell);\n    lifted_handlers_chain = handlr.seq.map(compose3(lift, do_meta, ast_parser));\n    wrapper_monad = cont_t(logger_t(maybe_m({\n      is_error: is_null\n    }), nullog));\n    return fun_with_meta(function(init_val) {\n      return (domonad(wrapper_monad, lifted_handlers_chain, init_val))(cont);\n    }, {\n      async: true,\n      arity: 1,\n      name: 'monadized-handler'\n    });\n  };\n\n  bind_handlers_to_event = function(ctx, cell, handlers, event_node) {\n    var args, event_binder, name, ns, scope, type, _ref5;\n\n    _ref5 = event_node.type === 'partial-event' ? {\n      type: 'partial-event',\n      args: partial(process_ast_vector, event_node.args, cell, ctx),\n      name: event_node.event.name,\n      ns: event_node.event.ns,\n      scope: event_node.event.scope\n    } : {\n      type: 'event',\n      args: [],\n      name: event_node.name,\n      ns: event_node.ns,\n      scope: event_node.scope\n    }, type = _ref5.type, args = _ref5.args, name = _ref5.name, ns = _ref5.ns, scope = _ref5.scope;\n    event_binder = dispatch_handler(ns, name, find_cell(scope || THIS, cell, ctx));\n    return handlers.map(function(handlr) {\n      if (event_node.type === 'partial-event') {\n        return args(function(processed_args) {\n          return event_binder.apply(null, processed_args.concat([handlr]));\n        });\n      } else {\n        return event_binder.apply(null, args.concat([handlr]));\n      }\n    });\n  };\n\n  make_dynamic_handler = function(ctx, cell, cont, handlr) {\n    return function() {\n      var args, fresh_cell, h;\n\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      fresh_cell = find_cell(cell.id, cell, ctx);\n      h = make_monadized_handler(ctx, fresh_cell, cont, handlr);\n      return h.apply(null, args);\n    };\n  };\n\n  process_subscribe = function(cell) {\n    var genes, genome_string;\n\n    if (cell.subscriptions_processed) {\n      return;\n    }\n    cell.subscriptions_processed = true;\n    genome_string = cell.ctx.dom_parser.getData(DNA_SUBSCRIBE, cell.node);\n    if (bool(genome_string)) {\n      genes = parse_genome(genome_string);\n      return genes.map(function(gene) {\n        return gene.events.map(partial(bind_handlers_to_event, cell.ctx, cell, gene.handlers.map(partial(make_dynamic_handler, cell.ctx, cell, default_handlers_cont))));\n      });\n    }\n  };\n\n  synthesize_cell = function(node, ctx, synthesis_id) {\n    var all_the_protocols, extended_protocols, proto_cell;\n\n    if (!node.id) {\n      node.id = (ctx.dom_parser.get_id(node)) || DNA_ID_PREFIX + Math.uuid();\n    }\n    proto_cell = {\n      id: node.id,\n      node: node,\n      receptors: {},\n      impls: {},\n      ctx: ctx,\n      synthesis_id: synthesis_id\n    };\n    extended_protocols = (extended_protocols = ctx.dom_parser.getData(DNA_EXTEND, node)) ? (extended_protocols.split(' ')).filter(function(i) {\n      return !!i;\n    }) : [];\n    all_the_protocols = distinct(extended_protocols.concat(ctx.default_protocols));\n    all_the_protocols.map(function(protocol) {\n      var p;\n\n      p = get_protocol(protocol);\n      proto_cell.impls[protocol] = dispatch_impl(protocol, node);\n      if (!is_object(proto_cell.impls[protocol])) {\n        error(\"Bad protocol implementation for DNA: \" + protocol, proto_cell.impls[protocol]);\n        throw \"Bad protocol implementation for DNA: \" + protocol + \" :: \" + proto_cell.impls[protocol];\n      }\n      if (p && proto_cell.impls[protocol]) {\n        return p.map(function(_arg) {\n          var args, m, name;\n\n          name = _arg[0], args = _arg[1];\n          m = {\n            name: name,\n            ns: protocol,\n            impl: proto_cell.impls[protocol][name]\n          };\n          if (proto_cell.receptors[name]) {\n            return proto_cell.receptors[name].push(m);\n          } else {\n            return proto_cell.receptors[name] = [m];\n          }\n        });\n      }\n    });\n    return proto_cell;\n  };\n\n  create_cell = function(ctx, synthesis_id, node) {\n    var cell, maybe_id, old_cell, sid;\n\n    maybe_id = node.id;\n    sid = maybe_id && (old_cell = get_cell(maybe_id)) ? (debug(\"Reinstantiating cell with id \" + maybe_id), old_cell.synthesis_id + 1) : synthesis_id;\n    cell = synthesize_cell(node, ctx, sid);\n    save_cell(cell);\n    return cell;\n  };\n\n  synthesize_node = function(ctx) {\n    var START_TIME, active_nodes, creator, new_cells, root_node, synthesis_id;\n\n    START_TIME = new Date;\n    synthesis_id = 0;\n    root_node = ctx.dom_parser.get_root_node();\n    active_nodes = ctx.dom_parser.get_by_attr(\"[data-\" + DNA_EXTEND + \"], [data-\" + DNA_SUBSCRIBE + \"]\");\n    creator = partial(create_cell, ctx, synthesis_id);\n    new_cells = active_nodes.map(creator);\n    return new_cells.map(process_subscribe);\n  };\n\n  X = {\n    get_cells: function() {\n      return (lazy_init_state(get_state(MY_STATE))).CELLS;\n    },\n    get_cell: get_cell,\n    forget_cell: function(id) {\n      return swap_state(MY_STATE, function(old_state) {\n        var new_state;\n\n        new_state = lazy_init_state(old_state);\n        delete new_state.CELLS[id];\n        return new_state;\n      });\n    },\n    start_synthesis: function(root_node, default_protocols) {\n      var ctx;\n\n      if (!root_node) {\n        error(\"Root node not specified\");\n        throw \"Root node not specified\";\n      }\n      info('Synthesis started');\n      ctx = {\n        dom_parser: dispatch_impl('IDom', root_node),\n        default_protocols: default_protocols\n      };\n      observe_dom_added(root_node, function(new_dom) {\n        return setTimeout(function() {\n          return synthesize_node({\n            dom_parser: dispatch_impl('IDom', new_dom),\n            default_protocols: default_protocols\n          });\n        }, 10);\n      });\n      return synthesize_node(ctx);\n    },\n    synthesize_node: function(node, default_protocols) {\n      return synthesize_node({\n        dom_parser: dispatch_impl('IDom', node),\n        default_protocols: default_protocols\n      });\n    },\n    get_bound_method: function(cell, method_proto, method_name) {\n      var method_impl, method_inv;\n\n      method_inv = cell.receptors[method_name];\n      if (!method_inv) {\n        throw \"No method \" + method_name + \"@\" + cell.id;\n      }\n      if (method_proto === void 0 && method_inv.length === 1) {\n        return method_inv[0].impl;\n      } else {\n        method_impl = method_inv.filter(function(m) {\n          return m.ns === method_proto;\n        });\n        if (method_impl.length !== 1) {\n          throw \"No method \" + method_proto + \"/\" + method_name + \"@\" + cell.id;\n        }\n        return method_impl[0].impl;\n      }\n    },\n    call: function() {\n      var args, cellid, m, meth_name, meth_spec, mspec, ns, _ref5, _ref6;\n\n      mspec = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      _ref5 = mspec.split('@'), meth_spec = _ref5[0], cellid = _ref5[1];\n      _ref6 = meth_spec.split('/'), ns = _ref6[0], meth_name = _ref6[1];\n      m = X.get_bound_method(X.get_cell(cellid), ns, meth_name);\n      return m.apply(null, args);\n    }\n  };\n\n  module.exports = X;\n\n}).call(this);\n\n}).call(this);}\n});\n\n\n/*ZB: genome-parser */\nrequire.define('genome-parser', {\n\n/*ZB:  genome-parser/index */\n'index': function(exports, require, module) {(function() {\n/* parser generated by jison 0.4.13 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"program\":3,\"text\":4,\"EOF\":5,\"statement\":6,\";\":7,\"event_binding_def\":8,\"events\":9,\"ESEP\":10,\"handlers\":11,\"event_expression\":12,\",\":13,\"event\":14,\"values\":15,\"IDENTIFIER\":16,\"/\":17,\"@\":18,\"handler\":19,\"block\":20,\"|\":21,\"value\":22,\"fn\":23,\"primitive\":24,\"complex\":25,\"expr\":26,\"(\":27,\")\":28,\"QUOTE\":29,\"NAN\":30,\"NULL\":31,\"KEYWORD\":32,\"STRING\":33,\"BQ\":34,\"RE\":35,\"number\":36,\"INT\":37,\"FLOAT\":38,\"[\":39,\"vector\":40,\"]\":41,\"vec_item\":42,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\";\",10:\"ESEP\",13:\",\",16:\"IDENTIFIER\",17:\"/\",18:\"@\",21:\"|\",27:\"(\",28:\")\",29:\"QUOTE\",30:\"NAN\",31:\"NULL\",32:\"KEYWORD\",33:\"STRING\",34:\"BQ\",35:\"RE\",37:\"INT\",38:\"FLOAT\",39:\"[\",41:\"]\"},\nproductions_: [0,[3,0],[3,2],[4,1],[4,3],[6,1],[6,1],[8,3],[9,1],[9,3],[12,1],[12,2],[14,1],[14,3],[14,3],[14,5],[11,1],[11,3],[19,1],[19,3],[20,1],[20,1],[20,2],[15,1],[15,2],[22,1],[22,1],[22,1],[26,3],[26,4],[24,1],[24,1],[24,1],[24,1],[24,1],[24,1],[24,1],[36,1],[36,1],[25,3],[40,0],[40,2],[42,1],[42,1],[42,1],[23,1],[23,3],[23,3],[23,5]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 2:\n           //console.log($$[$0-1]);\n           return $$[$0-1];\n        \nbreak;\ncase 3: this.$ = [$$[$0]]; \nbreak;\ncase 4:\n           this.$ = ($$[$0-2]).concat($$[$0]);\n        \nbreak;\ncase 6: this.$ = $$[$0]; \nbreak;\ncase 7: this.$ = {events: $$[$0-2], handlers: $$[$0]}; \nbreak;\ncase 8: this.$ = [$$[$0]]; \nbreak;\ncase 9: this.$ = ($$[$0-2]).concat([$$[$0]]); \nbreak;\ncase 10: this.$ = $$[$0]; \nbreak;\ncase 11: this.$ = {type: 'partial-event', event: $$[$0-1], args: $$[$0]}; \nbreak;\ncase 12: this.$ = {ns: undefined, name: $$[$0], scope: undefined, type: 'event'}; \nbreak;\ncase 13: this.$ = {ns: $$[$0-2], name: $$[$0-1], scope: undefined, type: 'event'}; \nbreak;\ncase 14: this.$ = {ns: undefined, name: $$[$0-2], scope: $$[$0], type: 'event'}; \nbreak;\ncase 15: this.$ = {ns: $$[$0-4], name: $$[$0-2], scope: $$[$0], type: 'event'}; \nbreak;\ncase 16: this.$ = [$$[$0]]; \nbreak;\ncase 17: this.$ = ($$[$0-2]).concat([$$[$0]]); \nbreak;\ncase 18: this.$ = {type: 'handler', seq: [$$[$0]]}; \nbreak;\ncase 19: this.$ = {type: 'handler', seq: $$[$0-2].seq.concat([$$[$0]])}; \nbreak;\ncase 20: this.$ = $$[$0]; \nbreak;\ncase 21: this.$ = $$[$0]; \nbreak;\ncase 22: this.$ = { type: \"partial\", fn: $$[$0-1], args: $$[$0]}; \nbreak;\ncase 23: this.$ = [$$[$0]]; \nbreak;\ncase 24: this.$ = $$[$0-1].concat([$$[$0]]); \nbreak;\ncase 25: this.$ = $$[$0]; \nbreak;\ncase 26: this.$ = $$[$0]; \nbreak;\ncase 27: this.$ = $$[$0]; \nbreak;\ncase 28: this.$ = {type: 'nested', value: $$[$0-1]}; \nbreak;\ncase 29: this.$ = {type: 'quoted-nested', value: $$[$0-1]}; \nbreak;\ncase 30: this.$ = { type: \"NaN\", value: NaN }; \nbreak;\ncase 31: this.$ = { type: \"null\", value: null }; \nbreak;\ncase 32: this.$ = { type: \"keyword\", value: $$[$0] }; \nbreak;\ncase 33: this.$ = { type: \"string\", value: ($$[$0]).match('\\\"(\\\\.|[^\\\\\"]*?)\\\"')[1] }; \nbreak;\ncase 34: this.$ = { type: \"bq\", value: $$[$0].substr(1, $$[$0].length-2) } \nbreak;\ncase 35: this.$ = { type: \"re\", value: new RegExp($$[$0].substr(1, $$[$0].length-2)) } \nbreak;\ncase 36: this.$ = $$[$0]; \nbreak;\ncase 37: this.$ = { type: \"integer\", value: parseInt($$[$0], 10)}; \nbreak;\ncase 38: this.$ = { type: \"float\", value: parseFloat($$[$0], 10)}; \nbreak;\ncase 39: this.$ = { type: \"vector\", value: $$[$0-1]}; \nbreak;\ncase 40: this.$ = []; \nbreak;\ncase 41: this.$ = $$[$0-1].concat([$$[$0]]); \nbreak;\ncase 42: this.$ = $$[$0]; \nbreak;\ncase 43: this.$ = $$[$0]; \nbreak;\ncase 44: this.$ = $$[$0]; \nbreak;\ncase 45: this.$ = {type: 'fn', ns: undefined, name: $$[$0], scope: undefined}; \nbreak;\ncase 46: this.$ = {type: 'fn', ns: $$[$0-2], name: $$[$0], scope: undefined}; \nbreak;\ncase 47: this.$ = {type: 'fn', ns: undefined, name: $$[$0-2], scope: $$[$0]}; \nbreak;\ncase 48: this.$ = {type: 'fn', ns: $$[$0-4], name: $$[$0-2], scope: $$[$0]}; \nbreak;\n}\n},\ntable: [{1:[2,1],3:1,4:2,6:3,7:[1,4],8:5,9:6,12:7,14:8,16:[1,9]},{1:[3]},{5:[1,10],7:[1,11]},{5:[2,3],7:[2,3]},{5:[2,5],7:[2,5]},{5:[2,6],7:[2,6]},{10:[1,12],13:[1,13]},{10:[2,8],13:[2,8]},{10:[2,10],13:[2,10],15:14,22:15,24:16,25:17,26:18,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{10:[2,12],13:[2,12],17:[1,31],18:[1,32],27:[2,12],29:[2,12],30:[2,12],31:[2,12],32:[2,12],33:[2,12],34:[2,12],35:[2,12],37:[2,12],38:[2,12],39:[2,12]},{1:[2,2]},{6:33,7:[1,4],8:5,9:6,12:7,14:8,16:[1,9]},{11:34,16:[1,39],19:35,20:36,22:37,23:38,24:16,25:17,26:18,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{12:40,14:8,16:[1,9]},{10:[2,11],13:[2,11],22:41,24:16,25:17,26:18,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{5:[2,23],7:[2,23],10:[2,23],13:[2,23],21:[2,23],27:[2,23],28:[2,23],29:[2,23],30:[2,23],31:[2,23],32:[2,23],33:[2,23],34:[2,23],35:[2,23],37:[2,23],38:[2,23],39:[2,23]},{5:[2,25],7:[2,25],10:[2,25],13:[2,25],21:[2,25],27:[2,25],28:[2,25],29:[2,25],30:[2,25],31:[2,25],32:[2,25],33:[2,25],34:[2,25],35:[2,25],37:[2,25],38:[2,25],39:[2,25]},{5:[2,26],7:[2,26],10:[2,26],13:[2,26],21:[2,26],27:[2,26],28:[2,26],29:[2,26],30:[2,26],31:[2,26],32:[2,26],33:[2,26],34:[2,26],35:[2,26],37:[2,26],38:[2,26],39:[2,26]},{5:[2,27],7:[2,27],10:[2,27],13:[2,27],21:[2,27],27:[2,27],28:[2,27],29:[2,27],30:[2,27],31:[2,27],32:[2,27],33:[2,27],34:[2,27],35:[2,27],37:[2,27],38:[2,27],39:[2,27]},{5:[2,30],7:[2,30],10:[2,30],13:[2,30],21:[2,30],27:[2,30],28:[2,30],29:[2,30],30:[2,30],31:[2,30],32:[2,30],33:[2,30],34:[2,30],35:[2,30],37:[2,30],38:[2,30],39:[2,30],41:[2,30]},{5:[2,31],7:[2,31],10:[2,31],13:[2,31],21:[2,31],27:[2,31],28:[2,31],29:[2,31],30:[2,31],31:[2,31],32:[2,31],33:[2,31],34:[2,31],35:[2,31],37:[2,31],38:[2,31],39:[2,31],41:[2,31]},{5:[2,32],7:[2,32],10:[2,32],13:[2,32],21:[2,32],27:[2,32],28:[2,32],29:[2,32],30:[2,32],31:[2,32],32:[2,32],33:[2,32],34:[2,32],35:[2,32],37:[2,32],38:[2,32],39:[2,32],41:[2,32]},{5:[2,33],7:[2,33],10:[2,33],13:[2,33],21:[2,33],27:[2,33],28:[2,33],29:[2,33],30:[2,33],31:[2,33],32:[2,33],33:[2,33],34:[2,33],35:[2,33],37:[2,33],38:[2,33],39:[2,33],41:[2,33]},{5:[2,34],7:[2,34],10:[2,34],13:[2,34],21:[2,34],27:[2,34],28:[2,34],29:[2,34],30:[2,34],31:[2,34],32:[2,34],33:[2,34],34:[2,34],35:[2,34],37:[2,34],38:[2,34],39:[2,34],41:[2,34]},{5:[2,35],7:[2,35],10:[2,35],13:[2,35],21:[2,35],27:[2,35],28:[2,35],29:[2,35],30:[2,35],31:[2,35],32:[2,35],33:[2,35],34:[2,35],35:[2,35],37:[2,35],38:[2,35],39:[2,35],41:[2,35]},{5:[2,36],7:[2,36],10:[2,36],13:[2,36],21:[2,36],27:[2,36],28:[2,36],29:[2,36],30:[2,36],31:[2,36],32:[2,36],33:[2,36],34:[2,36],35:[2,36],37:[2,36],38:[2,36],39:[2,36],41:[2,36]},{27:[2,40],29:[2,40],30:[2,40],31:[2,40],32:[2,40],33:[2,40],34:[2,40],35:[2,40],37:[2,40],38:[2,40],39:[2,40],40:42,41:[2,40]},{16:[1,39],19:43,20:36,22:37,23:38,24:16,25:17,26:18,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{27:[1,44]},{5:[2,37],7:[2,37],10:[2,37],13:[2,37],21:[2,37],27:[2,37],28:[2,37],29:[2,37],30:[2,37],31:[2,37],32:[2,37],33:[2,37],34:[2,37],35:[2,37],37:[2,37],38:[2,37],39:[2,37],41:[2,37]},{5:[2,38],7:[2,38],10:[2,38],13:[2,38],21:[2,38],27:[2,38],28:[2,38],29:[2,38],30:[2,38],31:[2,38],32:[2,38],33:[2,38],34:[2,38],35:[2,38],37:[2,38],38:[2,38],39:[2,38],41:[2,38]},{16:[1,45]},{16:[1,46]},{5:[2,4],7:[2,4]},{5:[2,7],7:[2,7],13:[1,47]},{5:[2,16],7:[2,16],13:[2,16],21:[1,48]},{5:[2,18],7:[2,18],13:[2,18],21:[2,18],28:[2,18]},{5:[2,20],7:[2,20],13:[2,20],21:[2,20],28:[2,20]},{5:[2,21],7:[2,21],13:[2,21],15:49,21:[2,21],22:15,24:16,25:17,26:18,27:[1,27],28:[2,21],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{5:[2,45],7:[2,45],13:[2,45],17:[1,50],18:[1,51],21:[2,45],27:[2,45],28:[2,45],29:[2,45],30:[2,45],31:[2,45],32:[2,45],33:[2,45],34:[2,45],35:[2,45],37:[2,45],38:[2,45],39:[2,45]},{10:[2,9],13:[2,9]},{5:[2,24],7:[2,24],10:[2,24],13:[2,24],21:[2,24],27:[2,24],28:[2,24],29:[2,24],30:[2,24],31:[2,24],32:[2,24],33:[2,24],34:[2,24],35:[2,24],37:[2,24],38:[2,24],39:[2,24]},{24:54,25:55,26:56,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26],41:[1,52],42:53},{21:[1,48],28:[1,57]},{16:[1,39],19:58,20:36,22:37,23:38,24:16,25:17,26:18,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{10:[2,13],13:[2,13],18:[1,59],27:[2,13],29:[2,13],30:[2,13],31:[2,13],32:[2,13],33:[2,13],34:[2,13],35:[2,13],37:[2,13],38:[2,13],39:[2,13]},{10:[2,14],13:[2,14],27:[2,14],29:[2,14],30:[2,14],31:[2,14],32:[2,14],33:[2,14],34:[2,14],35:[2,14],37:[2,14],38:[2,14],39:[2,14]},{16:[1,39],19:60,20:36,22:37,23:38,24:16,25:17,26:18,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{16:[1,39],20:61,22:37,23:38,24:16,25:17,26:18,27:[1,27],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{5:[2,22],7:[2,22],13:[2,22],21:[2,22],22:41,24:16,25:17,26:18,27:[1,27],28:[2,22],29:[1,28],30:[1,19],31:[1,20],32:[1,21],33:[1,22],34:[1,23],35:[1,24],36:25,37:[1,29],38:[1,30],39:[1,26]},{16:[1,62]},{16:[1,63]},{5:[2,39],7:[2,39],10:[2,39],13:[2,39],21:[2,39],27:[2,39],28:[2,39],29:[2,39],30:[2,39],31:[2,39],32:[2,39],33:[2,39],34:[2,39],35:[2,39],37:[2,39],38:[2,39],39:[2,39],41:[2,39]},{27:[2,41],29:[2,41],30:[2,41],31:[2,41],32:[2,41],33:[2,41],34:[2,41],35:[2,41],37:[2,41],38:[2,41],39:[2,41],41:[2,41]},{27:[2,42],29:[2,42],30:[2,42],31:[2,42],32:[2,42],33:[2,42],34:[2,42],35:[2,42],37:[2,42],38:[2,42],39:[2,42],41:[2,42]},{27:[2,43],29:[2,43],30:[2,43],31:[2,43],32:[2,43],33:[2,43],34:[2,43],35:[2,43],37:[2,43],38:[2,43],39:[2,43],41:[2,43]},{27:[2,44],29:[2,44],30:[2,44],31:[2,44],32:[2,44],33:[2,44],34:[2,44],35:[2,44],37:[2,44],38:[2,44],39:[2,44],41:[2,44]},{5:[2,28],7:[2,28],10:[2,28],13:[2,28],21:[2,28],27:[2,28],28:[2,28],29:[2,28],30:[2,28],31:[2,28],32:[2,28],33:[2,28],34:[2,28],35:[2,28],37:[2,28],38:[2,28],39:[2,28],41:[2,28]},{21:[1,48],28:[1,64]},{16:[1,65]},{5:[2,17],7:[2,17],13:[2,17],21:[1,48]},{5:[2,19],7:[2,19],13:[2,19],21:[2,19],28:[2,19]},{5:[2,46],7:[2,46],13:[2,46],18:[1,66],21:[2,46],27:[2,46],28:[2,46],29:[2,46],30:[2,46],31:[2,46],32:[2,46],33:[2,46],34:[2,46],35:[2,46],37:[2,46],38:[2,46],39:[2,46]},{5:[2,47],7:[2,47],13:[2,47],21:[2,47],27:[2,47],28:[2,47],29:[2,47],30:[2,47],31:[2,47],32:[2,47],33:[2,47],34:[2,47],35:[2,47],37:[2,47],38:[2,47],39:[2,47]},{5:[2,29],7:[2,29],10:[2,29],13:[2,29],21:[2,29],27:[2,29],28:[2,29],29:[2,29],30:[2,29],31:[2,29],32:[2,29],33:[2,29],34:[2,29],35:[2,29],37:[2,29],38:[2,29],39:[2,29],41:[2,29]},{10:[2,15],13:[2,15],27:[2,15],29:[2,15],30:[2,15],31:[2,15],32:[2,15],33:[2,15],34:[2,15],35:[2,15],37:[2,15],38:[2,15],39:[2,15]},{16:[1,67]},{5:[2,48],7:[2,48],13:[2,48],21:[2,48],27:[2,48],28:[2,48],29:[2,48],30:[2,48],31:[2,48],32:[2,48],33:[2,48],34:[2,48],35:[2,48],37:[2,48],38:[2,48],39:[2,48]}],\ndefaultActions: {10:[2,2]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == 'undefined') {\n        this.lexer.yylloc = {};\n    }\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n    if (typeof this.yy.parseError === 'function') {\n        this.parseError = this.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || EOF;\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + this.lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: this.lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: this.lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                this.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.2.1 */\nvar lexer = (function(){\nvar lexer = {\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 38\nbreak;\ncase 2:return 37\nbreak;\ncase 3:return 34 \nbreak;\ncase 4:return 33\nbreak;\ncase 5:return 30\nbreak;\ncase 6:return 31\nbreak;\ncase 7:return 32\nbreak;\ncase 8:return 10\nbreak;\ncase 9:return 16\nbreak;\ncase 10:return 'DBLQUOTE'\nbreak;\ncase 11:return 29\nbreak;\ncase 12:return 27\nbreak;\ncase 13:return 28\nbreak;\ncase 14:return 39\nbreak;\ncase 15:return 41\nbreak;\ncase 16:return '^'\nbreak;\ncase 17:return 18\nbreak;\ncase 18:return 21\nbreak;\ncase 19:return 13\nbreak;\ncase 20:return 17\nbreak;\ncase 21:return 7\nbreak;\ncase 22:return ':'\nbreak;\ncase 23:return 35\nbreak;\ncase 24:return 5\nbreak;\ncase 25:return 'INVALID'\nbreak;\n}\n},\nrules: [/^(?:\\s+)/,/^(?:[0-9]+\\.[0-9]*)/,/^(?:[0-9]+)/,/^(?:`.*`)/,/^(?:\"(\\\\.|[^\\\\\"]*?)\")/,/^(?:NaN\\b)/,/^(?:null\\b)/,/^(?::([a-z0-9]+))/,/^(?::)/,/^(?:[A-Za-z_\\-<>+*=$#%^&!?][A-Za-z0-9_\\-<>+*=$#%^&!?]*)/,/^(?:\")/,/^(?:')/,/^(?:\\()/,/^(?:\\))/,/^(?:\\[)/,/^(?:\\])/,/^(?:\\^)/,/^(?:@)/,/^(?:\\|)/,/^(?:,)/,/^(?:\\/)/,/^(?:;)/,/^(?::)/,/^(?:\\/(?:[^\\/]|\\\\\\/)*\\/)/,/^(?:$)/,/^(?:.)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25],\"inclusive\":true}}\n};\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n}).call(this);}\n});","mtime":1384435897529,"type":"commonjs","path":"npm://dna-lang@0.2.19"},"main":{"name":"main","sources":"\n/*ZB:  main */\n(function() {\n  (function(AppState) {\n    var $, CSMTS, CSQS, debug, error, hello, info, init_dna, proto, realm, run_init_queue, warn, _ref, _ref1;\n    proto = require('libprotocol');\n    proto.discover_protocols();\n    _ref = proto.dispatch_impl('ILogger', \"\" + realm + \"/Main\"), info = _ref.info, warn = _ref.warn, error = _ref.error, debug = _ref.debug;\n    _ref1 = require('queue-manager'), run_init_queue = _ref1.run_init_queue, CSQS = _ref1.CSQS, CSMTS = _ref1.CSMTS;\n    $ = proto.dispatch_impl('IDom', document.body);\n    realm = AppState.realm;\n    init_dna = {\n      type: CSMTS.CUSTOM_INIT,\n      modname: 'init-dna',\n      queue: CSQS.INIT_QUEUE,\n      fun: function() {\n        var dna, dp, get_config;\n        dna = require('dna-lang');\n        get_config = require('config').get_config;\n        dp = get_config('ENV.DEFAULT_PROTOCOLS', AppState);\n        return dna.start_synthesis(document.body, dp);\n      }\n    };\n    hello = {\n      type: CSMTS.CUSTOM_INIT,\n      modname: 'hello',\n      queue: CSQS.INIT_QUEUE,\n      fun: function() {\n        return info('hello');\n      }\n    };\n    return $.on_dom_ready(function() {\n      return run_init_queue([init_dna, hello], AppState);\n    });\n  })(AppState);\n\n}).call(this);\n;","mtime":1384437767409,"type":"plainjs","path":"main.coffee"},"initial-state":{"name":"initial-state","sources":"\n/*ZB:  initial-state */\n(function() {\n  var _base;\n\n  window.AppState || (window.AppState = {});\n\n  (_base = window.AppState).realm || (_base.realm = 'dna-playground');\n\n}).call(this);\n;","mtime":1384434581378,"type":"plainjs","path":"state.coffee"},"libstate":{"name":"libstate","sources":"\n\n/*ZB: libstate */\nrequire.define('libstate', {\n\n/*ZB:  libstate/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var MY_STATE, get_state, lazy_init_my_state, swap_state, unwatch_state, watch_state, _AppState,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  _AppState = window.AppState;\n\n  MY_STATE = '_state';\n\n  lazy_init_my_state = function() {\n    var _base, _base1;\n\n    _AppState.modstate || (_AppState.modstate = {});\n    (_base = _AppState.modstate)[MY_STATE] || (_base[MY_STATE] = {});\n    return (_base1 = _AppState.modstate[MY_STATE]).watchers || (_base1.watchers = {});\n  };\n\n  get_state = function(key, __AppState) {\n    if (key && key !== MY_STATE) {\n      lazy_init_my_state();\n      return _AppState.modstate[key];\n    } else {\n      return void 0;\n    }\n  };\n\n  swap_state = function(key, mutator) {\n    var new_state, old_state, _ref;\n\n    if (key && key !== MY_STATE) {\n      lazy_init_my_state();\n      old_state = _AppState.modstate[key];\n      new_state = mutator(old_state);\n      _AppState.modstate[key] = new_state;\n      return (_ref = _AppState.modstate[MY_STATE].watchers[key]) != null ? _ref.map(function(h) {\n        return h(old_state, new_state);\n      }) : void 0;\n    }\n  };\n\n  watch_state = function(key, handler) {\n    var _base;\n\n    lazy_init_my_state();\n    (_base = _AppState.modstate[MY_STATE].watchers)[key] || (_base[key] = []);\n    if (__indexOf.call(_AppState.modstate[MY_STATE].watchers[key], handler) < 0) {\n      return _AppState.modstate[MY_STATE].watchers[key].push(handler);\n    }\n  };\n\n  unwatch_state = function(key, handler) {\n    var _base;\n\n    lazy_init_my_state();\n    (_base = _AppState.modstate[MY_STATE].watchers)[key] || (_base[key] = []);\n    if (__indexOf.call(_AppState.modstate[MY_STATE].watchers[key], handler) >= 0) {\n      return _AppState.modstate[MY_STATE].watchers[key] = _AppState.modstate[MY_STATE].watchers[key].filter(function(h) {\n        return h !== handler;\n      });\n    }\n  };\n\n  module.exports = {\n    get_state: get_state,\n    swap_state: swap_state,\n    watch_state: watch_state,\n    unwatch_state: unwatch_state\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435896560,"type":"commonjs","path":"npm://libstate@0.0.1"},"config":{"name":"config","sources":"\n\n/*ZB:  */\nrequire.define('', {\n\n/*ZB:  /config */\n'config': function(exports, require, module) {(function() {\n(function() {\n  var get, get_config, get_data, on_config_changed, pub, pubsubhub, set, set_config, set_data, sub, _AppState, _ref,\n    __slice = [].slice;\n\n  _AppState = window.AppState;\n\n  pubsubhub = require('libprotein').pubsubhub;\n\n  _ref = pubsubhub(), pub = _ref.pub, sub = _ref.sub;\n\n  get_data = function(store, _arg) {\n    var k, tail;\n    k = _arg[0], tail = 2 <= _arg.length ? __slice.call(_arg, 1) : [];\n    if (!store) {\n      return void 0;\n    }\n    if (tail.length) {\n      return get_data(store[k], tail);\n    } else {\n      return store[k];\n    }\n  };\n\n  set_data = function(store, _arg, data) {\n    var k, tail;\n    k = _arg[0], tail = 2 <= _arg.length ? __slice.call(_arg, 1) : [];\n    if (!k) {\n      return void 0;\n    }\n    if (tail.length) {\n      store[k] || (store[k] = {});\n      store[k] = set_data(store[k], tail, data);\n      return store;\n    } else {\n      store[k] = data;\n      return store;\n    }\n  };\n\n  get_config = function(key, _arg) {\n    var config;\n    config = (_arg != null ? _arg : _AppState).config;\n    return get_data(config, key.split('.'));\n  };\n\n  set_config = function(key, value, _arg) {\n    var config;\n    config = (_arg != null ? _arg : _AppState).config;\n    set_data(config, key.split('.'), value);\n    return pub(key, get_config(key));\n  };\n\n  get = get_config;\n\n  set = set_config;\n\n  on_config_changed = function(key, handler, _arg) {\n    var config;\n    config = (_arg != null ? _arg : _AppState).config;\n    return sub(key, handler);\n  };\n\n  module.exports = {\n    get_config: get_config,\n    set_config: set_config,\n    on_config_changed: on_config_changed,\n    get: get,\n    set: set\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435525862,"type":"commonjs","path":"config.coffee"},"commonjs-jquery":{"name":"commonjs-jquery","sources":"\n\n/*ZB: commonjs-jquery */\nrequire.define('commonjs-jquery', {\n\n/*ZB:  commonjs-jquery/index */\n'index': function(exports, require, module) {(function() {\nmodule.exports = require('commonjs-jquery')\n}).call(this);},\n\n/*ZB:  commonjs-jquery/commonjs-jquery */\n'commonjs-jquery': function(exports, require, module) {(function() {\n(function() {\n  var create = function(window, noConflictMode) {\n    var navigator = window.navigator;\n    var location = window.location;\n    /*!\n     * jQuery JavaScript Library v1.7.1\n     * http://jquery.com/\n     *\n     * Copyright 2011, John Resig\n     * Dual licensed under the MIT or GPL Version 2 licenses.\n     * http://jquery.org/license\n     *\n     * Includes Sizzle.js\n     * http://sizzlejs.com/\n     * Copyright 2011, The Dojo Foundation\n     * Released under the MIT, BSD, and GPL Licenses.\n     *\n     * Date: Mon Nov 21 21:11:03 2011 -0500\n     */\n    (function( window, undefined ) {\n    \n    // Use the correct document accordingly with window argument (sandbox)\n    var document = window.document,\n    \tnavigator = window.navigator,\n    \tlocation = window.location;\n    var jQuery = (function() {\n    \n    // Define a local copy of jQuery\n    var jQuery = function( selector, context ) {\n    \t\t// The jQuery object is actually just the init constructor 'enhanced'\n    \t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n    \t},\n    \n    \t// Map over jQuery in case of overwrite\n    \t_jQuery = window.jQuery,\n    \n    \t// Map over the $ in case of overwrite\n    \t_$ = window.$,\n    \n    \t// A central reference to the root jQuery(document)\n    \trootjQuery,\n    \n    \t// A simple way to check for HTML strings or ID strings\n    \t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n    \tquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n    \n    \t// Check if a string has a non-whitespace character in it\n    \trnotwhite = /\\S/,\n    \n    \t// Used for trimming whitespace\n    \ttrimLeft = /^\\s+/,\n    \ttrimRight = /\\s+$/,\n    \n    \t// Match a standalone tag\n    \trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,\n    \n    \t// JSON RegExp\n    \trvalidchars = /^[\\],:{}\\s]*$/,\n    \trvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n    \trvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n    \trvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n    \n    \t// Useragent RegExp\n    \trwebkit = /(webkit)[ \\/]([\\w.]+)/,\n    \tropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n    \trmsie = /(msie) ([\\w.]+)/,\n    \trmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n    \n    \t// Matches dashed string for camelizing\n    \trdashAlpha = /-([a-z]|[0-9])/ig,\n    \trmsPrefix = /^-ms-/,\n    \n    \t// Used by jQuery.camelCase as callback to replace()\n    \tfcamelCase = function( all, letter ) {\n    \t\treturn ( letter + \"\" ).toUpperCase();\n    \t},\n    \n    \t// Keep a UserAgent string for use with jQuery.browser\n    \tuserAgent = navigator.userAgent,\n    \n    \t// For matching the engine and version of the browser\n    \tbrowserMatch,\n    \n    \t// The deferred used on DOM ready\n    \treadyList,\n    \n    \t// The ready event handler\n    \tDOMContentLoaded,\n    \n    \t// Save a reference to some core methods\n    \ttoString = Object.prototype.toString,\n    \thasOwn = Object.prototype.hasOwnProperty,\n    \tpush = Array.prototype.push,\n    \tslice = Array.prototype.slice,\n    \ttrim = String.prototype.trim,\n    \tindexOf = Array.prototype.indexOf,\n    \n    \t// [[Class]] -> type pairs\n    \tclass2type = {};\n    \n    jQuery.fn = jQuery.prototype = {\n    \tconstructor: jQuery,\n    \tinit: function( selector, context, rootjQuery ) {\n    \t\tvar match, elem, ret, doc;\n    \n    \t\t// Handle $(\"\"), $(null), or $(undefined)\n    \t\tif ( !selector ) {\n    \t\t\treturn this;\n    \t\t}\n    \n    \t\t// Handle $(DOMElement)\n    \t\tif ( selector.nodeType ) {\n    \t\t\tthis.context = this[0] = selector;\n    \t\t\tthis.length = 1;\n    \t\t\treturn this;\n    \t\t}\n    \n    \t\t// The body element only exists once, optimize finding it\n    \t\tif ( selector === \"body\" && !context && document.body ) {\n    \t\t\tthis.context = document;\n    \t\t\tthis[0] = document.body;\n    \t\t\tthis.selector = selector;\n    \t\t\tthis.length = 1;\n    \t\t\treturn this;\n    \t\t}\n    \n    \t\t// Handle HTML strings\n    \t\tif ( typeof selector === \"string\" ) {\n    \t\t\t// Are we dealing with HTML string or an ID?\n    \t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n    \t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n    \t\t\t\tmatch = [ null, selector, null ];\n    \n    \t\t\t} else {\n    \t\t\t\tmatch = quickExpr.exec( selector );\n    \t\t\t}\n    \n    \t\t\t// Verify a match, and that no context was specified for #id\n    \t\t\tif ( match && (match[1] || !context) ) {\n    \n    \t\t\t\t// HANDLE: $(html) -> $(array)\n    \t\t\t\tif ( match[1] ) {\n    \t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n    \t\t\t\t\tdoc = ( context ? context.ownerDocument || context : document );\n    \n    \t\t\t\t\t// If a single string is passed in and it's a single tag\n    \t\t\t\t\t// just do a createElement and skip the rest\n    \t\t\t\t\tret = rsingleTag.exec( selector );\n    \n    \t\t\t\t\tif ( ret ) {\n    \t\t\t\t\t\tif ( jQuery.isPlainObject( context ) ) {\n    \t\t\t\t\t\t\tselector = [ document.createElement( ret[1] ) ];\n    \t\t\t\t\t\t\tjQuery.fn.attr.call( selector, context, true );\n    \n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\tselector = [ doc.createElement( ret[1] ) ];\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tret = jQuery.buildFragment( [ match[1] ], [ doc ] );\n    \t\t\t\t\t\tselector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;\n    \t\t\t\t\t}\n    \n    \t\t\t\t\treturn jQuery.merge( this, selector );\n    \n    \t\t\t\t// HANDLE: $(\"#id\")\n    \t\t\t\t} else {\n    \t\t\t\t\telem = document.getElementById( match[2] );\n    \n    \t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n    \t\t\t\t\t// nodes that are no longer in the document #6963\n    \t\t\t\t\tif ( elem && elem.parentNode ) {\n    \t\t\t\t\t\t// Handle the case where IE and Opera return items\n    \t\t\t\t\t\t// by name instead of ID\n    \t\t\t\t\t\tif ( elem.id !== match[2] ) {\n    \t\t\t\t\t\t\treturn rootjQuery.find( selector );\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n    \t\t\t\t\t\tthis.length = 1;\n    \t\t\t\t\t\tthis[0] = elem;\n    \t\t\t\t\t}\n    \n    \t\t\t\t\tthis.context = document;\n    \t\t\t\t\tthis.selector = selector;\n    \t\t\t\t\treturn this;\n    \t\t\t\t}\n    \n    \t\t\t// HANDLE: $(expr, $(...))\n    \t\t\t} else if ( !context || context.jquery ) {\n    \t\t\t\treturn ( context || rootjQuery ).find( selector );\n    \n    \t\t\t// HANDLE: $(expr, context)\n    \t\t\t// (which is just equivalent to: $(context).find(expr)\n    \t\t\t} else {\n    \t\t\t\treturn this.constructor( context ).find( selector );\n    \t\t\t}\n    \n    \t\t// HANDLE: $(function)\n    \t\t// Shortcut for document ready\n    \t\t} else if ( jQuery.isFunction( selector ) ) {\n    \t\t\treturn rootjQuery.ready( selector );\n    \t\t}\n    \n    \t\tif ( selector.selector !== undefined ) {\n    \t\t\tthis.selector = selector.selector;\n    \t\t\tthis.context = selector.context;\n    \t\t}\n    \n    \t\treturn jQuery.makeArray( selector, this );\n    \t},\n    \n    \t// Start with an empty selector\n    \tselector: \"\",\n    \n    \t// The current version of jQuery being used\n    \tjquery: \"1.7.1\",\n    \n    \t// The default length of a jQuery object is 0\n    \tlength: 0,\n    \n    \t// The number of elements contained in the matched element set\n    \tsize: function() {\n    \t\treturn this.length;\n    \t},\n    \n    \ttoArray: function() {\n    \t\treturn slice.call( this, 0 );\n    \t},\n    \n    \t// Get the Nth element in the matched element set OR\n    \t// Get the whole matched element set as a clean array\n    \tget: function( num ) {\n    \t\treturn num == null ?\n    \n    \t\t\t// Return a 'clean' array\n    \t\t\tthis.toArray() :\n    \n    \t\t\t// Return just the object\n    \t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n    \t},\n    \n    \t// Take an array of elements and push it onto the stack\n    \t// (returning the new matched element set)\n    \tpushStack: function( elems, name, selector ) {\n    \t\t// Build a new jQuery matched element set\n    \t\tvar ret = this.constructor();\n    \n    \t\tif ( jQuery.isArray( elems ) ) {\n    \t\t\tpush.apply( ret, elems );\n    \n    \t\t} else {\n    \t\t\tjQuery.merge( ret, elems );\n    \t\t}\n    \n    \t\t// Add the old object onto the stack (as a reference)\n    \t\tret.prevObject = this;\n    \n    \t\tret.context = this.context;\n    \n    \t\tif ( name === \"find\" ) {\n    \t\t\tret.selector = this.selector + ( this.selector ? \" \" : \"\" ) + selector;\n    \t\t} else if ( name ) {\n    \t\t\tret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n    \t\t}\n    \n    \t\t// Return the newly-formed element set\n    \t\treturn ret;\n    \t},\n    \n    \t// Execute a callback for every element in the matched set.\n    \t// (You can seed the arguments with an array of args, but this is\n    \t// only used internally.)\n    \teach: function( callback, args ) {\n    \t\treturn jQuery.each( this, callback, args );\n    \t},\n    \n    \tready: function( fn ) {\n    \t\t// Attach the listeners\n    \t\tjQuery.bindReady();\n    \n    \t\t// Add the callback\n    \t\treadyList.add( fn );\n    \n    \t\treturn this;\n    \t},\n    \n    \teq: function( i ) {\n    \t\ti = +i;\n    \t\treturn i === -1 ?\n    \t\t\tthis.slice( i ) :\n    \t\t\tthis.slice( i, i + 1 );\n    \t},\n    \n    \tfirst: function() {\n    \t\treturn this.eq( 0 );\n    \t},\n    \n    \tlast: function() {\n    \t\treturn this.eq( -1 );\n    \t},\n    \n    \tslice: function() {\n    \t\treturn this.pushStack( slice.apply( this, arguments ),\n    \t\t\t\"slice\", slice.call(arguments).join(\",\") );\n    \t},\n    \n    \tmap: function( callback ) {\n    \t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n    \t\t\treturn callback.call( elem, i, elem );\n    \t\t}));\n    \t},\n    \n    \tend: function() {\n    \t\treturn this.prevObject || this.constructor(null);\n    \t},\n    \n    \t// For internal use only.\n    \t// Behaves like an Array's method, not like a jQuery method.\n    \tpush: push,\n    \tsort: [].sort,\n    \tsplice: [].splice\n    };\n    \n    // Give the init function the jQuery prototype for later instantiation\n    jQuery.fn.init.prototype = jQuery.fn;\n    \n    jQuery.extend = jQuery.fn.extend = function() {\n    \tvar options, name, src, copy, copyIsArray, clone,\n    \t\ttarget = arguments[0] || {},\n    \t\ti = 1,\n    \t\tlength = arguments.length,\n    \t\tdeep = false;\n    \n    \t// Handle a deep copy situation\n    \tif ( typeof target === \"boolean\" ) {\n    \t\tdeep = target;\n    \t\ttarget = arguments[1] || {};\n    \t\t// skip the boolean and the target\n    \t\ti = 2;\n    \t}\n    \n    \t// Handle case when target is a string or something (possible in deep copy)\n    \tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n    \t\ttarget = {};\n    \t}\n    \n    \t// extend jQuery itself if only one argument is passed\n    \tif ( length === i ) {\n    \t\ttarget = this;\n    \t\t--i;\n    \t}\n    \n    \tfor ( ; i < length; i++ ) {\n    \t\t// Only deal with non-null/undefined values\n    \t\tif ( (options = arguments[ i ]) != null ) {\n    \t\t\t// Extend the base object\n    \t\t\tfor ( name in options ) {\n    \t\t\t\tsrc = target[ name ];\n    \t\t\t\tcopy = options[ name ];\n    \n    \t\t\t\t// Prevent never-ending loop\n    \t\t\t\tif ( target === copy ) {\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \n    \t\t\t\t// Recurse if we're merging plain objects or arrays\n    \t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n    \t\t\t\t\tif ( copyIsArray ) {\n    \t\t\t\t\t\tcopyIsArray = false;\n    \t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n    \n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Never move original objects, clone them\n    \t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n    \n    \t\t\t\t// Don't bring in undefined values\n    \t\t\t\t} else if ( copy !== undefined ) {\n    \t\t\t\t\ttarget[ name ] = copy;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \t// Return the modified object\n    \treturn target;\n    };\n    \n    jQuery.extend({\n    \tnoConflict: function( deep ) {\n    \t\tif ( window.$ === jQuery ) {\n    \t\t\twindow.$ = _$;\n    \t\t}\n    \n    \t\tif ( deep && window.jQuery === jQuery ) {\n    \t\t\twindow.jQuery = _jQuery;\n    \t\t}\n    \n    \t\treturn jQuery;\n    \t},\n    \n    \t// Is the DOM ready to be used? Set to true once it occurs.\n    \tisReady: false,\n    \n    \t// A counter to track how many items to wait for before\n    \t// the ready event fires. See #6781\n    \treadyWait: 1,\n    \n    \t// Hold (or release) the ready event\n    \tholdReady: function( hold ) {\n    \t\tif ( hold ) {\n    \t\t\tjQuery.readyWait++;\n    \t\t} else {\n    \t\t\tjQuery.ready( true );\n    \t\t}\n    \t},\n    \n    \t// Handle when the DOM is ready\n    \tready: function( wait ) {\n    \t\t// Either a released hold or an DOMready/load event and not yet ready\n    \t\tif ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {\n    \t\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n    \t\t\tif ( !document.body ) {\n    \t\t\t\treturn setTimeout( jQuery.ready, 1 );\n    \t\t\t}\n    \n    \t\t\t// Remember that the DOM is ready\n    \t\t\tjQuery.isReady = true;\n    \n    \t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n    \t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n    \t\t\t\treturn;\n    \t\t\t}\n    \n    \t\t\t// If there are functions bound, to execute\n    \t\t\treadyList.fireWith( document, [ jQuery ] );\n    \n    \t\t\t// Trigger any bound ready events\n    \t\t\tif ( jQuery.fn.trigger ) {\n    \t\t\t\tjQuery( document ).trigger( \"ready\" ).off( \"ready\" );\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \tbindReady: function() {\n    \t\tif ( readyList ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\treadyList = jQuery.Callbacks( \"once memory\" );\n    \n    \t\t// Catch cases where $(document).ready() is called after the\n    \t\t// browser event has already occurred.\n    \t\tif ( document.readyState === \"complete\" ) {\n    \t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n    \t\t\treturn setTimeout( jQuery.ready, 1 );\n    \t\t}\n    \n    \t\t// Mozilla, Opera and webkit nightlies currently support this event\n    \t\tif ( document.addEventListener ) {\n    \t\t\t// Use the handy event callback\n    \t\t\tdocument.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n    \n    \t\t\t// A fallback to window.onload, that will always work\n    \t\t\twindow.addEventListener( \"load\", jQuery.ready, false );\n    \n    \t\t// If IE event model is used\n    \t\t} else if ( document.attachEvent ) {\n    \t\t\t// ensure firing before onload,\n    \t\t\t// maybe late but safe also for iframes\n    \t\t\tdocument.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n    \n    \t\t\t// A fallback to window.onload, that will always work\n    \t\t\twindow.attachEvent( \"onload\", jQuery.ready );\n    \n    \t\t\t// If IE and not a frame\n    \t\t\t// continually check to see if the document is ready\n    \t\t\tvar toplevel = false;\n    \n    \t\t\ttry {\n    \t\t\t\ttoplevel = window.frameElement == null;\n    \t\t\t} catch(e) {}\n    \n    \t\t\tif ( document.documentElement.doScroll && toplevel ) {\n    \t\t\t\tdoScrollCheck();\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \t// See test/unit/core.js for details concerning isFunction.\n    \t// Since version 1.3, DOM methods and functions like alert\n    \t// aren't supported. They return false on IE (#2968).\n    \tisFunction: function( obj ) {\n    \t\treturn jQuery.type(obj) === \"function\";\n    \t},\n    \n    \tisArray: Array.isArray || function( obj ) {\n    \t\treturn jQuery.type(obj) === \"array\";\n    \t},\n    \n    \t// A crude way of determining if an object is a window\n    \tisWindow: function( obj ) {\n    \t\treturn obj && typeof obj === \"object\" && \"setInterval\" in obj;\n    \t},\n    \n    \tisNumeric: function( obj ) {\n    \t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n    \t},\n    \n    \ttype: function( obj ) {\n    \t\treturn obj == null ?\n    \t\t\tString( obj ) :\n    \t\t\tclass2type[ toString.call(obj) ] || \"object\";\n    \t},\n    \n    \tisPlainObject: function( obj ) {\n    \t\t// Must be an Object.\n    \t\t// Because of IE, we also have to check the presence of the constructor property.\n    \t\t// Make sure that DOM nodes and window objects don't pass through, as well\n    \t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n    \t\t\treturn false;\n    \t\t}\n    \n    \t\ttry {\n    \t\t\t// Not own constructor property must be Object\n    \t\t\tif ( obj.constructor &&\n    \t\t\t\t!hasOwn.call(obj, \"constructor\") &&\n    \t\t\t\t!hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t} catch ( e ) {\n    \t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n    \t\t\treturn false;\n    \t\t}\n    \n    \t\t// Own properties are enumerated firstly, so to speed up,\n    \t\t// if last one is own, then all properties are own.\n    \n    \t\tvar key;\n    \t\tfor ( key in obj ) {}\n    \n    \t\treturn key === undefined || hasOwn.call( obj, key );\n    \t},\n    \n    \tisEmptyObject: function( obj ) {\n    \t\tfor ( var name in obj ) {\n    \t\t\treturn false;\n    \t\t}\n    \t\treturn true;\n    \t},\n    \n    \terror: function( msg ) {\n    \t\tthrow new Error( msg );\n    \t},\n    \n    \tparseJSON: function( data ) {\n    \t\tif ( typeof data !== \"string\" || !data ) {\n    \t\t\treturn null;\n    \t\t}\n    \n    \t\t// Make sure leading/trailing whitespace is removed (IE can't handle it)\n    \t\tdata = jQuery.trim( data );\n    \n    \t\t// Attempt to parse using the native JSON parser first\n    \t\tif ( window.JSON && window.JSON.parse ) {\n    \t\t\treturn window.JSON.parse( data );\n    \t\t}\n    \n    \t\t// Make sure the incoming data is actual JSON\n    \t\t// Logic borrowed from http://json.org/json2.js\n    \t\tif ( rvalidchars.test( data.replace( rvalidescape, \"@\" )\n    \t\t\t.replace( rvalidtokens, \"]\" )\n    \t\t\t.replace( rvalidbraces, \"\")) ) {\n    \n    \t\t\treturn ( new Function( \"return \" + data ) )();\n    \n    \t\t}\n    \t\tjQuery.error( \"Invalid JSON: \" + data );\n    \t},\n    \n    \t// Cross-browser xml parsing\n    \tparseXML: function( data ) {\n    \t\tvar xml, tmp;\n    \t\ttry {\n    \t\t\tif ( window.DOMParser ) { // Standard\n    \t\t\t\ttmp = new DOMParser();\n    \t\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n    \t\t\t} else { // IE\n    \t\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n    \t\t\t\txml.async = \"false\";\n    \t\t\t\txml.loadXML( data );\n    \t\t\t}\n    \t\t} catch( e ) {\n    \t\t\txml = undefined;\n    \t\t}\n    \t\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n    \t\t\tjQuery.error( \"Invalid XML: \" + data );\n    \t\t}\n    \t\treturn xml;\n    \t},\n    \n    \tnoop: function() {},\n    \n    \t// Evaluates a script in a global context\n    \t// Workarounds based on findings by Jim Driscoll\n    \t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n    \tglobalEval: function( data ) {\n    \t\tif ( data && rnotwhite.test( data ) ) {\n    \t\t\t// We use execScript on Internet Explorer\n    \t\t\t// We use an anonymous function so that context is window\n    \t\t\t// rather than jQuery in Firefox\n    \t\t\t( window.execScript || function( data ) {\n    \t\t\t\twindow[ \"eval\" ].call( window, data );\n    \t\t\t} )( data );\n    \t\t}\n    \t},\n    \n    \t// Convert dashed to camelCase; used by the css and data modules\n    \t// Microsoft forgot to hump their vendor prefix (#9572)\n    \tcamelCase: function( string ) {\n    \t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n    \t},\n    \n    \tnodeName: function( elem, name ) {\n    \t\treturn elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();\n    \t},\n    \n    \t// args is for internal usage only\n    \teach: function( object, callback, args ) {\n    \t\tvar name, i = 0,\n    \t\t\tlength = object.length,\n    \t\t\tisObj = length === undefined || jQuery.isFunction( object );\n    \n    \t\tif ( args ) {\n    \t\t\tif ( isObj ) {\n    \t\t\t\tfor ( name in object ) {\n    \t\t\t\t\tif ( callback.apply( object[ name ], args ) === false ) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t} else {\n    \t\t\t\tfor ( ; i < length; ) {\n    \t\t\t\t\tif ( callback.apply( object[ i++ ], args ) === false ) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t// A special, fast, case for the most common use of each\n    \t\t} else {\n    \t\t\tif ( isObj ) {\n    \t\t\t\tfor ( name in object ) {\n    \t\t\t\t\tif ( callback.call( object[ name ], name, object[ name ] ) === false ) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t} else {\n    \t\t\t\tfor ( ; i < length; ) {\n    \t\t\t\t\tif ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn object;\n    \t},\n    \n    \t// Use native String.trim function wherever possible\n    \ttrim: trim ?\n    \t\tfunction( text ) {\n    \t\t\treturn text == null ?\n    \t\t\t\t\"\" :\n    \t\t\t\ttrim.call( text );\n    \t\t} :\n    \n    \t\t// Otherwise use our own trimming functionality\n    \t\tfunction( text ) {\n    \t\t\treturn text == null ?\n    \t\t\t\t\"\" :\n    \t\t\t\ttext.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n    \t\t},\n    \n    \t// results is for internal usage only\n    \tmakeArray: function( array, results ) {\n    \t\tvar ret = results || [];\n    \n    \t\tif ( array != null ) {\n    \t\t\t// The window, strings (and functions) also have 'length'\n    \t\t\t// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n    \t\t\tvar type = jQuery.type( array );\n    \n    \t\t\tif ( array.length == null || type === \"string\" || type === \"function\" || type === \"regexp\" || jQuery.isWindow( array ) ) {\n    \t\t\t\tpush.call( ret, array );\n    \t\t\t} else {\n    \t\t\t\tjQuery.merge( ret, array );\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn ret;\n    \t},\n    \n    \tinArray: function( elem, array, i ) {\n    \t\tvar len;\n    \n    \t\tif ( array ) {\n    \t\t\tif ( indexOf ) {\n    \t\t\t\treturn indexOf.call( array, elem, i );\n    \t\t\t}\n    \n    \t\t\tlen = array.length;\n    \t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n    \n    \t\t\tfor ( ; i < len; i++ ) {\n    \t\t\t\t// Skip accessing in sparse arrays\n    \t\t\t\tif ( i in array && array[ i ] === elem ) {\n    \t\t\t\t\treturn i;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn -1;\n    \t},\n    \n    \tmerge: function( first, second ) {\n    \t\tvar i = first.length,\n    \t\t\tj = 0;\n    \n    \t\tif ( typeof second.length === \"number\" ) {\n    \t\t\tfor ( var l = second.length; j < l; j++ ) {\n    \t\t\t\tfirst[ i++ ] = second[ j ];\n    \t\t\t}\n    \n    \t\t} else {\n    \t\t\twhile ( second[j] !== undefined ) {\n    \t\t\t\tfirst[ i++ ] = second[ j++ ];\n    \t\t\t}\n    \t\t}\n    \n    \t\tfirst.length = i;\n    \n    \t\treturn first;\n    \t},\n    \n    \tgrep: function( elems, callback, inv ) {\n    \t\tvar ret = [], retVal;\n    \t\tinv = !!inv;\n    \n    \t\t// Go through the array, only saving the items\n    \t\t// that pass the validator function\n    \t\tfor ( var i = 0, length = elems.length; i < length; i++ ) {\n    \t\t\tretVal = !!callback( elems[ i ], i );\n    \t\t\tif ( inv !== retVal ) {\n    \t\t\t\tret.push( elems[ i ] );\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn ret;\n    \t},\n    \n    \t// arg is for internal usage only\n    \tmap: function( elems, callback, arg ) {\n    \t\tvar value, key, ret = [],\n    \t\t\ti = 0,\n    \t\t\tlength = elems.length,\n    \t\t\t// jquery objects are treated as arrays\n    \t\t\tisArray = elems instanceof jQuery || length !== undefined && typeof length === \"number\" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;\n    \n    \t\t// Go through the array, translating each of the items to their\n    \t\tif ( isArray ) {\n    \t\t\tfor ( ; i < length; i++ ) {\n    \t\t\t\tvalue = callback( elems[ i ], i, arg );\n    \n    \t\t\t\tif ( value != null ) {\n    \t\t\t\t\tret[ ret.length ] = value;\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t// Go through every key on the object,\n    \t\t} else {\n    \t\t\tfor ( key in elems ) {\n    \t\t\t\tvalue = callback( elems[ key ], key, arg );\n    \n    \t\t\t\tif ( value != null ) {\n    \t\t\t\t\tret[ ret.length ] = value;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Flatten any nested arrays\n    \t\treturn ret.concat.apply( [], ret );\n    \t},\n    \n    \t// A global GUID counter for objects\n    \tguid: 1,\n    \n    \t// Bind a function to a context, optionally partially applying any\n    \t// arguments.\n    \tproxy: function( fn, context ) {\n    \t\tif ( typeof context === \"string\" ) {\n    \t\t\tvar tmp = fn[ context ];\n    \t\t\tcontext = fn;\n    \t\t\tfn = tmp;\n    \t\t}\n    \n    \t\t// Quick check to determine if target is callable, in the spec\n    \t\t// this throws a TypeError, but we will just return undefined.\n    \t\tif ( !jQuery.isFunction( fn ) ) {\n    \t\t\treturn undefined;\n    \t\t}\n    \n    \t\t// Simulated bind\n    \t\tvar args = slice.call( arguments, 2 ),\n    \t\t\tproxy = function() {\n    \t\t\t\treturn fn.apply( context, args.concat( slice.call( arguments ) ) );\n    \t\t\t};\n    \n    \t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n    \t\tproxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;\n    \n    \t\treturn proxy;\n    \t},\n    \n    \t// Mutifunctional method to get and set values to a collection\n    \t// The value/s can optionally be executed if it's a function\n    \taccess: function( elems, key, value, exec, fn, pass ) {\n    \t\tvar length = elems.length;\n    \n    \t\t// Setting many attributes\n    \t\tif ( typeof key === \"object\" ) {\n    \t\t\tfor ( var k in key ) {\n    \t\t\t\tjQuery.access( elems, k, key[k], exec, fn, value );\n    \t\t\t}\n    \t\t\treturn elems;\n    \t\t}\n    \n    \t\t// Setting one attribute\n    \t\tif ( value !== undefined ) {\n    \t\t\t// Optionally, function values get executed if exec is true\n    \t\t\texec = !pass && exec && jQuery.isFunction(value);\n    \n    \t\t\tfor ( var i = 0; i < length; i++ ) {\n    \t\t\t\tfn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n    \t\t\t}\n    \n    \t\t\treturn elems;\n    \t\t}\n    \n    \t\t// Getting an attribute\n    \t\treturn length ? fn( elems[0], key ) : undefined;\n    \t},\n    \n    \tnow: function() {\n    \t\treturn ( new Date() ).getTime();\n    \t},\n    \n    \t// Use of jQuery.browser is frowned upon.\n    \t// More details: http://docs.jquery.com/Utilities/jQuery.browser\n    \tuaMatch: function( ua ) {\n    \t\tua = ua.toLowerCase();\n    \n    \t\tvar match = rwebkit.exec( ua ) ||\n    \t\t\tropera.exec( ua ) ||\n    \t\t\trmsie.exec( ua ) ||\n    \t\t\tua.indexOf(\"compatible\") < 0 && rmozilla.exec( ua ) ||\n    \t\t\t[];\n    \n    \t\treturn { browser: match[1] || \"\", version: match[2] || \"0\" };\n    \t},\n    \n    \tsub: function() {\n    \t\tfunction jQuerySub( selector, context ) {\n    \t\t\treturn new jQuerySub.fn.init( selector, context );\n    \t\t}\n    \t\tjQuery.extend( true, jQuerySub, this );\n    \t\tjQuerySub.superclass = this;\n    \t\tjQuerySub.fn = jQuerySub.prototype = this();\n    \t\tjQuerySub.fn.constructor = jQuerySub;\n    \t\tjQuerySub.sub = this.sub;\n    \t\tjQuerySub.fn.init = function init( selector, context ) {\n    \t\t\tif ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {\n    \t\t\t\tcontext = jQuerySub( context );\n    \t\t\t}\n    \n    \t\t\treturn jQuery.fn.init.call( this, selector, context, rootjQuerySub );\n    \t\t};\n    \t\tjQuerySub.fn.init.prototype = jQuerySub.fn;\n    \t\tvar rootjQuerySub = jQuerySub(document);\n    \t\treturn jQuerySub;\n    \t},\n    \n    \tbrowser: {}\n    });\n    \n    // Populate the class2type map\n    jQuery.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(i, name) {\n    \tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n    });\n    \n    browserMatch = jQuery.uaMatch( userAgent );\n    if ( browserMatch.browser ) {\n    \tjQuery.browser[ browserMatch.browser ] = true;\n    \tjQuery.browser.version = browserMatch.version;\n    }\n    \n    // Deprecated, use jQuery.browser.webkit instead\n    if ( jQuery.browser.webkit ) {\n    \tjQuery.browser.safari = true;\n    }\n    \n    // IE doesn't match non-breaking spaces with \\s\n    if ( rnotwhite.test( \"\\xA0\" ) ) {\n    \ttrimLeft = /^[\\s\\xA0]+/;\n    \ttrimRight = /[\\s\\xA0]+$/;\n    }\n    \n    // All jQuery objects should point back to these\n    rootjQuery = jQuery(document);\n    \n    // Cleanup functions for the document ready method\n    if ( document.addEventListener ) {\n    \tDOMContentLoaded = function() {\n    \t\tdocument.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n    \t\tjQuery.ready();\n    \t};\n    \n    } else if ( document.attachEvent ) {\n    \tDOMContentLoaded = function() {\n    \t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n    \t\tif ( document.readyState === \"complete\" ) {\n    \t\t\tdocument.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n    \t\t\tjQuery.ready();\n    \t\t}\n    \t};\n    }\n    \n    // The DOM ready check for Internet Explorer\n    function doScrollCheck() {\n    \tif ( jQuery.isReady ) {\n    \t\treturn;\n    \t}\n    \n    \ttry {\n    \t\t// If IE is used, use the trick by Diego Perini\n    \t\t// http://javascript.nwbox.com/IEContentLoaded/\n    \t\tdocument.documentElement.doScroll(\"left\");\n    \t} catch(e) {\n    \t\tsetTimeout( doScrollCheck, 1 );\n    \t\treturn;\n    \t}\n    \n    \t// and execute any waiting functions\n    \tjQuery.ready();\n    }\n    \n    return jQuery;\n    \n    })();\n    \n    \n    // String to Object flags format cache\n    var flagsCache = {};\n    \n    // Convert String-formatted flags into Object-formatted ones and store in cache\n    function createFlags( flags ) {\n    \tvar object = flagsCache[ flags ] = {},\n    \t\ti, length;\n    \tflags = flags.split( /\\s+/ );\n    \tfor ( i = 0, length = flags.length; i < length; i++ ) {\n    \t\tobject[ flags[i] ] = true;\n    \t}\n    \treturn object;\n    }\n    \n    /*\n     * Create a callback list using the following parameters:\n     *\n     *\tflags:\tan optional list of space-separated flags that will change how\n     *\t\t\tthe callback list behaves\n     *\n     * By default a callback list will act like an event callback list and can be\n     * \"fired\" multiple times.\n     *\n     * Possible flags:\n     *\n     *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n     *\n     *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n     *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n     *\t\t\t\t\tvalues (like a Deferred)\n     *\n     *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n     *\n     *\tstopOnFalse:\tinterrupt callings when a callback returns false\n     *\n     */\n    jQuery.Callbacks = function( flags ) {\n    \n    \t// Convert flags from String-formatted to Object-formatted\n    \t// (we check in cache first)\n    \tflags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};\n    \n    \tvar // Actual callback list\n    \t\tlist = [],\n    \t\t// Stack of fire calls for repeatable lists\n    \t\tstack = [],\n    \t\t// Last fire value (for non-forgettable lists)\n    \t\tmemory,\n    \t\t// Flag to know if list is currently firing\n    \t\tfiring,\n    \t\t// First callback to fire (used internally by add and fireWith)\n    \t\tfiringStart,\n    \t\t// End of the loop when firing\n    \t\tfiringLength,\n    \t\t// Index of currently firing callback (modified by remove if needed)\n    \t\tfiringIndex,\n    \t\t// Add one or several callbacks to the list\n    \t\tadd = function( args ) {\n    \t\t\tvar i,\n    \t\t\t\tlength,\n    \t\t\t\telem,\n    \t\t\t\ttype,\n    \t\t\t\tactual;\n    \t\t\tfor ( i = 0, length = args.length; i < length; i++ ) {\n    \t\t\t\telem = args[ i ];\n    \t\t\t\ttype = jQuery.type( elem );\n    \t\t\t\tif ( type === \"array\" ) {\n    \t\t\t\t\t// Inspect recursively\n    \t\t\t\t\tadd( elem );\n    \t\t\t\t} else if ( type === \"function\" ) {\n    \t\t\t\t\t// Add if not in unique mode and callback is not in\n    \t\t\t\t\tif ( !flags.unique || !self.has( elem ) ) {\n    \t\t\t\t\t\tlist.push( elem );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \t\t// Fire callbacks\n    \t\tfire = function( context, args ) {\n    \t\t\targs = args || [];\n    \t\t\tmemory = !flags.memory || [ context, args ];\n    \t\t\tfiring = true;\n    \t\t\tfiringIndex = firingStart || 0;\n    \t\t\tfiringStart = 0;\n    \t\t\tfiringLength = list.length;\n    \t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n    \t\t\t\tif ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {\n    \t\t\t\t\tmemory = true; // Mark as halted\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfiring = false;\n    \t\t\tif ( list ) {\n    \t\t\t\tif ( !flags.once ) {\n    \t\t\t\t\tif ( stack && stack.length ) {\n    \t\t\t\t\t\tmemory = stack.shift();\n    \t\t\t\t\t\tself.fireWith( memory[ 0 ], memory[ 1 ] );\n    \t\t\t\t\t}\n    \t\t\t\t} else if ( memory === true ) {\n    \t\t\t\t\tself.disable();\n    \t\t\t\t} else {\n    \t\t\t\t\tlist = [];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \t\t// Actual Callbacks object\n    \t\tself = {\n    \t\t\t// Add a callback or a collection of callbacks to the list\n    \t\t\tadd: function() {\n    \t\t\t\tif ( list ) {\n    \t\t\t\t\tvar length = list.length;\n    \t\t\t\t\tadd( arguments );\n    \t\t\t\t\t// Do we need to add the callbacks to the\n    \t\t\t\t\t// current firing batch?\n    \t\t\t\t\tif ( firing ) {\n    \t\t\t\t\t\tfiringLength = list.length;\n    \t\t\t\t\t// With memory, if we're not firing then\n    \t\t\t\t\t// we should call right away, unless previous\n    \t\t\t\t\t// firing was halted (stopOnFalse)\n    \t\t\t\t\t} else if ( memory && memory !== true ) {\n    \t\t\t\t\t\tfiringStart = length;\n    \t\t\t\t\t\tfire( memory[ 0 ], memory[ 1 ] );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\treturn this;\n    \t\t\t},\n    \t\t\t// Remove a callback from the list\n    \t\t\tremove: function() {\n    \t\t\t\tif ( list ) {\n    \t\t\t\t\tvar args = arguments,\n    \t\t\t\t\t\targIndex = 0,\n    \t\t\t\t\t\targLength = args.length;\n    \t\t\t\t\tfor ( ; argIndex < argLength ; argIndex++ ) {\n    \t\t\t\t\t\tfor ( var i = 0; i < list.length; i++ ) {\n    \t\t\t\t\t\t\tif ( args[ argIndex ] === list[ i ] ) {\n    \t\t\t\t\t\t\t\t// Handle firingIndex and firingLength\n    \t\t\t\t\t\t\t\tif ( firing ) {\n    \t\t\t\t\t\t\t\t\tif ( i <= firingLength ) {\n    \t\t\t\t\t\t\t\t\t\tfiringLength--;\n    \t\t\t\t\t\t\t\t\t\tif ( i <= firingIndex ) {\n    \t\t\t\t\t\t\t\t\t\t\tfiringIndex--;\n    \t\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t// Remove the element\n    \t\t\t\t\t\t\t\tlist.splice( i--, 1 );\n    \t\t\t\t\t\t\t\t// If we have some unicity property then\n    \t\t\t\t\t\t\t\t// we only need to do this once\n    \t\t\t\t\t\t\t\tif ( flags.unique ) {\n    \t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\treturn this;\n    \t\t\t},\n    \t\t\t// Control if a given callback is in the list\n    \t\t\thas: function( fn ) {\n    \t\t\t\tif ( list ) {\n    \t\t\t\t\tvar i = 0,\n    \t\t\t\t\t\tlength = list.length;\n    \t\t\t\t\tfor ( ; i < length; i++ ) {\n    \t\t\t\t\t\tif ( fn === list[ i ] ) {\n    \t\t\t\t\t\t\treturn true;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\treturn false;\n    \t\t\t},\n    \t\t\t// Remove all callbacks from the list\n    \t\t\tempty: function() {\n    \t\t\t\tlist = [];\n    \t\t\t\treturn this;\n    \t\t\t},\n    \t\t\t// Have the list do nothing anymore\n    \t\t\tdisable: function() {\n    \t\t\t\tlist = stack = memory = undefined;\n    \t\t\t\treturn this;\n    \t\t\t},\n    \t\t\t// Is it disabled?\n    \t\t\tdisabled: function() {\n    \t\t\t\treturn !list;\n    \t\t\t},\n    \t\t\t// Lock the list in its current state\n    \t\t\tlock: function() {\n    \t\t\t\tstack = undefined;\n    \t\t\t\tif ( !memory || memory === true ) {\n    \t\t\t\t\tself.disable();\n    \t\t\t\t}\n    \t\t\t\treturn this;\n    \t\t\t},\n    \t\t\t// Is it locked?\n    \t\t\tlocked: function() {\n    \t\t\t\treturn !stack;\n    \t\t\t},\n    \t\t\t// Call all callbacks with the given context and arguments\n    \t\t\tfireWith: function( context, args ) {\n    \t\t\t\tif ( stack ) {\n    \t\t\t\t\tif ( firing ) {\n    \t\t\t\t\t\tif ( !flags.once ) {\n    \t\t\t\t\t\t\tstack.push( [ context, args ] );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t} else if ( !( flags.once && memory ) ) {\n    \t\t\t\t\t\tfire( context, args );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\treturn this;\n    \t\t\t},\n    \t\t\t// Call all the callbacks with the given arguments\n    \t\t\tfire: function() {\n    \t\t\t\tself.fireWith( this, arguments );\n    \t\t\t\treturn this;\n    \t\t\t},\n    \t\t\t// To know if the callbacks have already been called at least once\n    \t\t\tfired: function() {\n    \t\t\t\treturn !!memory;\n    \t\t\t}\n    \t\t};\n    \n    \treturn self;\n    };\n    \n    \n    \n    \n    var // Static reference to slice\n    \tsliceDeferred = [].slice;\n    \n    jQuery.extend({\n    \n    \tDeferred: function( func ) {\n    \t\tvar doneList = jQuery.Callbacks( \"once memory\" ),\n    \t\t\tfailList = jQuery.Callbacks( \"once memory\" ),\n    \t\t\tprogressList = jQuery.Callbacks( \"memory\" ),\n    \t\t\tstate = \"pending\",\n    \t\t\tlists = {\n    \t\t\t\tresolve: doneList,\n    \t\t\t\treject: failList,\n    \t\t\t\tnotify: progressList\n    \t\t\t},\n    \t\t\tpromise = {\n    \t\t\t\tdone: doneList.add,\n    \t\t\t\tfail: failList.add,\n    \t\t\t\tprogress: progressList.add,\n    \n    \t\t\t\tstate: function() {\n    \t\t\t\t\treturn state;\n    \t\t\t\t},\n    \n    \t\t\t\t// Deprecated\n    \t\t\t\tisResolved: doneList.fired,\n    \t\t\t\tisRejected: failList.fired,\n    \n    \t\t\t\tthen: function( doneCallbacks, failCallbacks, progressCallbacks ) {\n    \t\t\t\t\tdeferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );\n    \t\t\t\t\treturn this;\n    \t\t\t\t},\n    \t\t\t\talways: function() {\n    \t\t\t\t\tdeferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );\n    \t\t\t\t\treturn this;\n    \t\t\t\t},\n    \t\t\t\tpipe: function( fnDone, fnFail, fnProgress ) {\n    \t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n    \t\t\t\t\t\tjQuery.each( {\n    \t\t\t\t\t\t\tdone: [ fnDone, \"resolve\" ],\n    \t\t\t\t\t\t\tfail: [ fnFail, \"reject\" ],\n    \t\t\t\t\t\t\tprogress: [ fnProgress, \"notify\" ]\n    \t\t\t\t\t\t}, function( handler, data ) {\n    \t\t\t\t\t\t\tvar fn = data[ 0 ],\n    \t\t\t\t\t\t\t\taction = data[ 1 ],\n    \t\t\t\t\t\t\t\treturned;\n    \t\t\t\t\t\t\tif ( jQuery.isFunction( fn ) ) {\n    \t\t\t\t\t\t\t\tdeferred[ handler ](function() {\n    \t\t\t\t\t\t\t\t\treturned = fn.apply( this, arguments );\n    \t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n    \t\t\t\t\t\t\t\t\t\treturned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );\n    \t\t\t\t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === deferred ? newDefer : this, [ returned ] );\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t});\n    \t\t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t\tdeferred[ handler ]( newDefer[ action ] );\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t});\n    \t\t\t\t\t}).promise();\n    \t\t\t\t},\n    \t\t\t\t// Get a promise for this deferred\n    \t\t\t\t// If obj is provided, the promise aspect is added to the object\n    \t\t\t\tpromise: function( obj ) {\n    \t\t\t\t\tif ( obj == null ) {\n    \t\t\t\t\t\tobj = promise;\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tfor ( var key in promise ) {\n    \t\t\t\t\t\t\tobj[ key ] = promise[ key ];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\treturn obj;\n    \t\t\t\t}\n    \t\t\t},\n    \t\t\tdeferred = promise.promise({}),\n    \t\t\tkey;\n    \n    \t\tfor ( key in lists ) {\n    \t\t\tdeferred[ key ] = lists[ key ].fire;\n    \t\t\tdeferred[ key + \"With\" ] = lists[ key ].fireWith;\n    \t\t}\n    \n    \t\t// Handle state\n    \t\tdeferred.done( function() {\n    \t\t\tstate = \"resolved\";\n    \t\t}, failList.disable, progressList.lock ).fail( function() {\n    \t\t\tstate = \"rejected\";\n    \t\t}, doneList.disable, progressList.lock );\n    \n    \t\t// Call given func if any\n    \t\tif ( func ) {\n    \t\t\tfunc.call( deferred, deferred );\n    \t\t}\n    \n    \t\t// All done!\n    \t\treturn deferred;\n    \t},\n    \n    \t// Deferred helper\n    \twhen: function( firstParam ) {\n    \t\tvar args = sliceDeferred.call( arguments, 0 ),\n    \t\t\ti = 0,\n    \t\t\tlength = args.length,\n    \t\t\tpValues = new Array( length ),\n    \t\t\tcount = length,\n    \t\t\tpCount = length,\n    \t\t\tdeferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?\n    \t\t\t\tfirstParam :\n    \t\t\t\tjQuery.Deferred(),\n    \t\t\tpromise = deferred.promise();\n    \t\tfunction resolveFunc( i ) {\n    \t\t\treturn function( value ) {\n    \t\t\t\targs[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;\n    \t\t\t\tif ( !( --count ) ) {\n    \t\t\t\t\tdeferred.resolveWith( deferred, args );\n    \t\t\t\t}\n    \t\t\t};\n    \t\t}\n    \t\tfunction progressFunc( i ) {\n    \t\t\treturn function( value ) {\n    \t\t\t\tpValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;\n    \t\t\t\tdeferred.notifyWith( promise, pValues );\n    \t\t\t};\n    \t\t}\n    \t\tif ( length > 1 ) {\n    \t\t\tfor ( ; i < length; i++ ) {\n    \t\t\t\tif ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {\n    \t\t\t\t\targs[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );\n    \t\t\t\t} else {\n    \t\t\t\t\t--count;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif ( !count ) {\n    \t\t\t\tdeferred.resolveWith( deferred, args );\n    \t\t\t}\n    \t\t} else if ( deferred !== firstParam ) {\n    \t\t\tdeferred.resolveWith( deferred, length ? [ firstParam ] : [] );\n    \t\t}\n    \t\treturn promise;\n    \t}\n    });\n    \n    \n    \n    \n    jQuery.support = (function() {\n    \n    \tvar support,\n    \t\tall,\n    \t\ta,\n    \t\tselect,\n    \t\topt,\n    \t\tinput,\n    \t\tmarginDiv,\n    \t\tfragment,\n    \t\ttds,\n    \t\tevents,\n    \t\teventName,\n    \t\ti,\n    \t\tisSupported,\n    \t\tdiv = document.createElement( \"div\" ),\n    \t\tdocumentElement = document.documentElement;\n    \n    \t// Preliminary tests\n    \tdiv.setAttribute(\"className\", \"t\");\n    \tdiv.innerHTML = \"   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>\";\n    \n    \tall = div.getElementsByTagName( \"*\" );\n    \ta = div.getElementsByTagName( \"a\" )[ 0 ];\n    \n    \t// Can't get basic test support\n    \tif ( !all || !all.length || !a ) {\n    \t\treturn {};\n    \t}\n    \n    \t// First batch of supports tests\n    \tselect = document.createElement( \"select\" );\n    \topt = select.appendChild( document.createElement(\"option\") );\n    \tinput = div.getElementsByTagName( \"input\" )[ 0 ];\n    \n    \tsupport = {\n    \t\t// IE strips leading whitespace when .innerHTML is used\n    \t\tleadingWhitespace: ( div.firstChild.nodeType === 3 ),\n    \n    \t\t// Make sure that tbody elements aren't automatically inserted\n    \t\t// IE will insert them into empty tables\n    \t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n    \n    \t\t// Make sure that link elements get serialized correctly by innerHTML\n    \t\t// This requires a wrapper element in IE\n    \t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n    \n    \t\t// Get the style information from getAttribute\n    \t\t// (IE uses .cssText instead)\n    \t\tstyle: /top/.test( a.getAttribute(\"style\") ),\n    \n    \t\t// Make sure that URLs aren't manipulated\n    \t\t// (IE normalizes it by default)\n    \t\threfNormalized: ( a.getAttribute(\"href\") === \"/a\" ),\n    \n    \t\t// Make sure that element opacity exists\n    \t\t// (IE uses filter instead)\n    \t\t// Use a regex to work around a WebKit issue. See #5145\n    \t\topacity: /^0.55/.test( a.style.opacity ),\n    \n    \t\t// Verify style float existence\n    \t\t// (IE uses styleFloat instead of cssFloat)\n    \t\tcssFloat: !!a.style.cssFloat,\n    \n    \t\t// Make sure that if no value is specified for a checkbox\n    \t\t// that it defaults to \"on\".\n    \t\t// (WebKit defaults to \"\" instead)\n    \t\tcheckOn: ( input.value === \"on\" ),\n    \n    \t\t// Make sure that a selected-by-default option has a working selected property.\n    \t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n    \t\toptSelected: opt.selected,\n    \n    \t\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n    \t\tgetSetAttribute: div.className !== \"t\",\n    \n    \t\t// Tests for enctype support on a form(#6743)\n    \t\tenctype: !!document.createElement(\"form\").enctype,\n    \n    \t\t// Makes sure cloning an html5 element does not cause problems\n    \t\t// Where outerHTML is undefined, this still works\n    \t\thtml5Clone: document.createElement(\"nav\").cloneNode( true ).outerHTML !== \"<:nav></:nav>\",\n    \n    \t\t// Will be defined later\n    \t\tsubmitBubbles: true,\n    \t\tchangeBubbles: true,\n    \t\tfocusinBubbles: false,\n    \t\tdeleteExpando: true,\n    \t\tnoCloneEvent: true,\n    \t\tinlineBlockNeedsLayout: false,\n    \t\tshrinkWrapBlocks: false,\n    \t\treliableMarginRight: true\n    \t};\n    \n    \t// Make sure checked status is properly cloned\n    \tinput.checked = true;\n    \tsupport.noCloneChecked = input.cloneNode( true ).checked;\n    \n    \t// Make sure that the options inside disabled selects aren't marked as disabled\n    \t// (WebKit marks them as disabled)\n    \tselect.disabled = true;\n    \tsupport.optDisabled = !opt.disabled;\n    \n    \t// Test to see if it's possible to delete an expando from an element\n    \t// Fails in Internet Explorer\n    \ttry {\n    \t\tdelete div.test;\n    \t} catch( e ) {\n    \t\tsupport.deleteExpando = false;\n    \t}\n    \n    \tif ( !div.addEventListener && div.attachEvent && div.fireEvent ) {\n    \t\tdiv.attachEvent( \"onclick\", function() {\n    \t\t\t// Cloning a node shouldn't copy over any\n    \t\t\t// bound event handlers (IE does this)\n    \t\t\tsupport.noCloneEvent = false;\n    \t\t});\n    \t\tdiv.cloneNode( true ).fireEvent( \"onclick\" );\n    \t}\n    \n    \t// Check if a radio maintains its value\n    \t// after being appended to the DOM\n    \tinput = document.createElement(\"input\");\n    \tinput.value = \"t\";\n    \tinput.setAttribute(\"type\", \"radio\");\n    \tsupport.radioValue = input.value === \"t\";\n    \n    \tinput.setAttribute(\"checked\", \"checked\");\n    \tdiv.appendChild( input );\n    \tfragment = document.createDocumentFragment();\n    \tfragment.appendChild( div.lastChild );\n    \n    \t// WebKit doesn't clone checked state correctly in fragments\n    \tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n    \n    \t// Check if a disconnected checkbox will retain its checked\n    \t// value of true after appended to the DOM (IE6/7)\n    \tsupport.appendChecked = input.checked;\n    \n    \tfragment.removeChild( input );\n    \tfragment.appendChild( div );\n    \n    \tdiv.innerHTML = \"\";\n    \n    \t// Check if div with explicit width and no margin-right incorrectly\n    \t// gets computed margin-right based on width of container. For more\n    \t// info see bug #3333\n    \t// Fails in WebKit before Feb 2011 nightlies\n    \t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n    \tif ( window.getComputedStyle ) {\n    \t\tmarginDiv = document.createElement( \"div\" );\n    \t\tmarginDiv.style.width = \"0\";\n    \t\tmarginDiv.style.marginRight = \"0\";\n    \t\tdiv.style.width = \"2px\";\n    \t\tdiv.appendChild( marginDiv );\n    \t\tsupport.reliableMarginRight =\n    \t\t\t( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;\n    \t}\n    \n    \t// Technique from Juriy Zaytsev\n    \t// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/\n    \t// We only care about the case where non-standard event systems\n    \t// are used, namely in IE. Short-circuiting here helps us to\n    \t// avoid an eval call (in setAttribute) which can cause CSP\n    \t// to go haywire. See: https://developer.mozilla.org/en/Security/CSP\n    \tif ( div.attachEvent ) {\n    \t\tfor( i in {\n    \t\t\tsubmit: 1,\n    \t\t\tchange: 1,\n    \t\t\tfocusin: 1\n    \t\t}) {\n    \t\t\teventName = \"on\" + i;\n    \t\t\tisSupported = ( eventName in div );\n    \t\t\tif ( !isSupported ) {\n    \t\t\t\tdiv.setAttribute( eventName, \"return;\" );\n    \t\t\t\tisSupported = ( typeof div[ eventName ] === \"function\" );\n    \t\t\t}\n    \t\t\tsupport[ i + \"Bubbles\" ] = isSupported;\n    \t\t}\n    \t}\n    \n    \tfragment.removeChild( div );\n    \n    \t// Null elements to avoid leaks in IE\n    \tfragment = select = opt = marginDiv = div = input = null;\n    \n    \t// Run tests that need a body at doc ready\n    \tjQuery(function() {\n    \t\tvar container, outer, inner, table, td, offsetSupport,\n    \t\t\tconMarginTop, ptlm, vb, style, html,\n    \t\t\tbody = document.getElementsByTagName(\"body\")[0];\n    \n    \t\tif ( !body ) {\n    \t\t\t// Return for frameset docs that don't have a body\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tconMarginTop = 1;\n    \t\tptlm = \"position:absolute;top:0;left:0;width:1px;height:1px;margin:0;\";\n    \t\tvb = \"visibility:hidden;border:0;\";\n    \t\tstyle = \"style='\" + ptlm + \"border:5px solid #000;padding:0;'\";\n    \t\thtml = \"<div \" + style + \"><div></div></div>\" +\n    \t\t\t\"<table \" + style + \" cellpadding='0' cellspacing='0'>\" +\n    \t\t\t\"<tr><td></td></tr></table>\";\n    \n    \t\tcontainer = document.createElement(\"div\");\n    \t\tcontainer.style.cssText = vb + \"width:0;height:0;position:static;top:0;margin-top:\" + conMarginTop + \"px\";\n    \t\tbody.insertBefore( container, body.firstChild );\n    \n    \t\t// Construct the test element\n    \t\tdiv = document.createElement(\"div\");\n    \t\tcontainer.appendChild( div );\n    \n    \t\t// Check if table cells still have offsetWidth/Height when they are set\n    \t\t// to display:none and there are still other visible table cells in a\n    \t\t// table row; if so, offsetWidth/Height are not reliable for use when\n    \t\t// determining if an element has been hidden directly using\n    \t\t// display:none (it is still safe to use offsets if a parent element is\n    \t\t// hidden; don safety goggles and see bug #4512 for more information).\n    \t\t// (only IE 8 fails this test)\n    \t\tdiv.innerHTML = \"<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>\";\n    \t\ttds = div.getElementsByTagName( \"td\" );\n    \t\tisSupported = ( tds[ 0 ].offsetHeight === 0 );\n    \n    \t\ttds[ 0 ].style.display = \"\";\n    \t\ttds[ 1 ].style.display = \"none\";\n    \n    \t\t// Check if empty table cells still have offsetWidth/Height\n    \t\t// (IE <= 8 fail this test)\n    \t\tsupport.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n    \n    \t\t// Figure out if the W3C box model works as expected\n    \t\tdiv.innerHTML = \"\";\n    \t\tdiv.style.width = div.style.paddingLeft = \"1px\";\n    \t\tjQuery.boxModel = support.boxModel = div.offsetWidth === 2;\n    \n    \t\tif ( typeof div.style.zoom !== \"undefined\" ) {\n    \t\t\t// Check if natively block-level elements act like inline-block\n    \t\t\t// elements when setting their display to 'inline' and giving\n    \t\t\t// them layout\n    \t\t\t// (IE < 8 does this)\n    \t\t\tdiv.style.display = \"inline\";\n    \t\t\tdiv.style.zoom = 1;\n    \t\t\tsupport.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );\n    \n    \t\t\t// Check if elements with layout shrink-wrap their children\n    \t\t\t// (IE 6 does this)\n    \t\t\tdiv.style.display = \"\";\n    \t\t\tdiv.innerHTML = \"<div style='width:4px;'></div>\";\n    \t\t\tsupport.shrinkWrapBlocks = ( div.offsetWidth !== 2 );\n    \t\t}\n    \n    \t\tdiv.style.cssText = ptlm + vb;\n    \t\tdiv.innerHTML = html;\n    \n    \t\touter = div.firstChild;\n    \t\tinner = outer.firstChild;\n    \t\ttd = outer.nextSibling.firstChild.firstChild;\n    \n    \t\toffsetSupport = {\n    \t\t\tdoesNotAddBorder: ( inner.offsetTop !== 5 ),\n    \t\t\tdoesAddBorderForTableAndCells: ( td.offsetTop === 5 )\n    \t\t};\n    \n    \t\tinner.style.position = \"fixed\";\n    \t\tinner.style.top = \"20px\";\n    \n    \t\t// safari subtracts parent border width here which is 5px\n    \t\toffsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );\n    \t\tinner.style.position = inner.style.top = \"\";\n    \n    \t\touter.style.overflow = \"hidden\";\n    \t\touter.style.position = \"relative\";\n    \n    \t\toffsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );\n    \t\toffsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );\n    \n    \t\tbody.removeChild( container );\n    \t\tdiv  = container = null;\n    \n    \t\tjQuery.extend( support, offsetSupport );\n    \t});\n    \n    \treturn support;\n    })();\n    \n    \n    \n    \n    var rbrace = /^(?:\\{.*\\}|\\[.*\\])$/,\n    \trmultiDash = /([A-Z])/g;\n    \n    jQuery.extend({\n    \tcache: {},\n    \n    \t// Please use with caution\n    \tuuid: 0,\n    \n    \t// Unique for each copy of jQuery on the page\n    \t// Non-digits removed to match rinlinejQuery\n    \texpando: \"jQuery\" + ( jQuery.fn.jquery + Math.random() ).replace( /\\D/g, \"\" ),\n    \n    \t// The following elements throw uncatchable exceptions if you\n    \t// attempt to add expando properties to them.\n    \tnoData: {\n    \t\t\"embed\": true,\n    \t\t// Ban all objects except for Flash (which handle expandos)\n    \t\t\"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n    \t\t\"applet\": true\n    \t},\n    \n    \thasData: function( elem ) {\n    \t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n    \t\treturn !!elem && !isEmptyDataObject( elem );\n    \t},\n    \n    \tdata: function( elem, name, data, pvt /* Internal Use Only */ ) {\n    \t\tif ( !jQuery.acceptData( elem ) ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tvar privateCache, thisCache, ret,\n    \t\t\tinternalKey = jQuery.expando,\n    \t\t\tgetByName = typeof name === \"string\",\n    \n    \t\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n    \t\t\t// can't GC object references properly across the DOM-JS boundary\n    \t\t\tisNode = elem.nodeType,\n    \n    \t\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n    \t\t\t// attached directly to the object so GC can occur automatically\n    \t\t\tcache = isNode ? jQuery.cache : elem,\n    \n    \t\t\t// Only defining an ID for JS objects if its cache already exists allows\n    \t\t\t// the code to shortcut on the same path as a DOM node with no cache\n    \t\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,\n    \t\t\tisEvents = name === \"events\";\n    \n    \t\t// Avoid doing any more work than we need to when trying to get data on an\n    \t\t// object that has no data at all\n    \t\tif ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tif ( !id ) {\n    \t\t\t// Only DOM nodes need a new unique ID for each element since their data\n    \t\t\t// ends up in the global cache\n    \t\t\tif ( isNode ) {\n    \t\t\t\telem[ internalKey ] = id = ++jQuery.uuid;\n    \t\t\t} else {\n    \t\t\t\tid = internalKey;\n    \t\t\t}\n    \t\t}\n    \n    \t\tif ( !cache[ id ] ) {\n    \t\t\tcache[ id ] = {};\n    \n    \t\t\t// Avoids exposing jQuery metadata on plain JS objects when the object\n    \t\t\t// is serialized using JSON.stringify\n    \t\t\tif ( !isNode ) {\n    \t\t\t\tcache[ id ].toJSON = jQuery.noop;\n    \t\t\t}\n    \t\t}\n    \n    \t\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n    \t\t// shallow copied over onto the existing cache\n    \t\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n    \t\t\tif ( pvt ) {\n    \t\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n    \t\t\t} else {\n    \t\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n    \t\t\t}\n    \t\t}\n    \n    \t\tprivateCache = thisCache = cache[ id ];\n    \n    \t\t// jQuery data() is stored in a separate object inside the object's internal data\n    \t\t// cache in order to avoid key collisions between internal data and user-defined\n    \t\t// data.\n    \t\tif ( !pvt ) {\n    \t\t\tif ( !thisCache.data ) {\n    \t\t\t\tthisCache.data = {};\n    \t\t\t}\n    \n    \t\t\tthisCache = thisCache.data;\n    \t\t}\n    \n    \t\tif ( data !== undefined ) {\n    \t\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n    \t\t}\n    \n    \t\t// Users should not attempt to inspect the internal events object using jQuery.data,\n    \t\t// it is undocumented and subject to change. But does anyone listen? No.\n    \t\tif ( isEvents && !thisCache[ name ] ) {\n    \t\t\treturn privateCache.events;\n    \t\t}\n    \n    \t\t// Check for both converted-to-camel and non-converted data property names\n    \t\t// If a data property was specified\n    \t\tif ( getByName ) {\n    \n    \t\t\t// First Try to find as-is property data\n    \t\t\tret = thisCache[ name ];\n    \n    \t\t\t// Test for null|undefined property data\n    \t\t\tif ( ret == null ) {\n    \n    \t\t\t\t// Try to find the camelCased property\n    \t\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n    \t\t\t}\n    \t\t} else {\n    \t\t\tret = thisCache;\n    \t\t}\n    \n    \t\treturn ret;\n    \t},\n    \n    \tremoveData: function( elem, name, pvt /* Internal Use Only */ ) {\n    \t\tif ( !jQuery.acceptData( elem ) ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tvar thisCache, i, l,\n    \n    \t\t\t// Reference to internal data cache key\n    \t\t\tinternalKey = jQuery.expando,\n    \n    \t\t\tisNode = elem.nodeType,\n    \n    \t\t\t// See jQuery.data for more information\n    \t\t\tcache = isNode ? jQuery.cache : elem,\n    \n    \t\t\t// See jQuery.data for more information\n    \t\t\tid = isNode ? elem[ internalKey ] : internalKey;\n    \n    \t\t// If there is already no cache entry for this object, there is no\n    \t\t// purpose in continuing\n    \t\tif ( !cache[ id ] ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tif ( name ) {\n    \n    \t\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n    \n    \t\t\tif ( thisCache ) {\n    \n    \t\t\t\t// Support array or space separated string names for data keys\n    \t\t\t\tif ( !jQuery.isArray( name ) ) {\n    \n    \t\t\t\t\t// try the string as a key before any manipulation\n    \t\t\t\t\tif ( name in thisCache ) {\n    \t\t\t\t\t\tname = [ name ];\n    \t\t\t\t\t} else {\n    \n    \t\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n    \t\t\t\t\t\tname = jQuery.camelCase( name );\n    \t\t\t\t\t\tif ( name in thisCache ) {\n    \t\t\t\t\t\t\tname = [ name ];\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\tname = name.split( \" \" );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\tfor ( i = 0, l = name.length; i < l; i++ ) {\n    \t\t\t\t\tdelete thisCache[ name[i] ];\n    \t\t\t\t}\n    \n    \t\t\t\t// If there is no data left in the cache, we want to continue\n    \t\t\t\t// and let the cache object itself get destroyed\n    \t\t\t\tif ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\t// See jQuery.data for more information\n    \t\tif ( !pvt ) {\n    \t\t\tdelete cache[ id ].data;\n    \n    \t\t\t// Don't destroy the parent cache unless the internal data object\n    \t\t\t// had been the only thing left in it\n    \t\t\tif ( !isEmptyDataObject(cache[ id ]) ) {\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Browsers that fail expando deletion also refuse to delete expandos on\n    \t\t// the window, but it will allow it on all other JS objects; other browsers\n    \t\t// don't care\n    \t\t// Ensure that `cache` is not a window object #10080\n    \t\tif ( jQuery.support.deleteExpando || !cache.setInterval ) {\n    \t\t\tdelete cache[ id ];\n    \t\t} else {\n    \t\t\tcache[ id ] = null;\n    \t\t}\n    \n    \t\t// We destroyed the cache and need to eliminate the expando on the node to avoid\n    \t\t// false lookups in the cache for entries that no longer exist\n    \t\tif ( isNode ) {\n    \t\t\t// IE does not allow us to delete expando properties from nodes,\n    \t\t\t// nor does it have a removeAttribute function on Document nodes;\n    \t\t\t// we must handle all of these cases\n    \t\t\tif ( jQuery.support.deleteExpando ) {\n    \t\t\t\tdelete elem[ internalKey ];\n    \t\t\t} else if ( elem.removeAttribute ) {\n    \t\t\t\telem.removeAttribute( internalKey );\n    \t\t\t} else {\n    \t\t\t\telem[ internalKey ] = null;\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \t// For internal use only.\n    \t_data: function( elem, name, data ) {\n    \t\treturn jQuery.data( elem, name, data, true );\n    \t},\n    \n    \t// A method for determining if a DOM node can handle the data expando\n    \tacceptData: function( elem ) {\n    \t\tif ( elem.nodeName ) {\n    \t\t\tvar match = jQuery.noData[ elem.nodeName.toLowerCase() ];\n    \n    \t\t\tif ( match ) {\n    \t\t\t\treturn !(match === true || elem.getAttribute(\"classid\") !== match);\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn true;\n    \t}\n    });\n    \n    jQuery.fn.extend({\n    \tdata: function( key, value ) {\n    \t\tvar parts, attr, name,\n    \t\t\tdata = null;\n    \n    \t\tif ( typeof key === \"undefined\" ) {\n    \t\t\tif ( this.length ) {\n    \t\t\t\tdata = jQuery.data( this[0] );\n    \n    \t\t\t\tif ( this[0].nodeType === 1 && !jQuery._data( this[0], \"parsedAttrs\" ) ) {\n    \t\t\t\t\tattr = this[0].attributes;\n    \t\t\t\t\tfor ( var i = 0, l = attr.length; i < l; i++ ) {\n    \t\t\t\t\t\tname = attr[i].name;\n    \n    \t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n    \t\t\t\t\t\t\tname = jQuery.camelCase( name.substring(5) );\n    \n    \t\t\t\t\t\t\tdataAttr( this[0], name, data[ name ] );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\tjQuery._data( this[0], \"parsedAttrs\", true );\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\treturn data;\n    \n    \t\t} else if ( typeof key === \"object\" ) {\n    \t\t\treturn this.each(function() {\n    \t\t\t\tjQuery.data( this, key );\n    \t\t\t});\n    \t\t}\n    \n    \t\tparts = key.split(\".\");\n    \t\tparts[1] = parts[1] ? \".\" + parts[1] : \"\";\n    \n    \t\tif ( value === undefined ) {\n    \t\t\tdata = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]);\n    \n    \t\t\t// Try to fetch any internally stored data first\n    \t\t\tif ( data === undefined && this.length ) {\n    \t\t\t\tdata = jQuery.data( this[0], key );\n    \t\t\t\tdata = dataAttr( this[0], key, data );\n    \t\t\t}\n    \n    \t\t\treturn data === undefined && parts[1] ?\n    \t\t\t\tthis.data( parts[0] ) :\n    \t\t\t\tdata;\n    \n    \t\t} else {\n    \t\t\treturn this.each(function() {\n    \t\t\t\tvar self = jQuery( this ),\n    \t\t\t\t\targs = [ parts[0], value ];\n    \n    \t\t\t\tself.triggerHandler( \"setData\" + parts[1] + \"!\", args );\n    \t\t\t\tjQuery.data( this, key, value );\n    \t\t\t\tself.triggerHandler( \"changeData\" + parts[1] + \"!\", args );\n    \t\t\t});\n    \t\t}\n    \t},\n    \n    \tremoveData: function( key ) {\n    \t\treturn this.each(function() {\n    \t\t\tjQuery.removeData( this, key );\n    \t\t});\n    \t}\n    });\n    \n    function dataAttr( elem, key, data ) {\n    \t// If nothing was found internally, try to fetch any\n    \t// data from the HTML5 data-* attribute\n    \tif ( data === undefined && elem.nodeType === 1 ) {\n    \n    \t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n    \n    \t\tdata = elem.getAttribute( name );\n    \n    \t\tif ( typeof data === \"string\" ) {\n    \t\t\ttry {\n    \t\t\t\tdata = data === \"true\" ? true :\n    \t\t\t\tdata === \"false\" ? false :\n    \t\t\t\tdata === \"null\" ? null :\n    \t\t\t\tjQuery.isNumeric( data ) ? parseFloat( data ) :\n    \t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n    \t\t\t\t\tdata;\n    \t\t\t} catch( e ) {}\n    \n    \t\t\t// Make sure we set the data so it isn't changed later\n    \t\t\tjQuery.data( elem, key, data );\n    \n    \t\t} else {\n    \t\t\tdata = undefined;\n    \t\t}\n    \t}\n    \n    \treturn data;\n    }\n    \n    // checks a cache object for emptiness\n    function isEmptyDataObject( obj ) {\n    \tfor ( var name in obj ) {\n    \n    \t\t// if the public data object is empty, the private is still empty\n    \t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n    \t\t\tcontinue;\n    \t\t}\n    \t\tif ( name !== \"toJSON\" ) {\n    \t\t\treturn false;\n    \t\t}\n    \t}\n    \n    \treturn true;\n    }\n    \n    \n    \n    \n    function handleQueueMarkDefer( elem, type, src ) {\n    \tvar deferDataKey = type + \"defer\",\n    \t\tqueueDataKey = type + \"queue\",\n    \t\tmarkDataKey = type + \"mark\",\n    \t\tdefer = jQuery._data( elem, deferDataKey );\n    \tif ( defer &&\n    \t\t( src === \"queue\" || !jQuery._data(elem, queueDataKey) ) &&\n    \t\t( src === \"mark\" || !jQuery._data(elem, markDataKey) ) ) {\n    \t\t// Give room for hard-coded callbacks to fire first\n    \t\t// and eventually mark/queue something else on the element\n    \t\tsetTimeout( function() {\n    \t\t\tif ( !jQuery._data( elem, queueDataKey ) &&\n    \t\t\t\t!jQuery._data( elem, markDataKey ) ) {\n    \t\t\t\tjQuery.removeData( elem, deferDataKey, true );\n    \t\t\t\tdefer.fire();\n    \t\t\t}\n    \t\t}, 0 );\n    \t}\n    }\n    \n    jQuery.extend({\n    \n    \t_mark: function( elem, type ) {\n    \t\tif ( elem ) {\n    \t\t\ttype = ( type || \"fx\" ) + \"mark\";\n    \t\t\tjQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );\n    \t\t}\n    \t},\n    \n    \t_unmark: function( force, elem, type ) {\n    \t\tif ( force !== true ) {\n    \t\t\ttype = elem;\n    \t\t\telem = force;\n    \t\t\tforce = false;\n    \t\t}\n    \t\tif ( elem ) {\n    \t\t\ttype = type || \"fx\";\n    \t\t\tvar key = type + \"mark\",\n    \t\t\t\tcount = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );\n    \t\t\tif ( count ) {\n    \t\t\t\tjQuery._data( elem, key, count );\n    \t\t\t} else {\n    \t\t\t\tjQuery.removeData( elem, key, true );\n    \t\t\t\thandleQueueMarkDefer( elem, type, \"mark\" );\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \tqueue: function( elem, type, data ) {\n    \t\tvar q;\n    \t\tif ( elem ) {\n    \t\t\ttype = ( type || \"fx\" ) + \"queue\";\n    \t\t\tq = jQuery._data( elem, type );\n    \n    \t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n    \t\t\tif ( data ) {\n    \t\t\t\tif ( !q || jQuery.isArray(data) ) {\n    \t\t\t\t\tq = jQuery._data( elem, type, jQuery.makeArray(data) );\n    \t\t\t\t} else {\n    \t\t\t\t\tq.push( data );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn q || [];\n    \t\t}\n    \t},\n    \n    \tdequeue: function( elem, type ) {\n    \t\ttype = type || \"fx\";\n    \n    \t\tvar queue = jQuery.queue( elem, type ),\n    \t\t\tfn = queue.shift(),\n    \t\t\thooks = {};\n    \n    \t\t// If the fx queue is dequeued, always remove the progress sentinel\n    \t\tif ( fn === \"inprogress\" ) {\n    \t\t\tfn = queue.shift();\n    \t\t}\n    \n    \t\tif ( fn ) {\n    \t\t\t// Add a progress sentinel to prevent the fx queue from being\n    \t\t\t// automatically dequeued\n    \t\t\tif ( type === \"fx\" ) {\n    \t\t\t\tqueue.unshift( \"inprogress\" );\n    \t\t\t}\n    \n    \t\t\tjQuery._data( elem, type + \".run\", hooks );\n    \t\t\tfn.call( elem, function() {\n    \t\t\t\tjQuery.dequeue( elem, type );\n    \t\t\t}, hooks );\n    \t\t}\n    \n    \t\tif ( !queue.length ) {\n    \t\t\tjQuery.removeData( elem, type + \"queue \" + type + \".run\", true );\n    \t\t\thandleQueueMarkDefer( elem, type, \"queue\" );\n    \t\t}\n    \t}\n    });\n    \n    jQuery.fn.extend({\n    \tqueue: function( type, data ) {\n    \t\tif ( typeof type !== \"string\" ) {\n    \t\t\tdata = type;\n    \t\t\ttype = \"fx\";\n    \t\t}\n    \n    \t\tif ( data === undefined ) {\n    \t\t\treturn jQuery.queue( this[0], type );\n    \t\t}\n    \t\treturn this.each(function() {\n    \t\t\tvar queue = jQuery.queue( this, type, data );\n    \n    \t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n    \t\t\t\tjQuery.dequeue( this, type );\n    \t\t\t}\n    \t\t});\n    \t},\n    \tdequeue: function( type ) {\n    \t\treturn this.each(function() {\n    \t\t\tjQuery.dequeue( this, type );\n    \t\t});\n    \t},\n    \t// Based off of the plugin by Clint Helfers, with permission.\n    \t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n    \tdelay: function( time, type ) {\n    \t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n    \t\ttype = type || \"fx\";\n    \n    \t\treturn this.queue( type, function( next, hooks ) {\n    \t\t\tvar timeout = setTimeout( next, time );\n    \t\t\thooks.stop = function() {\n    \t\t\t\tclearTimeout( timeout );\n    \t\t\t};\n    \t\t});\n    \t},\n    \tclearQueue: function( type ) {\n    \t\treturn this.queue( type || \"fx\", [] );\n    \t},\n    \t// Get a promise resolved when queues of a certain type\n    \t// are emptied (fx is the type by default)\n    \tpromise: function( type, object ) {\n    \t\tif ( typeof type !== \"string\" ) {\n    \t\t\tobject = type;\n    \t\t\ttype = undefined;\n    \t\t}\n    \t\ttype = type || \"fx\";\n    \t\tvar defer = jQuery.Deferred(),\n    \t\t\telements = this,\n    \t\t\ti = elements.length,\n    \t\t\tcount = 1,\n    \t\t\tdeferDataKey = type + \"defer\",\n    \t\t\tqueueDataKey = type + \"queue\",\n    \t\t\tmarkDataKey = type + \"mark\",\n    \t\t\ttmp;\n    \t\tfunction resolve() {\n    \t\t\tif ( !( --count ) ) {\n    \t\t\t\tdefer.resolveWith( elements, [ elements ] );\n    \t\t\t}\n    \t\t}\n    \t\twhile( i-- ) {\n    \t\t\tif (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||\n    \t\t\t\t\t( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||\n    \t\t\t\t\t\tjQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&\n    \t\t\t\t\tjQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( \"once memory\" ), true ) )) {\n    \t\t\t\tcount++;\n    \t\t\t\ttmp.add( resolve );\n    \t\t\t}\n    \t\t}\n    \t\tresolve();\n    \t\treturn defer.promise();\n    \t}\n    });\n    \n    \n    \n    \n    var rclass = /[\\n\\t\\r]/g,\n    \trspace = /\\s+/,\n    \trreturn = /\\r/g,\n    \trtype = /^(?:button|input)$/i,\n    \trfocusable = /^(?:button|input|object|select|textarea)$/i,\n    \trclickable = /^a(?:rea)?$/i,\n    \trboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,\n    \tgetSetAttribute = jQuery.support.getSetAttribute,\n    \tnodeHook, boolHook, fixSpecified;\n    \n    jQuery.fn.extend({\n    \tattr: function( name, value ) {\n    \t\treturn jQuery.access( this, name, value, true, jQuery.attr );\n    \t},\n    \n    \tremoveAttr: function( name ) {\n    \t\treturn this.each(function() {\n    \t\t\tjQuery.removeAttr( this, name );\n    \t\t});\n    \t},\n    \n    \tprop: function( name, value ) {\n    \t\treturn jQuery.access( this, name, value, true, jQuery.prop );\n    \t},\n    \n    \tremoveProp: function( name ) {\n    \t\tname = jQuery.propFix[ name ] || name;\n    \t\treturn this.each(function() {\n    \t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n    \t\t\ttry {\n    \t\t\t\tthis[ name ] = undefined;\n    \t\t\t\tdelete this[ name ];\n    \t\t\t} catch( e ) {}\n    \t\t});\n    \t},\n    \n    \taddClass: function( value ) {\n    \t\tvar classNames, i, l, elem,\n    \t\t\tsetClass, c, cl;\n    \n    \t\tif ( jQuery.isFunction( value ) ) {\n    \t\t\treturn this.each(function( j ) {\n    \t\t\t\tjQuery( this ).addClass( value.call(this, j, this.className) );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( value && typeof value === \"string\" ) {\n    \t\t\tclassNames = value.split( rspace );\n    \n    \t\t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n    \t\t\t\telem = this[ i ];\n    \n    \t\t\t\tif ( elem.nodeType === 1 ) {\n    \t\t\t\t\tif ( !elem.className && classNames.length === 1 ) {\n    \t\t\t\t\t\telem.className = value;\n    \n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tsetClass = \" \" + elem.className + \" \";\n    \n    \t\t\t\t\t\tfor ( c = 0, cl = classNames.length; c < cl; c++ ) {\n    \t\t\t\t\t\t\tif ( !~setClass.indexOf( \" \" + classNames[ c ] + \" \" ) ) {\n    \t\t\t\t\t\t\t\tsetClass += classNames[ c ] + \" \";\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telem.className = jQuery.trim( setClass );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn this;\n    \t},\n    \n    \tremoveClass: function( value ) {\n    \t\tvar classNames, i, l, elem, className, c, cl;\n    \n    \t\tif ( jQuery.isFunction( value ) ) {\n    \t\t\treturn this.each(function( j ) {\n    \t\t\t\tjQuery( this ).removeClass( value.call(this, j, this.className) );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( (value && typeof value === \"string\") || value === undefined ) {\n    \t\t\tclassNames = ( value || \"\" ).split( rspace );\n    \n    \t\t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n    \t\t\t\telem = this[ i ];\n    \n    \t\t\t\tif ( elem.nodeType === 1 && elem.className ) {\n    \t\t\t\t\tif ( value ) {\n    \t\t\t\t\t\tclassName = (\" \" + elem.className + \" \").replace( rclass, \" \" );\n    \t\t\t\t\t\tfor ( c = 0, cl = classNames.length; c < cl; c++ ) {\n    \t\t\t\t\t\t\tclassName = className.replace(\" \" + classNames[ c ] + \" \", \" \");\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telem.className = jQuery.trim( className );\n    \n    \t\t\t\t\t} else {\n    \t\t\t\t\t\telem.className = \"\";\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn this;\n    \t},\n    \n    \ttoggleClass: function( value, stateVal ) {\n    \t\tvar type = typeof value,\n    \t\t\tisBool = typeof stateVal === \"boolean\";\n    \n    \t\tif ( jQuery.isFunction( value ) ) {\n    \t\t\treturn this.each(function( i ) {\n    \t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n    \t\t\t});\n    \t\t}\n    \n    \t\treturn this.each(function() {\n    \t\t\tif ( type === \"string\" ) {\n    \t\t\t\t// toggle individual class names\n    \t\t\t\tvar className,\n    \t\t\t\t\ti = 0,\n    \t\t\t\t\tself = jQuery( this ),\n    \t\t\t\t\tstate = stateVal,\n    \t\t\t\t\tclassNames = value.split( rspace );\n    \n    \t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n    \t\t\t\t\t// check each className given, space seperated list\n    \t\t\t\t\tstate = isBool ? state : !self.hasClass( className );\n    \t\t\t\t\tself[ state ? \"addClass\" : \"removeClass\" ]( className );\n    \t\t\t\t}\n    \n    \t\t\t} else if ( type === \"undefined\" || type === \"boolean\" ) {\n    \t\t\t\tif ( this.className ) {\n    \t\t\t\t\t// store className if set\n    \t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n    \t\t\t\t}\n    \n    \t\t\t\t// toggle whole className\n    \t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n    \t\t\t}\n    \t\t});\n    \t},\n    \n    \thasClass: function( selector ) {\n    \t\tvar className = \" \" + selector + \" \",\n    \t\t\ti = 0,\n    \t\t\tl = this.length;\n    \t\tfor ( ; i < l; i++ ) {\n    \t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) > -1 ) {\n    \t\t\t\treturn true;\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn false;\n    \t},\n    \n    \tval: function( value ) {\n    \t\tvar hooks, ret, isFunction,\n    \t\t\telem = this[0];\n    \n    \t\tif ( !arguments.length ) {\n    \t\t\tif ( elem ) {\n    \t\t\t\thooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];\n    \n    \t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n    \t\t\t\t\treturn ret;\n    \t\t\t\t}\n    \n    \t\t\t\tret = elem.value;\n    \n    \t\t\t\treturn typeof ret === \"string\" ?\n    \t\t\t\t\t// handle most common string cases\n    \t\t\t\t\tret.replace(rreturn, \"\") :\n    \t\t\t\t\t// handle cases where value is null/undef or number\n    \t\t\t\t\tret == null ? \"\" : ret;\n    \t\t\t}\n    \n    \t\t\treturn;\n    \t\t}\n    \n    \t\tisFunction = jQuery.isFunction( value );\n    \n    \t\treturn this.each(function( i ) {\n    \t\t\tvar self = jQuery(this), val;\n    \n    \t\t\tif ( this.nodeType !== 1 ) {\n    \t\t\t\treturn;\n    \t\t\t}\n    \n    \t\t\tif ( isFunction ) {\n    \t\t\t\tval = value.call( this, i, self.val() );\n    \t\t\t} else {\n    \t\t\t\tval = value;\n    \t\t\t}\n    \n    \t\t\t// Treat null/undefined as \"\"; convert numbers to string\n    \t\t\tif ( val == null ) {\n    \t\t\t\tval = \"\";\n    \t\t\t} else if ( typeof val === \"number\" ) {\n    \t\t\t\tval += \"\";\n    \t\t\t} else if ( jQuery.isArray( val ) ) {\n    \t\t\t\tval = jQuery.map(val, function ( value ) {\n    \t\t\t\t\treturn value == null ? \"\" : value + \"\";\n    \t\t\t\t});\n    \t\t\t}\n    \n    \t\t\thooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];\n    \n    \t\t\t// If set returns undefined, fall back to normal setting\n    \t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n    \t\t\t\tthis.value = val;\n    \t\t\t}\n    \t\t});\n    \t}\n    });\n    \n    jQuery.extend({\n    \tvalHooks: {\n    \t\toption: {\n    \t\t\tget: function( elem ) {\n    \t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n    \t\t\t\t// uses .value. See #6932\n    \t\t\t\tvar val = elem.attributes.value;\n    \t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n    \t\t\t}\n    \t\t},\n    \t\tselect: {\n    \t\t\tget: function( elem ) {\n    \t\t\t\tvar value, i, max, option,\n    \t\t\t\t\tindex = elem.selectedIndex,\n    \t\t\t\t\tvalues = [],\n    \t\t\t\t\toptions = elem.options,\n    \t\t\t\t\tone = elem.type === \"select-one\";\n    \n    \t\t\t\t// Nothing was selected\n    \t\t\t\tif ( index < 0 ) {\n    \t\t\t\t\treturn null;\n    \t\t\t\t}\n    \n    \t\t\t\t// Loop through all the selected options\n    \t\t\t\ti = one ? index : 0;\n    \t\t\t\tmax = one ? index + 1 : options.length;\n    \t\t\t\tfor ( ; i < max; i++ ) {\n    \t\t\t\t\toption = options[ i ];\n    \n    \t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n    \t\t\t\t\tif ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) &&\n    \t\t\t\t\t\t\t(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" )) ) {\n    \n    \t\t\t\t\t\t// Get the specific value for the option\n    \t\t\t\t\t\tvalue = jQuery( option ).val();\n    \n    \t\t\t\t\t\t// We don't need an array for one selects\n    \t\t\t\t\t\tif ( one ) {\n    \t\t\t\t\t\t\treturn value;\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t// Multi-Selects return an array\n    \t\t\t\t\t\tvalues.push( value );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\t// Fixes Bug #2551 -- select.val() broken in IE after form.reset()\n    \t\t\t\tif ( one && !values.length && options.length ) {\n    \t\t\t\t\treturn jQuery( options[ index ] ).val();\n    \t\t\t\t}\n    \n    \t\t\t\treturn values;\n    \t\t\t},\n    \n    \t\t\tset: function( elem, value ) {\n    \t\t\t\tvar values = jQuery.makeArray( value );\n    \n    \t\t\t\tjQuery(elem).find(\"option\").each(function() {\n    \t\t\t\t\tthis.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;\n    \t\t\t\t});\n    \n    \t\t\t\tif ( !values.length ) {\n    \t\t\t\t\telem.selectedIndex = -1;\n    \t\t\t\t}\n    \t\t\t\treturn values;\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \tattrFn: {\n    \t\tval: true,\n    \t\tcss: true,\n    \t\thtml: true,\n    \t\ttext: true,\n    \t\tdata: true,\n    \t\twidth: true,\n    \t\theight: true,\n    \t\toffset: true\n    \t},\n    \n    \tattr: function( elem, name, value, pass ) {\n    \t\tvar ret, hooks, notxml,\n    \t\t\tnType = elem.nodeType;\n    \n    \t\t// don't get/set attributes on text, comment and attribute nodes\n    \t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tif ( pass && name in jQuery.attrFn ) {\n    \t\t\treturn jQuery( elem )[ name ]( value );\n    \t\t}\n    \n    \t\t// Fallback to prop when attributes are not supported\n    \t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n    \t\t\treturn jQuery.prop( elem, name, value );\n    \t\t}\n    \n    \t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n    \n    \t\t// All attributes are lowercase\n    \t\t// Grab necessary hook if one is defined\n    \t\tif ( notxml ) {\n    \t\t\tname = name.toLowerCase();\n    \t\t\thooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );\n    \t\t}\n    \n    \t\tif ( value !== undefined ) {\n    \n    \t\t\tif ( value === null ) {\n    \t\t\t\tjQuery.removeAttr( elem, name );\n    \t\t\t\treturn;\n    \n    \t\t\t} else if ( hooks && \"set\" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {\n    \t\t\t\treturn ret;\n    \n    \t\t\t} else {\n    \t\t\t\telem.setAttribute( name, \"\" + value );\n    \t\t\t\treturn value;\n    \t\t\t}\n    \n    \t\t} else if ( hooks && \"get\" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {\n    \t\t\treturn ret;\n    \n    \t\t} else {\n    \n    \t\t\tret = elem.getAttribute( name );\n    \n    \t\t\t// Non-existent attributes return null, we normalize to undefined\n    \t\t\treturn ret === null ?\n    \t\t\t\tundefined :\n    \t\t\t\tret;\n    \t\t}\n    \t},\n    \n    \tremoveAttr: function( elem, value ) {\n    \t\tvar propName, attrNames, name, l,\n    \t\t\ti = 0;\n    \n    \t\tif ( value && elem.nodeType === 1 ) {\n    \t\t\tattrNames = value.toLowerCase().split( rspace );\n    \t\t\tl = attrNames.length;\n    \n    \t\t\tfor ( ; i < l; i++ ) {\n    \t\t\t\tname = attrNames[ i ];\n    \n    \t\t\t\tif ( name ) {\n    \t\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n    \n    \t\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n    \t\t\t\t\tjQuery.attr( elem, name, \"\" );\n    \t\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n    \n    \t\t\t\t\t// Set corresponding property to false for boolean attributes\n    \t\t\t\t\tif ( rboolean.test( name ) && propName in elem ) {\n    \t\t\t\t\t\telem[ propName ] = false;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \tattrHooks: {\n    \t\ttype: {\n    \t\t\tset: function( elem, value ) {\n    \t\t\t\t// We can't allow the type property to be changed (since it causes problems in IE)\n    \t\t\t\tif ( rtype.test( elem.nodeName ) && elem.parentNode ) {\n    \t\t\t\t\tjQuery.error( \"type property can't be changed\" );\n    \t\t\t\t} else if ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n    \t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n    \t\t\t\t\t// Reset value to it's default in case type is set after value\n    \t\t\t\t\t// This is for element creation\n    \t\t\t\t\tvar val = elem.value;\n    \t\t\t\t\telem.setAttribute( \"type\", value );\n    \t\t\t\t\tif ( val ) {\n    \t\t\t\t\t\telem.value = val;\n    \t\t\t\t\t}\n    \t\t\t\t\treturn value;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \t\t// Use the value property for back compat\n    \t\t// Use the nodeHook for button elements in IE6/7 (#1954)\n    \t\tvalue: {\n    \t\t\tget: function( elem, name ) {\n    \t\t\t\tif ( nodeHook && jQuery.nodeName( elem, \"button\" ) ) {\n    \t\t\t\t\treturn nodeHook.get( elem, name );\n    \t\t\t\t}\n    \t\t\t\treturn name in elem ?\n    \t\t\t\t\telem.value :\n    \t\t\t\t\tnull;\n    \t\t\t},\n    \t\t\tset: function( elem, value, name ) {\n    \t\t\t\tif ( nodeHook && jQuery.nodeName( elem, \"button\" ) ) {\n    \t\t\t\t\treturn nodeHook.set( elem, value, name );\n    \t\t\t\t}\n    \t\t\t\t// Does not return so that setAttribute is also used\n    \t\t\t\telem.value = value;\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \tpropFix: {\n    \t\ttabindex: \"tabIndex\",\n    \t\treadonly: \"readOnly\",\n    \t\t\"for\": \"htmlFor\",\n    \t\t\"class\": \"className\",\n    \t\tmaxlength: \"maxLength\",\n    \t\tcellspacing: \"cellSpacing\",\n    \t\tcellpadding: \"cellPadding\",\n    \t\trowspan: \"rowSpan\",\n    \t\tcolspan: \"colSpan\",\n    \t\tusemap: \"useMap\",\n    \t\tframeborder: \"frameBorder\",\n    \t\tcontenteditable: \"contentEditable\"\n    \t},\n    \n    \tprop: function( elem, name, value ) {\n    \t\tvar ret, hooks, notxml,\n    \t\t\tnType = elem.nodeType;\n    \n    \t\t// don't get/set properties on text, comment and attribute nodes\n    \t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n    \n    \t\tif ( notxml ) {\n    \t\t\t// Fix name and attach hooks\n    \t\t\tname = jQuery.propFix[ name ] || name;\n    \t\t\thooks = jQuery.propHooks[ name ];\n    \t\t}\n    \n    \t\tif ( value !== undefined ) {\n    \t\t\tif ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n    \t\t\t\treturn ret;\n    \n    \t\t\t} else {\n    \t\t\t\treturn ( elem[ name ] = value );\n    \t\t\t}\n    \n    \t\t} else {\n    \t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n    \t\t\t\treturn ret;\n    \n    \t\t\t} else {\n    \t\t\t\treturn elem[ name ];\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \tpropHooks: {\n    \t\ttabIndex: {\n    \t\t\tget: function( elem ) {\n    \t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n    \t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n    \t\t\t\tvar attributeNode = elem.getAttributeNode(\"tabindex\");\n    \n    \t\t\t\treturn attributeNode && attributeNode.specified ?\n    \t\t\t\t\tparseInt( attributeNode.value, 10 ) :\n    \t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n    \t\t\t\t\t\t0 :\n    \t\t\t\t\t\tundefined;\n    \t\t\t}\n    \t\t}\n    \t}\n    });\n    \n    // Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)\n    jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;\n    \n    // Hook for boolean attributes\n    boolHook = {\n    \tget: function( elem, name ) {\n    \t\t// Align boolean attributes with corresponding properties\n    \t\t// Fall back to attribute presence where some booleans are not supported\n    \t\tvar attrNode,\n    \t\t\tproperty = jQuery.prop( elem, name );\n    \t\treturn property === true || typeof property !== \"boolean\" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?\n    \t\t\tname.toLowerCase() :\n    \t\t\tundefined;\n    \t},\n    \tset: function( elem, value, name ) {\n    \t\tvar propName;\n    \t\tif ( value === false ) {\n    \t\t\t// Remove boolean attributes when set to false\n    \t\t\tjQuery.removeAttr( elem, name );\n    \t\t} else {\n    \t\t\t// value is true since we know at this point it's type boolean and not false\n    \t\t\t// Set boolean attributes to the same name and set the DOM property\n    \t\t\tpropName = jQuery.propFix[ name ] || name;\n    \t\t\tif ( propName in elem ) {\n    \t\t\t\t// Only set the IDL specifically if it already exists on the element\n    \t\t\t\telem[ propName ] = true;\n    \t\t\t}\n    \n    \t\t\telem.setAttribute( name, name.toLowerCase() );\n    \t\t}\n    \t\treturn name;\n    \t}\n    };\n    \n    // IE6/7 do not support getting/setting some attributes with get/setAttribute\n    if ( !getSetAttribute ) {\n    \n    \tfixSpecified = {\n    \t\tname: true,\n    \t\tid: true\n    \t};\n    \n    \t// Use this for any attribute in IE6/7\n    \t// This fixes almost every IE6/7 issue\n    \tnodeHook = jQuery.valHooks.button = {\n    \t\tget: function( elem, name ) {\n    \t\t\tvar ret;\n    \t\t\tret = elem.getAttributeNode( name );\n    \t\t\treturn ret && ( fixSpecified[ name ] ? ret.nodeValue !== \"\" : ret.specified ) ?\n    \t\t\t\tret.nodeValue :\n    \t\t\t\tundefined;\n    \t\t},\n    \t\tset: function( elem, value, name ) {\n    \t\t\t// Set the existing or create a new attribute node\n    \t\t\tvar ret = elem.getAttributeNode( name );\n    \t\t\tif ( !ret ) {\n    \t\t\t\tret = document.createAttribute( name );\n    \t\t\t\telem.setAttributeNode( ret );\n    \t\t\t}\n    \t\t\treturn ( ret.nodeValue = value + \"\" );\n    \t\t}\n    \t};\n    \n    \t// Apply the nodeHook to tabindex\n    \tjQuery.attrHooks.tabindex.set = nodeHook.set;\n    \n    \t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n    \t// This is for removals\n    \tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n    \t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n    \t\t\tset: function( elem, value ) {\n    \t\t\t\tif ( value === \"\" ) {\n    \t\t\t\t\telem.setAttribute( name, \"auto\" );\n    \t\t\t\t\treturn value;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t});\n    \t});\n    \n    \t// Set contenteditable to false on removals(#10429)\n    \t// Setting to empty string throws an error as an invalid value\n    \tjQuery.attrHooks.contenteditable = {\n    \t\tget: nodeHook.get,\n    \t\tset: function( elem, value, name ) {\n    \t\t\tif ( value === \"\" ) {\n    \t\t\t\tvalue = \"false\";\n    \t\t\t}\n    \t\t\tnodeHook.set( elem, value, name );\n    \t\t}\n    \t};\n    }\n    \n    \n    // Some attributes require a special call on IE\n    if ( !jQuery.support.hrefNormalized ) {\n    \tjQuery.each([ \"href\", \"src\", \"width\", \"height\" ], function( i, name ) {\n    \t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n    \t\t\tget: function( elem ) {\n    \t\t\t\tvar ret = elem.getAttribute( name, 2 );\n    \t\t\t\treturn ret === null ? undefined : ret;\n    \t\t\t}\n    \t\t});\n    \t});\n    }\n    \n    if ( !jQuery.support.style ) {\n    \tjQuery.attrHooks.style = {\n    \t\tget: function( elem ) {\n    \t\t\t// Return undefined in the case of empty string\n    \t\t\t// Normalize to lowercase since IE uppercases css property names\n    \t\t\treturn elem.style.cssText.toLowerCase() || undefined;\n    \t\t},\n    \t\tset: function( elem, value ) {\n    \t\t\treturn ( elem.style.cssText = \"\" + value );\n    \t\t}\n    \t};\n    }\n    \n    // Safari mis-reports the default selected property of an option\n    // Accessing the parent's selectedIndex property fixes it\n    if ( !jQuery.support.optSelected ) {\n    \tjQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {\n    \t\tget: function( elem ) {\n    \t\t\tvar parent = elem.parentNode;\n    \n    \t\t\tif ( parent ) {\n    \t\t\t\tparent.selectedIndex;\n    \n    \t\t\t\t// Make sure that it also works with optgroups, see #5701\n    \t\t\t\tif ( parent.parentNode ) {\n    \t\t\t\t\tparent.parentNode.selectedIndex;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn null;\n    \t\t}\n    \t});\n    }\n    \n    // IE6/7 call enctype encoding\n    if ( !jQuery.support.enctype ) {\n    \tjQuery.propFix.enctype = \"encoding\";\n    }\n    \n    // Radios and checkboxes getter/setter\n    if ( !jQuery.support.checkOn ) {\n    \tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n    \t\tjQuery.valHooks[ this ] = {\n    \t\t\tget: function( elem ) {\n    \t\t\t\t// Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n    \t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n    \t\t\t}\n    \t\t};\n    \t});\n    }\n    jQuery.each([ \"radio\", \"checkbox\" ], function() {\n    \tjQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {\n    \t\tset: function( elem, value ) {\n    \t\t\tif ( jQuery.isArray( value ) ) {\n    \t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n    \t\t\t}\n    \t\t}\n    \t});\n    });\n    \n    \n    \n    \n    var rformElems = /^(?:textarea|input|select)$/i,\n    \trtypenamespace = /^([^\\.]*)?(?:\\.(.+))?$/,\n    \trhoverHack = /\\bhover(\\.\\S+)?\\b/,\n    \trkeyEvent = /^key/,\n    \trmouseEvent = /^(?:mouse|contextmenu)|click/,\n    \trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n    \trquickIs = /^(\\w*)(?:#([\\w\\-]+))?(?:\\.([\\w\\-]+))?$/,\n    \tquickParse = function( selector ) {\n    \t\tvar quick = rquickIs.exec( selector );\n    \t\tif ( quick ) {\n    \t\t\t//   0  1    2   3\n    \t\t\t// [ _, tag, id, class ]\n    \t\t\tquick[1] = ( quick[1] || \"\" ).toLowerCase();\n    \t\t\tquick[3] = quick[3] && new RegExp( \"(?:^|\\\\s)\" + quick[3] + \"(?:\\\\s|$)\" );\n    \t\t}\n    \t\treturn quick;\n    \t},\n    \tquickIs = function( elem, m ) {\n    \t\tvar attrs = elem.attributes || {};\n    \t\treturn (\n    \t\t\t(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&\n    \t\t\t(!m[2] || (attrs.id || {}).value === m[2]) &&\n    \t\t\t(!m[3] || m[3].test( (attrs[ \"class\" ] || {}).value ))\n    \t\t);\n    \t},\n    \thoverHack = function( events ) {\n    \t\treturn jQuery.event.special.hover ? events : events.replace( rhoverHack, \"mouseenter$1 mouseleave$1\" );\n    \t};\n    \n    /*\n     * Helper functions for managing events -- not part of the public interface.\n     * Props to Dean Edwards' addEvent library for many of the ideas.\n     */\n    jQuery.event = {\n    \n    \tadd: function( elem, types, handler, data, selector ) {\n    \n    \t\tvar elemData, eventHandle, events,\n    \t\t\tt, tns, type, namespaces, handleObj,\n    \t\t\thandleObjIn, quick, handlers, special;\n    \n    \t\t// Don't attach events to noData or text/comment nodes (allow plain objects tho)\n    \t\tif ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// Caller can pass in an object of custom data in lieu of the handler\n    \t\tif ( handler.handler ) {\n    \t\t\thandleObjIn = handler;\n    \t\t\thandler = handleObjIn.handler;\n    \t\t}\n    \n    \t\t// Make sure that the handler has a unique ID, used to find/remove it later\n    \t\tif ( !handler.guid ) {\n    \t\t\thandler.guid = jQuery.guid++;\n    \t\t}\n    \n    \t\t// Init the element's event structure and main handler, if this is the first\n    \t\tevents = elemData.events;\n    \t\tif ( !events ) {\n    \t\t\telemData.events = events = {};\n    \t\t}\n    \t\teventHandle = elemData.handle;\n    \t\tif ( !eventHandle ) {\n    \t\t\telemData.handle = eventHandle = function( e ) {\n    \t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n    \t\t\t\t// when an event is called after a page has unloaded\n    \t\t\t\treturn typeof jQuery !== \"undefined\" && (!e || jQuery.event.triggered !== e.type) ?\n    \t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n    \t\t\t\t\tundefined;\n    \t\t\t};\n    \t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n    \t\t\teventHandle.elem = elem;\n    \t\t}\n    \n    \t\t// Handle multiple events separated by a space\n    \t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n    \t\ttypes = jQuery.trim( hoverHack(types) ).split( \" \" );\n    \t\tfor ( t = 0; t < types.length; t++ ) {\n    \n    \t\t\ttns = rtypenamespace.exec( types[t] ) || [];\n    \t\t\ttype = tns[1];\n    \t\t\tnamespaces = ( tns[2] || \"\" ).split( \".\" ).sort();\n    \n    \t\t\t// If event changes its type, use the special event handlers for the changed type\n    \t\t\tspecial = jQuery.event.special[ type ] || {};\n    \n    \t\t\t// If selector defined, determine special event api type, otherwise given type\n    \t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n    \n    \t\t\t// Update special based on newly reset type\n    \t\t\tspecial = jQuery.event.special[ type ] || {};\n    \n    \t\t\t// handleObj is passed to all event handlers\n    \t\t\thandleObj = jQuery.extend({\n    \t\t\t\ttype: type,\n    \t\t\t\torigType: tns[1],\n    \t\t\t\tdata: data,\n    \t\t\t\thandler: handler,\n    \t\t\t\tguid: handler.guid,\n    \t\t\t\tselector: selector,\n    \t\t\t\tquick: quickParse( selector ),\n    \t\t\t\tnamespace: namespaces.join(\".\")\n    \t\t\t}, handleObjIn );\n    \n    \t\t\t// Init the event handler queue if we're the first\n    \t\t\thandlers = events[ type ];\n    \t\t\tif ( !handlers ) {\n    \t\t\t\thandlers = events[ type ] = [];\n    \t\t\t\thandlers.delegateCount = 0;\n    \n    \t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n    \t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n    \t\t\t\t\t// Bind the global event handler to the element\n    \t\t\t\t\tif ( elem.addEventListener ) {\n    \t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n    \n    \t\t\t\t\t} else if ( elem.attachEvent ) {\n    \t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\tif ( special.add ) {\n    \t\t\t\tspecial.add.call( elem, handleObj );\n    \n    \t\t\t\tif ( !handleObj.handler.guid ) {\n    \t\t\t\t\thandleObj.handler.guid = handler.guid;\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// Add to the element's handler list, delegates in front\n    \t\t\tif ( selector ) {\n    \t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n    \t\t\t} else {\n    \t\t\t\thandlers.push( handleObj );\n    \t\t\t}\n    \n    \t\t\t// Keep track of which events have ever been used, for event optimization\n    \t\t\tjQuery.event.global[ type ] = true;\n    \t\t}\n    \n    \t\t// Nullify elem to prevent memory leaks in IE\n    \t\telem = null;\n    \t},\n    \n    \tglobal: {},\n    \n    \t// Detach an event or set of events from an element\n    \tremove: function( elem, types, handler, selector, mappedTypes ) {\n    \n    \t\tvar elemData = jQuery.hasData( elem ) && jQuery._data( elem ),\n    \t\t\tt, tns, type, origType, namespaces, origCount,\n    \t\t\tj, events, special, handle, eventType, handleObj;\n    \n    \t\tif ( !elemData || !(events = elemData.events) ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// Once for each type.namespace in types; type may be omitted\n    \t\ttypes = jQuery.trim( hoverHack( types || \"\" ) ).split(\" \");\n    \t\tfor ( t = 0; t < types.length; t++ ) {\n    \t\t\ttns = rtypenamespace.exec( types[t] ) || [];\n    \t\t\ttype = origType = tns[1];\n    \t\t\tnamespaces = tns[2];\n    \n    \t\t\t// Unbind all events (on this namespace, if provided) for the element\n    \t\t\tif ( !type ) {\n    \t\t\t\tfor ( type in events ) {\n    \t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n    \t\t\t\t}\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \n    \t\t\tspecial = jQuery.event.special[ type ] || {};\n    \t\t\ttype = ( selector? special.delegateType : special.bindType ) || type;\n    \t\t\teventType = events[ type ] || [];\n    \t\t\torigCount = eventType.length;\n    \t\t\tnamespaces = namespaces ? new RegExp(\"(^|\\\\.)\" + namespaces.split(\".\").sort().join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") : null;\n    \n    \t\t\t// Remove matching events\n    \t\t\tfor ( j = 0; j < eventType.length; j++ ) {\n    \t\t\t\thandleObj = eventType[ j ];\n    \n    \t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n    \t\t\t\t\t ( !handler || handler.guid === handleObj.guid ) &&\n    \t\t\t\t\t ( !namespaces || namespaces.test( handleObj.namespace ) ) &&\n    \t\t\t\t\t ( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n    \t\t\t\t\teventType.splice( j--, 1 );\n    \n    \t\t\t\t\tif ( handleObj.selector ) {\n    \t\t\t\t\t\teventType.delegateCount--;\n    \t\t\t\t\t}\n    \t\t\t\t\tif ( special.remove ) {\n    \t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// Remove generic event handler if we removed something and no more handlers exist\n    \t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n    \t\t\tif ( eventType.length === 0 && origCount !== eventType.length ) {\n    \t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {\n    \t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n    \t\t\t\t}\n    \n    \t\t\t\tdelete events[ type ];\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Remove the expando if it's no longer used\n    \t\tif ( jQuery.isEmptyObject( events ) ) {\n    \t\t\thandle = elemData.handle;\n    \t\t\tif ( handle ) {\n    \t\t\t\thandle.elem = null;\n    \t\t\t}\n    \n    \t\t\t// removeData also checks for emptiness and clears the expando if empty\n    \t\t\t// so use it instead of delete\n    \t\t\tjQuery.removeData( elem, [ \"events\", \"handle\" ], true );\n    \t\t}\n    \t},\n    \n    \t// Events that are safe to short-circuit if no handlers are attached.\n    \t// Native DOM events should not be added, they may have inline handlers.\n    \tcustomEvent: {\n    \t\t\"getData\": true,\n    \t\t\"setData\": true,\n    \t\t\"changeData\": true\n    \t},\n    \n    \ttrigger: function( event, data, elem, onlyHandlers ) {\n    \t\t// Don't do events on text and comment nodes\n    \t\tif ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// Event object or event type\n    \t\tvar type = event.type || event,\n    \t\t\tnamespaces = [],\n    \t\t\tcache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;\n    \n    \t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n    \t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\tif ( type.indexOf( \"!\" ) >= 0 ) {\n    \t\t\t// Exclusive events trigger only for the exact event (no namespaces)\n    \t\t\ttype = type.slice(0, -1);\n    \t\t\texclusive = true;\n    \t\t}\n    \n    \t\tif ( type.indexOf( \".\" ) >= 0 ) {\n    \t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n    \t\t\tnamespaces = type.split(\".\");\n    \t\t\ttype = namespaces.shift();\n    \t\t\tnamespaces.sort();\n    \t\t}\n    \n    \t\tif ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {\n    \t\t\t// No jQuery handlers for this event type, and it can't have inline handlers\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// Caller can pass in an Event, Object, or just an event type string\n    \t\tevent = typeof event === \"object\" ?\n    \t\t\t// jQuery.Event object\n    \t\t\tevent[ jQuery.expando ] ? event :\n    \t\t\t// Object literal\n    \t\t\tnew jQuery.Event( type, event ) :\n    \t\t\t// Just the event type (string)\n    \t\t\tnew jQuery.Event( type );\n    \n    \t\tevent.type = type;\n    \t\tevent.isTrigger = true;\n    \t\tevent.exclusive = exclusive;\n    \t\tevent.namespace = namespaces.join( \".\" );\n    \t\tevent.namespace_re = event.namespace? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") : null;\n    \t\tontype = type.indexOf( \":\" ) < 0 ? \"on\" + type : \"\";\n    \n    \t\t// Handle a global trigger\n    \t\tif ( !elem ) {\n    \n    \t\t\t// TODO: Stop taunting the data cache; remove global events and always attach to document\n    \t\t\tcache = jQuery.cache;\n    \t\t\tfor ( i in cache ) {\n    \t\t\t\tif ( cache[ i ].events && cache[ i ].events[ type ] ) {\n    \t\t\t\t\tjQuery.event.trigger( event, data, cache[ i ].handle.elem, true );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// Clean up the event in case it is being reused\n    \t\tevent.result = undefined;\n    \t\tif ( !event.target ) {\n    \t\t\tevent.target = elem;\n    \t\t}\n    \n    \t\t// Clone any incoming data and prepend the event, creating the handler arg list\n    \t\tdata = data != null ? jQuery.makeArray( data ) : [];\n    \t\tdata.unshift( event );\n    \n    \t\t// Allow special events to draw outside the lines\n    \t\tspecial = jQuery.event.special[ type ] || {};\n    \t\tif ( special.trigger && special.trigger.apply( elem, data ) === false ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n    \t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n    \t\teventPath = [[ elem, special.bindType || type ]];\n    \t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n    \n    \t\t\tbubbleType = special.delegateType || type;\n    \t\t\tcur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;\n    \t\t\told = null;\n    \t\t\tfor ( ; cur; cur = cur.parentNode ) {\n    \t\t\t\teventPath.push([ cur, bubbleType ]);\n    \t\t\t\told = cur;\n    \t\t\t}\n    \n    \t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n    \t\t\tif ( old && old === elem.ownerDocument ) {\n    \t\t\t\teventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Fire handlers on the event path\n    \t\tfor ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {\n    \n    \t\t\tcur = eventPath[i][0];\n    \t\t\tevent.type = eventPath[i][1];\n    \n    \t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n    \t\t\tif ( handle ) {\n    \t\t\t\thandle.apply( cur, data );\n    \t\t\t}\n    \t\t\t// Note that this is a bare JS function and not a jQuery handler\n    \t\t\thandle = ontype && cur[ ontype ];\n    \t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {\n    \t\t\t\tevent.preventDefault();\n    \t\t\t}\n    \t\t}\n    \t\tevent.type = type;\n    \n    \t\t// If nobody prevented the default action, do it now\n    \t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n    \n    \t\t\tif ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&\n    \t\t\t\t!(type === \"click\" && jQuery.nodeName( elem, \"a\" )) && jQuery.acceptData( elem ) ) {\n    \n    \t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n    \t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n    \t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n    \t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486)\n    \t\t\t\tif ( ontype && elem[ type ] && ((type !== \"focus\" && type !== \"blur\") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {\n    \n    \t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n    \t\t\t\t\told = elem[ ontype ];\n    \n    \t\t\t\t\tif ( old ) {\n    \t\t\t\t\t\telem[ ontype ] = null;\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n    \t\t\t\t\tjQuery.event.triggered = type;\n    \t\t\t\t\telem[ type ]();\n    \t\t\t\t\tjQuery.event.triggered = undefined;\n    \n    \t\t\t\t\tif ( old ) {\n    \t\t\t\t\t\telem[ ontype ] = old;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn event.result;\n    \t},\n    \n    \tdispatch: function( event ) {\n    \n    \t\t// Make a writable jQuery.Event from the native event object\n    \t\tevent = jQuery.event.fix( event || window.event );\n    \n    \t\tvar handlers = ( (jQuery._data( this, \"events\" ) || {} )[ event.type ] || []),\n    \t\t\tdelegateCount = handlers.delegateCount,\n    \t\t\targs = [].slice.call( arguments, 0 ),\n    \t\t\trun_all = !event.exclusive && !event.namespace,\n    \t\t\thandlerQueue = [],\n    \t\t\ti, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;\n    \n    \t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n    \t\targs[0] = event;\n    \t\tevent.delegateTarget = this;\n    \n    \t\t// Determine handlers that should run if there are delegated events\n    \t\t// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)\n    \t\tif ( delegateCount && !event.target.disabled && !(event.button && event.type === \"click\") ) {\n    \n    \t\t\t// Pregenerate a single jQuery object for reuse with .is()\n    \t\t\tjqcur = jQuery(this);\n    \t\t\tjqcur.context = this.ownerDocument || this;\n    \n    \t\t\tfor ( cur = event.target; cur != this; cur = cur.parentNode || this ) {\n    \t\t\t\tselMatch = {};\n    \t\t\t\tmatches = [];\n    \t\t\t\tjqcur[0] = cur;\n    \t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n    \t\t\t\t\thandleObj = handlers[ i ];\n    \t\t\t\t\tsel = handleObj.selector;\n    \n    \t\t\t\t\tif ( selMatch[ sel ] === undefined ) {\n    \t\t\t\t\t\tselMatch[ sel ] = (\n    \t\t\t\t\t\t\thandleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )\n    \t\t\t\t\t\t);\n    \t\t\t\t\t}\n    \t\t\t\t\tif ( selMatch[ sel ] ) {\n    \t\t\t\t\t\tmatches.push( handleObj );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif ( matches.length ) {\n    \t\t\t\t\thandlerQueue.push({ elem: cur, matches: matches });\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Add the remaining (directly-bound) handlers\n    \t\tif ( handlers.length > delegateCount ) {\n    \t\t\thandlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });\n    \t\t}\n    \n    \t\t// Run delegates first; they may want to stop propagation beneath us\n    \t\tfor ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {\n    \t\t\tmatched = handlerQueue[ i ];\n    \t\t\tevent.currentTarget = matched.elem;\n    \n    \t\t\tfor ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {\n    \t\t\t\thandleObj = matched.matches[ j ];\n    \n    \t\t\t\t// Triggered event must either 1) be non-exclusive and have no namespace, or\n    \t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n    \t\t\t\tif ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {\n    \n    \t\t\t\t\tevent.data = handleObj.data;\n    \t\t\t\t\tevent.handleObj = handleObj;\n    \n    \t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n    \t\t\t\t\t\t\t.apply( matched.elem, args );\n    \n    \t\t\t\t\tif ( ret !== undefined ) {\n    \t\t\t\t\t\tevent.result = ret;\n    \t\t\t\t\t\tif ( ret === false ) {\n    \t\t\t\t\t\t\tevent.preventDefault();\n    \t\t\t\t\t\t\tevent.stopPropagation();\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn event.result;\n    \t},\n    \n    \t// Includes some event props shared by KeyEvent and MouseEvent\n    \t// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***\n    \tprops: \"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n    \n    \tfixHooks: {},\n    \n    \tkeyHooks: {\n    \t\tprops: \"char charCode key keyCode\".split(\" \"),\n    \t\tfilter: function( event, original ) {\n    \n    \t\t\t// Add which for key events\n    \t\t\tif ( event.which == null ) {\n    \t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n    \t\t\t}\n    \n    \t\t\treturn event;\n    \t\t}\n    \t},\n    \n    \tmouseHooks: {\n    \t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n    \t\tfilter: function( event, original ) {\n    \t\t\tvar eventDoc, doc, body,\n    \t\t\t\tbutton = original.button,\n    \t\t\t\tfromElement = original.fromElement;\n    \n    \t\t\t// Calculate pageX/Y if missing and clientX/Y available\n    \t\t\tif ( event.pageX == null && original.clientX != null ) {\n    \t\t\t\teventDoc = event.target.ownerDocument || document;\n    \t\t\t\tdoc = eventDoc.documentElement;\n    \t\t\t\tbody = eventDoc.body;\n    \n    \t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n    \t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n    \t\t\t}\n    \n    \t\t\t// Add relatedTarget, if necessary\n    \t\t\tif ( !event.relatedTarget && fromElement ) {\n    \t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n    \t\t\t}\n    \n    \t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n    \t\t\t// Note: button is not normalized, so don't use it\n    \t\t\tif ( !event.which && button !== undefined ) {\n    \t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n    \t\t\t}\n    \n    \t\t\treturn event;\n    \t\t}\n    \t},\n    \n    \tfix: function( event ) {\n    \t\tif ( event[ jQuery.expando ] ) {\n    \t\t\treturn event;\n    \t\t}\n    \n    \t\t// Create a writable copy of the event object and normalize some properties\n    \t\tvar i, prop,\n    \t\t\toriginalEvent = event,\n    \t\t\tfixHook = jQuery.event.fixHooks[ event.type ] || {},\n    \t\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n    \n    \t\tevent = jQuery.Event( originalEvent );\n    \n    \t\tfor ( i = copy.length; i; ) {\n    \t\t\tprop = copy[ --i ];\n    \t\t\tevent[ prop ] = originalEvent[ prop ];\n    \t\t}\n    \n    \t\t// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)\n    \t\tif ( !event.target ) {\n    \t\t\tevent.target = originalEvent.srcElement || document;\n    \t\t}\n    \n    \t\t// Target should not be a text node (#504, Safari)\n    \t\tif ( event.target.nodeType === 3 ) {\n    \t\t\tevent.target = event.target.parentNode;\n    \t\t}\n    \n    \t\t// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)\n    \t\tif ( event.metaKey === undefined ) {\n    \t\t\tevent.metaKey = event.ctrlKey;\n    \t\t}\n    \n    \t\treturn fixHook.filter? fixHook.filter( event, originalEvent ) : event;\n    \t},\n    \n    \tspecial: {\n    \t\tready: {\n    \t\t\t// Make sure the ready event is setup\n    \t\t\tsetup: jQuery.bindReady\n    \t\t},\n    \n    \t\tload: {\n    \t\t\t// Prevent triggered image.load events from bubbling to window.load\n    \t\t\tnoBubble: true\n    \t\t},\n    \n    \t\tfocus: {\n    \t\t\tdelegateType: \"focusin\"\n    \t\t},\n    \t\tblur: {\n    \t\t\tdelegateType: \"focusout\"\n    \t\t},\n    \n    \t\tbeforeunload: {\n    \t\t\tsetup: function( data, namespaces, eventHandle ) {\n    \t\t\t\t// We only want to do this special case on windows\n    \t\t\t\tif ( jQuery.isWindow( this ) ) {\n    \t\t\t\t\tthis.onbeforeunload = eventHandle;\n    \t\t\t\t}\n    \t\t\t},\n    \n    \t\t\tteardown: function( namespaces, eventHandle ) {\n    \t\t\t\tif ( this.onbeforeunload === eventHandle ) {\n    \t\t\t\t\tthis.onbeforeunload = null;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \tsimulate: function( type, elem, event, bubble ) {\n    \t\t// Piggyback on a donor event to simulate a different one.\n    \t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n    \t\t// simulated event prevents default then we do the same on the donor.\n    \t\tvar e = jQuery.extend(\n    \t\t\tnew jQuery.Event(),\n    \t\t\tevent,\n    \t\t\t{ type: type,\n    \t\t\t\tisSimulated: true,\n    \t\t\t\toriginalEvent: {}\n    \t\t\t}\n    \t\t);\n    \t\tif ( bubble ) {\n    \t\t\tjQuery.event.trigger( e, null, elem );\n    \t\t} else {\n    \t\t\tjQuery.event.dispatch.call( elem, e );\n    \t\t}\n    \t\tif ( e.isDefaultPrevented() ) {\n    \t\t\tevent.preventDefault();\n    \t\t}\n    \t}\n    };\n    \n    // Some plugins are using, but it's undocumented/deprecated and will be removed.\n    // The 1.7 special event interface should provide all the hooks needed now.\n    jQuery.event.handle = jQuery.event.dispatch;\n    \n    jQuery.removeEvent = document.removeEventListener ?\n    \tfunction( elem, type, handle ) {\n    \t\tif ( elem.removeEventListener ) {\n    \t\t\telem.removeEventListener( type, handle, false );\n    \t\t}\n    \t} :\n    \tfunction( elem, type, handle ) {\n    \t\tif ( elem.detachEvent ) {\n    \t\t\telem.detachEvent( \"on\" + type, handle );\n    \t\t}\n    \t};\n    \n    jQuery.Event = function( src, props ) {\n    \t// Allow instantiation without the 'new' keyword\n    \tif ( !(this instanceof jQuery.Event) ) {\n    \t\treturn new jQuery.Event( src, props );\n    \t}\n    \n    \t// Event object\n    \tif ( src && src.type ) {\n    \t\tthis.originalEvent = src;\n    \t\tthis.type = src.type;\n    \n    \t\t// Events bubbling up the document may have been marked as prevented\n    \t\t// by a handler lower down the tree; reflect the correct value.\n    \t\tthis.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||\n    \t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n    \n    \t// Event type\n    \t} else {\n    \t\tthis.type = src;\n    \t}\n    \n    \t// Put explicitly provided properties onto the event object\n    \tif ( props ) {\n    \t\tjQuery.extend( this, props );\n    \t}\n    \n    \t// Create a timestamp if incoming event doesn't have one\n    \tthis.timeStamp = src && src.timeStamp || jQuery.now();\n    \n    \t// Mark it as fixed\n    \tthis[ jQuery.expando ] = true;\n    };\n    \n    function returnFalse() {\n    \treturn false;\n    }\n    function returnTrue() {\n    \treturn true;\n    }\n    \n    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n    jQuery.Event.prototype = {\n    \tpreventDefault: function() {\n    \t\tthis.isDefaultPrevented = returnTrue;\n    \n    \t\tvar e = this.originalEvent;\n    \t\tif ( !e ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// if preventDefault exists run it on the original event\n    \t\tif ( e.preventDefault ) {\n    \t\t\te.preventDefault();\n    \n    \t\t// otherwise set the returnValue property of the original event to false (IE)\n    \t\t} else {\n    \t\t\te.returnValue = false;\n    \t\t}\n    \t},\n    \tstopPropagation: function() {\n    \t\tthis.isPropagationStopped = returnTrue;\n    \n    \t\tvar e = this.originalEvent;\n    \t\tif ( !e ) {\n    \t\t\treturn;\n    \t\t}\n    \t\t// if stopPropagation exists run it on the original event\n    \t\tif ( e.stopPropagation ) {\n    \t\t\te.stopPropagation();\n    \t\t}\n    \t\t// otherwise set the cancelBubble property of the original event to true (IE)\n    \t\te.cancelBubble = true;\n    \t},\n    \tstopImmediatePropagation: function() {\n    \t\tthis.isImmediatePropagationStopped = returnTrue;\n    \t\tthis.stopPropagation();\n    \t},\n    \tisDefaultPrevented: returnFalse,\n    \tisPropagationStopped: returnFalse,\n    \tisImmediatePropagationStopped: returnFalse\n    };\n    \n    // Create mouseenter/leave events using mouseover/out and event-time checks\n    jQuery.each({\n    \tmouseenter: \"mouseover\",\n    \tmouseleave: \"mouseout\"\n    }, function( orig, fix ) {\n    \tjQuery.event.special[ orig ] = {\n    \t\tdelegateType: fix,\n    \t\tbindType: fix,\n    \n    \t\thandle: function( event ) {\n    \t\t\tvar target = this,\n    \t\t\t\trelated = event.relatedTarget,\n    \t\t\t\thandleObj = event.handleObj,\n    \t\t\t\tselector = handleObj.selector,\n    \t\t\t\tret;\n    \n    \t\t\t// For mousenter/leave call the handler if related is outside the target.\n    \t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n    \t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n    \t\t\t\tevent.type = handleObj.origType;\n    \t\t\t\tret = handleObj.handler.apply( this, arguments );\n    \t\t\t\tevent.type = fix;\n    \t\t\t}\n    \t\t\treturn ret;\n    \t\t}\n    \t};\n    });\n    \n    // IE submit delegation\n    if ( !jQuery.support.submitBubbles ) {\n    \n    \tjQuery.event.special.submit = {\n    \t\tsetup: function() {\n    \t\t\t// Only need this for delegated form submit events\n    \t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \n    \t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n    \t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n    \t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n    \t\t\t\tvar elem = e.target,\n    \t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n    \t\t\t\tif ( form && !form._submit_attached ) {\n    \t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n    \t\t\t\t\t\t// If form was submitted by the user, bubble the event up the tree\n    \t\t\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n    \t\t\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t});\n    \t\t\t\t\tform._submit_attached = true;\n    \t\t\t\t}\n    \t\t\t});\n    \t\t\t// return undefined since we don't need an event listener\n    \t\t},\n    \n    \t\tteardown: function() {\n    \t\t\t// Only need this for delegated form submit events\n    \t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \n    \t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n    \t\t\tjQuery.event.remove( this, \"._submit\" );\n    \t\t}\n    \t};\n    }\n    \n    // IE change delegation and checkbox/radio fix\n    if ( !jQuery.support.changeBubbles ) {\n    \n    \tjQuery.event.special.change = {\n    \n    \t\tsetup: function() {\n    \n    \t\t\tif ( rformElems.test( this.nodeName ) ) {\n    \t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n    \t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n    \t\t\t\t// This still fires onchange a second time for check/radio after blur.\n    \t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n    \t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n    \t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n    \t\t\t\t\t\t\tthis._just_changed = true;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t});\n    \t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n    \t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n    \t\t\t\t\t\t\tthis._just_changed = false;\n    \t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t});\n    \t\t\t\t}\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n    \t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n    \t\t\t\tvar elem = e.target;\n    \n    \t\t\t\tif ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {\n    \t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n    \t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n    \t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t});\n    \t\t\t\t\telem._change_attached = true;\n    \t\t\t\t}\n    \t\t\t});\n    \t\t},\n    \n    \t\thandle: function( event ) {\n    \t\t\tvar elem = event.target;\n    \n    \t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n    \t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n    \t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n    \t\t\t}\n    \t\t},\n    \n    \t\tteardown: function() {\n    \t\t\tjQuery.event.remove( this, \"._change\" );\n    \n    \t\t\treturn rformElems.test( this.nodeName );\n    \t\t}\n    \t};\n    }\n    \n    // Create \"bubbling\" focus and blur events\n    if ( !jQuery.support.focusinBubbles ) {\n    \tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n    \n    \t\t// Attach a single capturing handler while someone wants focusin/focusout\n    \t\tvar attaches = 0,\n    \t\t\thandler = function( event ) {\n    \t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n    \t\t\t};\n    \n    \t\tjQuery.event.special[ fix ] = {\n    \t\t\tsetup: function() {\n    \t\t\t\tif ( attaches++ === 0 ) {\n    \t\t\t\t\tdocument.addEventListener( orig, handler, true );\n    \t\t\t\t}\n    \t\t\t},\n    \t\t\tteardown: function() {\n    \t\t\t\tif ( --attaches === 0 ) {\n    \t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t};\n    \t});\n    }\n    \n    jQuery.fn.extend({\n    \n    \ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n    \t\tvar origFn, type;\n    \n    \t\t// Types can be a map of types/handlers\n    \t\tif ( typeof types === \"object\" ) {\n    \t\t\t// ( types-Object, selector, data )\n    \t\t\tif ( typeof selector !== \"string\" ) {\n    \t\t\t\t// ( types-Object, data )\n    \t\t\t\tdata = selector;\n    \t\t\t\tselector = undefined;\n    \t\t\t}\n    \t\t\tfor ( type in types ) {\n    \t\t\t\tthis.on( type, selector, data, types[ type ], one );\n    \t\t\t}\n    \t\t\treturn this;\n    \t\t}\n    \n    \t\tif ( data == null && fn == null ) {\n    \t\t\t// ( types, fn )\n    \t\t\tfn = selector;\n    \t\t\tdata = selector = undefined;\n    \t\t} else if ( fn == null ) {\n    \t\t\tif ( typeof selector === \"string\" ) {\n    \t\t\t\t// ( types, selector, fn )\n    \t\t\t\tfn = data;\n    \t\t\t\tdata = undefined;\n    \t\t\t} else {\n    \t\t\t\t// ( types, data, fn )\n    \t\t\t\tfn = data;\n    \t\t\t\tdata = selector;\n    \t\t\t\tselector = undefined;\n    \t\t\t}\n    \t\t}\n    \t\tif ( fn === false ) {\n    \t\t\tfn = returnFalse;\n    \t\t} else if ( !fn ) {\n    \t\t\treturn this;\n    \t\t}\n    \n    \t\tif ( one === 1 ) {\n    \t\t\torigFn = fn;\n    \t\t\tfn = function( event ) {\n    \t\t\t\t// Can use an empty set, since event contains the info\n    \t\t\t\tjQuery().off( event );\n    \t\t\t\treturn origFn.apply( this, arguments );\n    \t\t\t};\n    \t\t\t// Use same guid so caller can remove using origFn\n    \t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n    \t\t}\n    \t\treturn this.each( function() {\n    \t\t\tjQuery.event.add( this, types, fn, data, selector );\n    \t\t});\n    \t},\n    \tone: function( types, selector, data, fn ) {\n    \t\treturn this.on.call( this, types, selector, data, fn, 1 );\n    \t},\n    \toff: function( types, selector, fn ) {\n    \t\tif ( types && types.preventDefault && types.handleObj ) {\n    \t\t\t// ( event )  dispatched jQuery.Event\n    \t\t\tvar handleObj = types.handleObj;\n    \t\t\tjQuery( types.delegateTarget ).off(\n    \t\t\t\thandleObj.namespace? handleObj.type + \".\" + handleObj.namespace : handleObj.type,\n    \t\t\t\thandleObj.selector,\n    \t\t\t\thandleObj.handler\n    \t\t\t);\n    \t\t\treturn this;\n    \t\t}\n    \t\tif ( typeof types === \"object\" ) {\n    \t\t\t// ( types-object [, selector] )\n    \t\t\tfor ( var type in types ) {\n    \t\t\t\tthis.off( type, selector, types[ type ] );\n    \t\t\t}\n    \t\t\treturn this;\n    \t\t}\n    \t\tif ( selector === false || typeof selector === \"function\" ) {\n    \t\t\t// ( types [, fn] )\n    \t\t\tfn = selector;\n    \t\t\tselector = undefined;\n    \t\t}\n    \t\tif ( fn === false ) {\n    \t\t\tfn = returnFalse;\n    \t\t}\n    \t\treturn this.each(function() {\n    \t\t\tjQuery.event.remove( this, types, fn, selector );\n    \t\t});\n    \t},\n    \n    \tbind: function( types, data, fn ) {\n    \t\treturn this.on( types, null, data, fn );\n    \t},\n    \tunbind: function( types, fn ) {\n    \t\treturn this.off( types, null, fn );\n    \t},\n    \n    \tlive: function( types, data, fn ) {\n    \t\tjQuery( this.context ).on( types, this.selector, data, fn );\n    \t\treturn this;\n    \t},\n    \tdie: function( types, fn ) {\n    \t\tjQuery( this.context ).off( types, this.selector || \"**\", fn );\n    \t\treturn this;\n    \t},\n    \n    \tdelegate: function( selector, types, data, fn ) {\n    \t\treturn this.on( types, selector, data, fn );\n    \t},\n    \tundelegate: function( selector, types, fn ) {\n    \t\t// ( namespace ) or ( selector, types [, fn] )\n    \t\treturn arguments.length == 1? this.off( selector, \"**\" ) : this.off( types, selector, fn );\n    \t},\n    \n    \ttrigger: function( type, data ) {\n    \t\treturn this.each(function() {\n    \t\t\tjQuery.event.trigger( type, data, this );\n    \t\t});\n    \t},\n    \ttriggerHandler: function( type, data ) {\n    \t\tif ( this[0] ) {\n    \t\t\treturn jQuery.event.trigger( type, data, this[0], true );\n    \t\t}\n    \t},\n    \n    \ttoggle: function( fn ) {\n    \t\t// Save reference to arguments for access in closure\n    \t\tvar args = arguments,\n    \t\t\tguid = fn.guid || jQuery.guid++,\n    \t\t\ti = 0,\n    \t\t\ttoggler = function( event ) {\n    \t\t\t\t// Figure out which function to execute\n    \t\t\t\tvar lastToggle = ( jQuery._data( this, \"lastToggle\" + fn.guid ) || 0 ) % i;\n    \t\t\t\tjQuery._data( this, \"lastToggle\" + fn.guid, lastToggle + 1 );\n    \n    \t\t\t\t// Make sure that clicks stop\n    \t\t\t\tevent.preventDefault();\n    \n    \t\t\t\t// and execute the function\n    \t\t\t\treturn args[ lastToggle ].apply( this, arguments ) || false;\n    \t\t\t};\n    \n    \t\t// link all the functions, so any of them can unbind this click handler\n    \t\ttoggler.guid = guid;\n    \t\twhile ( i < args.length ) {\n    \t\t\targs[ i++ ].guid = guid;\n    \t\t}\n    \n    \t\treturn this.click( toggler );\n    \t},\n    \n    \thover: function( fnOver, fnOut ) {\n    \t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n    \t}\n    });\n    \n    jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n    \t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n    \n    \t// Handle event binding\n    \tjQuery.fn[ name ] = function( data, fn ) {\n    \t\tif ( fn == null ) {\n    \t\t\tfn = data;\n    \t\t\tdata = null;\n    \t\t}\n    \n    \t\treturn arguments.length > 0 ?\n    \t\t\tthis.on( name, null, data, fn ) :\n    \t\t\tthis.trigger( name );\n    \t};\n    \n    \tif ( jQuery.attrFn ) {\n    \t\tjQuery.attrFn[ name ] = true;\n    \t}\n    \n    \tif ( rkeyEvent.test( name ) ) {\n    \t\tjQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;\n    \t}\n    \n    \tif ( rmouseEvent.test( name ) ) {\n    \t\tjQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;\n    \t}\n    });\n    \n    \n    \n    /*!\n     * Sizzle CSS Selector Engine\n     *  Copyright 2011, The Dojo Foundation\n     *  Released under the MIT, BSD, and GPL Licenses.\n     *  More information: http://sizzlejs.com/\n     */\n    (function(){\n    \n    var chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\n    \texpando = \"sizcache\" + (Math.random() + '').replace('.', ''),\n    \tdone = 0,\n    \ttoString = Object.prototype.toString,\n    \thasDuplicate = false,\n    \tbaseHasDuplicate = true,\n    \trBackslash = /\\\\/g,\n    \trReturn = /\\r\\n/g,\n    \trNonWord = /\\W/;\n    \n    // Here we check if the JavaScript engine is using some sort of\n    // optimization where it does not always call our comparision\n    // function. If that is the case, discard the hasDuplicate value.\n    //   Thus far that includes Google Chrome.\n    [0, 0].sort(function() {\n    \tbaseHasDuplicate = false;\n    \treturn 0;\n    });\n    \n    var Sizzle = function( selector, context, results, seed ) {\n    \tresults = results || [];\n    \tcontext = context || document;\n    \n    \tvar origContext = context;\n    \n    \tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n    \t\treturn [];\n    \t}\n    \t\n    \tif ( !selector || typeof selector !== \"string\" ) {\n    \t\treturn results;\n    \t}\n    \n    \tvar m, set, checkSet, extra, ret, cur, pop, i,\n    \t\tprune = true,\n    \t\tcontextXML = Sizzle.isXML( context ),\n    \t\tparts = [],\n    \t\tsoFar = selector;\n    \t\n    \t// Reset the position of the chunker regexp (start from head)\n    \tdo {\n    \t\tchunker.exec( \"\" );\n    \t\tm = chunker.exec( soFar );\n    \n    \t\tif ( m ) {\n    \t\t\tsoFar = m[3];\n    \t\t\n    \t\t\tparts.push( m[1] );\n    \t\t\n    \t\t\tif ( m[2] ) {\n    \t\t\t\textra = m[3];\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t} while ( m );\n    \n    \tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n    \n    \t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n    \t\t\tset = posProcess( parts[0] + parts[1], context, seed );\n    \n    \t\t} else {\n    \t\t\tset = Expr.relative[ parts[0] ] ?\n    \t\t\t\t[ context ] :\n    \t\t\t\tSizzle( parts.shift(), context );\n    \n    \t\t\twhile ( parts.length ) {\n    \t\t\t\tselector = parts.shift();\n    \n    \t\t\t\tif ( Expr.relative[ selector ] ) {\n    \t\t\t\t\tselector += parts.shift();\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tset = posProcess( selector, set, seed );\n    \t\t\t}\n    \t\t}\n    \n    \t} else {\n    \t\t// Take a shortcut and set the context if the root selector is an ID\n    \t\t// (but not if it'll be faster if the inner selector is an ID)\n    \t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n    \t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n    \n    \t\t\tret = Sizzle.find( parts.shift(), context, contextXML );\n    \t\t\tcontext = ret.expr ?\n    \t\t\t\tSizzle.filter( ret.expr, ret.set )[0] :\n    \t\t\t\tret.set[0];\n    \t\t}\n    \n    \t\tif ( context ) {\n    \t\t\tret = seed ?\n    \t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n    \t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\n    \n    \t\t\tset = ret.expr ?\n    \t\t\t\tSizzle.filter( ret.expr, ret.set ) :\n    \t\t\t\tret.set;\n    \n    \t\t\tif ( parts.length > 0 ) {\n    \t\t\t\tcheckSet = makeArray( set );\n    \n    \t\t\t} else {\n    \t\t\t\tprune = false;\n    \t\t\t}\n    \n    \t\t\twhile ( parts.length ) {\n    \t\t\t\tcur = parts.pop();\n    \t\t\t\tpop = cur;\n    \n    \t\t\t\tif ( !Expr.relative[ cur ] ) {\n    \t\t\t\t\tcur = \"\";\n    \t\t\t\t} else {\n    \t\t\t\t\tpop = parts.pop();\n    \t\t\t\t}\n    \n    \t\t\t\tif ( pop == null ) {\n    \t\t\t\t\tpop = context;\n    \t\t\t\t}\n    \n    \t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\n    \t\t\t}\n    \n    \t\t} else {\n    \t\t\tcheckSet = parts = [];\n    \t\t}\n    \t}\n    \n    \tif ( !checkSet ) {\n    \t\tcheckSet = set;\n    \t}\n    \n    \tif ( !checkSet ) {\n    \t\tSizzle.error( cur || selector );\n    \t}\n    \n    \tif ( toString.call(checkSet) === \"[object Array]\" ) {\n    \t\tif ( !prune ) {\n    \t\t\tresults.push.apply( results, checkSet );\n    \n    \t\t} else if ( context && context.nodeType === 1 ) {\n    \t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\n    \t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {\n    \t\t\t\t\tresults.push( set[i] );\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t} else {\n    \t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\n    \t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n    \t\t\t\t\tresults.push( set[i] );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t} else {\n    \t\tmakeArray( checkSet, results );\n    \t}\n    \n    \tif ( extra ) {\n    \t\tSizzle( extra, origContext, results, seed );\n    \t\tSizzle.uniqueSort( results );\n    \t}\n    \n    \treturn results;\n    };\n    \n    Sizzle.uniqueSort = function( results ) {\n    \tif ( sortOrder ) {\n    \t\thasDuplicate = baseHasDuplicate;\n    \t\tresults.sort( sortOrder );\n    \n    \t\tif ( hasDuplicate ) {\n    \t\t\tfor ( var i = 1; i < results.length; i++ ) {\n    \t\t\t\tif ( results[i] === results[ i - 1 ] ) {\n    \t\t\t\t\tresults.splice( i--, 1 );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \treturn results;\n    };\n    \n    Sizzle.matches = function( expr, set ) {\n    \treturn Sizzle( expr, null, null, set );\n    };\n    \n    Sizzle.matchesSelector = function( node, expr ) {\n    \treturn Sizzle( expr, null, null, [node] ).length > 0;\n    };\n    \n    Sizzle.find = function( expr, context, isXML ) {\n    \tvar set, i, len, match, type, left;\n    \n    \tif ( !expr ) {\n    \t\treturn [];\n    \t}\n    \n    \tfor ( i = 0, len = Expr.order.length; i < len; i++ ) {\n    \t\ttype = Expr.order[i];\n    \t\t\n    \t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) ) {\n    \t\t\tleft = match[1];\n    \t\t\tmatch.splice( 1, 1 );\n    \n    \t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\n    \t\t\t\tmatch[1] = (match[1] || \"\").replace( rBackslash, \"\" );\n    \t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n    \n    \t\t\t\tif ( set != null ) {\n    \t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \tif ( !set ) {\n    \t\tset = typeof context.getElementsByTagName !== \"undefined\" ?\n    \t\t\tcontext.getElementsByTagName( \"*\" ) :\n    \t\t\t[];\n    \t}\n    \n    \treturn { set: set, expr: expr };\n    };\n    \n    Sizzle.filter = function( expr, set, inplace, not ) {\n    \tvar match, anyFound,\n    \t\ttype, found, item, filter, left,\n    \t\ti, pass,\n    \t\told = expr,\n    \t\tresult = [],\n    \t\tcurLoop = set,\n    \t\tisXMLFilter = set && set[0] && Sizzle.isXML( set[0] );\n    \n    \twhile ( expr && set.length ) {\n    \t\tfor ( type in Expr.filter ) {\n    \t\t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {\n    \t\t\t\tfilter = Expr.filter[ type ];\n    \t\t\t\tleft = match[1];\n    \n    \t\t\t\tanyFound = false;\n    \n    \t\t\t\tmatch.splice(1,1);\n    \n    \t\t\t\tif ( left.substr( left.length - 1 ) === \"\\\\\" ) {\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \n    \t\t\t\tif ( curLoop === result ) {\n    \t\t\t\t\tresult = [];\n    \t\t\t\t}\n    \n    \t\t\t\tif ( Expr.preFilter[ type ] ) {\n    \t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n    \n    \t\t\t\t\tif ( !match ) {\n    \t\t\t\t\t\tanyFound = found = true;\n    \n    \t\t\t\t\t} else if ( match === true ) {\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\tif ( match ) {\n    \t\t\t\t\tfor ( i = 0; (item = curLoop[i]) != null; i++ ) {\n    \t\t\t\t\t\tif ( item ) {\n    \t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n    \t\t\t\t\t\t\tpass = not ^ found;\n    \n    \t\t\t\t\t\t\tif ( inplace && found != null ) {\n    \t\t\t\t\t\t\t\tif ( pass ) {\n    \t\t\t\t\t\t\t\t\tanyFound = true;\n    \n    \t\t\t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n    \t\t\t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t\t} else if ( pass ) {\n    \t\t\t\t\t\t\t\tresult.push( item );\n    \t\t\t\t\t\t\t\tanyFound = true;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\tif ( found !== undefined ) {\n    \t\t\t\t\tif ( !inplace ) {\n    \t\t\t\t\t\tcurLoop = result;\n    \t\t\t\t\t}\n    \n    \t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n    \n    \t\t\t\t\tif ( !anyFound ) {\n    \t\t\t\t\t\treturn [];\n    \t\t\t\t\t}\n    \n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Improper expression\n    \t\tif ( expr === old ) {\n    \t\t\tif ( anyFound == null ) {\n    \t\t\t\tSizzle.error( expr );\n    \n    \t\t\t} else {\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \n    \t\told = expr;\n    \t}\n    \n    \treturn curLoop;\n    };\n    \n    Sizzle.error = function( msg ) {\n    \tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n    };\n    \n    /**\n     * Utility function for retreiving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n    var getText = Sizzle.getText = function( elem ) {\n        var i, node,\n    \t\tnodeType = elem.nodeType,\n    \t\tret = \"\";\n    \n    \tif ( nodeType ) {\n    \t\tif ( nodeType === 1 || nodeType === 9 ) {\n    \t\t\t// Use textContent || innerText for elements\n    \t\t\tif ( typeof elem.textContent === 'string' ) {\n    \t\t\t\treturn elem.textContent;\n    \t\t\t} else if ( typeof elem.innerText === 'string' ) {\n    \t\t\t\t// Replace IE's carriage returns\n    \t\t\t\treturn elem.innerText.replace( rReturn, '' );\n    \t\t\t} else {\n    \t\t\t\t// Traverse it's children\n    \t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling) {\n    \t\t\t\t\tret += getText( elem );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n    \t\t\treturn elem.nodeValue;\n    \t\t}\n    \t} else {\n    \n    \t\t// If no nodeType, this is expected to be an array\n    \t\tfor ( i = 0; (node = elem[i]); i++ ) {\n    \t\t\t// Do not traverse comment nodes\n    \t\t\tif ( node.nodeType !== 8 ) {\n    \t\t\t\tret += getText( node );\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn ret;\n    };\n    \n    var Expr = Sizzle.selectors = {\n    \torder: [ \"ID\", \"NAME\", \"TAG\" ],\n    \n    \tmatch: {\n    \t\tID: /#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n    \t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n    \t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,\n    \t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/,\n    \t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,\n    \t\tCHILD: /:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/,\n    \t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,\n    \t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/\n    \t},\n    \n    \tleftMatch: {},\n    \n    \tattrMap: {\n    \t\t\"class\": \"className\",\n    \t\t\"for\": \"htmlFor\"\n    \t},\n    \n    \tattrHandle: {\n    \t\thref: function( elem ) {\n    \t\t\treturn elem.getAttribute( \"href\" );\n    \t\t},\n    \t\ttype: function( elem ) {\n    \t\t\treturn elem.getAttribute( \"type\" );\n    \t\t}\n    \t},\n    \n    \trelative: {\n    \t\t\"+\": function(checkSet, part){\n    \t\t\tvar isPartStr = typeof part === \"string\",\n    \t\t\t\tisTag = isPartStr && !rNonWord.test( part ),\n    \t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n    \n    \t\t\tif ( isTag ) {\n    \t\t\t\tpart = part.toLowerCase();\n    \t\t\t}\n    \n    \t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n    \t\t\t\tif ( (elem = checkSet[i]) ) {\n    \t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n    \n    \t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?\n    \t\t\t\t\t\telem || false :\n    \t\t\t\t\t\telem === part;\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\tif ( isPartStrNotTag ) {\n    \t\t\t\tSizzle.filter( part, checkSet, true );\n    \t\t\t}\n    \t\t},\n    \n    \t\t\">\": function( checkSet, part ) {\n    \t\t\tvar elem,\n    \t\t\t\tisPartStr = typeof part === \"string\",\n    \t\t\t\ti = 0,\n    \t\t\t\tl = checkSet.length;\n    \n    \t\t\tif ( isPartStr && !rNonWord.test( part ) ) {\n    \t\t\t\tpart = part.toLowerCase();\n    \n    \t\t\t\tfor ( ; i < l; i++ ) {\n    \t\t\t\t\telem = checkSet[i];\n    \n    \t\t\t\t\tif ( elem ) {\n    \t\t\t\t\t\tvar parent = elem.parentNode;\n    \t\t\t\t\t\tcheckSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t} else {\n    \t\t\t\tfor ( ; i < l; i++ ) {\n    \t\t\t\t\telem = checkSet[i];\n    \n    \t\t\t\t\tif ( elem ) {\n    \t\t\t\t\t\tcheckSet[i] = isPartStr ?\n    \t\t\t\t\t\t\telem.parentNode :\n    \t\t\t\t\t\t\telem.parentNode === part;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\tif ( isPartStr ) {\n    \t\t\t\t\tSizzle.filter( part, checkSet, true );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \n    \t\t\"\": function(checkSet, part, isXML){\n    \t\t\tvar nodeCheck,\n    \t\t\t\tdoneName = done++,\n    \t\t\t\tcheckFn = dirCheck;\n    \n    \t\t\tif ( typeof part === \"string\" && !rNonWord.test( part ) ) {\n    \t\t\t\tpart = part.toLowerCase();\n    \t\t\t\tnodeCheck = part;\n    \t\t\t\tcheckFn = dirNodeCheck;\n    \t\t\t}\n    \n    \t\t\tcheckFn( \"parentNode\", part, doneName, checkSet, nodeCheck, isXML );\n    \t\t},\n    \n    \t\t\"~\": function( checkSet, part, isXML ) {\n    \t\t\tvar nodeCheck,\n    \t\t\t\tdoneName = done++,\n    \t\t\t\tcheckFn = dirCheck;\n    \n    \t\t\tif ( typeof part === \"string\" && !rNonWord.test( part ) ) {\n    \t\t\t\tpart = part.toLowerCase();\n    \t\t\t\tnodeCheck = part;\n    \t\t\t\tcheckFn = dirNodeCheck;\n    \t\t\t}\n    \n    \t\t\tcheckFn( \"previousSibling\", part, doneName, checkSet, nodeCheck, isXML );\n    \t\t}\n    \t},\n    \n    \tfind: {\n    \t\tID: function( match, context, isXML ) {\n    \t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n    \t\t\t\tvar m = context.getElementById(match[1]);\n    \t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n    \t\t\t\t// nodes that are no longer in the document #6963\n    \t\t\t\treturn m && m.parentNode ? [m] : [];\n    \t\t\t}\n    \t\t},\n    \n    \t\tNAME: function( match, context ) {\n    \t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\n    \t\t\t\tvar ret = [],\n    \t\t\t\t\tresults = context.getElementsByName( match[1] );\n    \n    \t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n    \t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\n    \t\t\t\t\t\tret.push( results[i] );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\treturn ret.length === 0 ? null : ret;\n    \t\t\t}\n    \t\t},\n    \n    \t\tTAG: function( match, context ) {\n    \t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n    \t\t\t\treturn context.getElementsByTagName( match[1] );\n    \t\t\t}\n    \t\t}\n    \t},\n    \tpreFilter: {\n    \t\tCLASS: function( match, curLoop, inplace, result, not, isXML ) {\n    \t\t\tmatch = \" \" + match[1].replace( rBackslash, \"\" ) + \" \";\n    \n    \t\t\tif ( isXML ) {\n    \t\t\t\treturn match;\n    \t\t\t}\n    \n    \t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n    \t\t\t\tif ( elem ) {\n    \t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n\\r]/g, \" \").indexOf(match) >= 0) ) {\n    \t\t\t\t\t\tif ( !inplace ) {\n    \t\t\t\t\t\t\tresult.push( elem );\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t} else if ( inplace ) {\n    \t\t\t\t\t\tcurLoop[i] = false;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\treturn false;\n    \t\t},\n    \n    \t\tID: function( match ) {\n    \t\t\treturn match[1].replace( rBackslash, \"\" );\n    \t\t},\n    \n    \t\tTAG: function( match, curLoop ) {\n    \t\t\treturn match[1].replace( rBackslash, \"\" ).toLowerCase();\n    \t\t},\n    \n    \t\tCHILD: function( match ) {\n    \t\t\tif ( match[1] === \"nth\" ) {\n    \t\t\t\tif ( !match[2] ) {\n    \t\t\t\t\tSizzle.error( match[0] );\n    \t\t\t\t}\n    \n    \t\t\t\tmatch[2] = match[2].replace(/^\\+|\\s*/g, '');\n    \n    \t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n    \t\t\t\tvar test = /(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(\n    \t\t\t\t\tmatch[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" ||\n    \t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n    \n    \t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n    \t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n    \t\t\t\tmatch[3] = test[3] - 0;\n    \t\t\t}\n    \t\t\telse if ( match[2] ) {\n    \t\t\t\tSizzle.error( match[0] );\n    \t\t\t}\n    \n    \t\t\t// TODO: Move to normal caching system\n    \t\t\tmatch[0] = done++;\n    \n    \t\t\treturn match;\n    \t\t},\n    \n    \t\tATTR: function( match, curLoop, inplace, result, not, isXML ) {\n    \t\t\tvar name = match[1] = match[1].replace( rBackslash, \"\" );\n    \t\t\t\n    \t\t\tif ( !isXML && Expr.attrMap[name] ) {\n    \t\t\t\tmatch[1] = Expr.attrMap[name];\n    \t\t\t}\n    \n    \t\t\t// Handle if an un-quoted value was used\n    \t\t\tmatch[4] = ( match[4] || match[5] || \"\" ).replace( rBackslash, \"\" );\n    \n    \t\t\tif ( match[2] === \"~=\" ) {\n    \t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n    \t\t\t}\n    \n    \t\t\treturn match;\n    \t\t},\n    \n    \t\tPSEUDO: function( match, curLoop, inplace, result, not ) {\n    \t\t\tif ( match[1] === \"not\" ) {\n    \t\t\t\t// If we're dealing with a complex expression, or a simple one\n    \t\t\t\tif ( ( chunker.exec(match[3]) || \"\" ).length > 1 || /^\\w/.test(match[3]) ) {\n    \t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n    \n    \t\t\t\t} else {\n    \t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n    \n    \t\t\t\t\tif ( !inplace ) {\n    \t\t\t\t\t\tresult.push.apply( result, ret );\n    \t\t\t\t\t}\n    \n    \t\t\t\t\treturn false;\n    \t\t\t\t}\n    \n    \t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n    \t\t\t\treturn true;\n    \t\t\t}\n    \t\t\t\n    \t\t\treturn match;\n    \t\t},\n    \n    \t\tPOS: function( match ) {\n    \t\t\tmatch.unshift( true );\n    \n    \t\t\treturn match;\n    \t\t}\n    \t},\n    \t\n    \tfilters: {\n    \t\tenabled: function( elem ) {\n    \t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n    \t\t},\n    \n    \t\tdisabled: function( elem ) {\n    \t\t\treturn elem.disabled === true;\n    \t\t},\n    \n    \t\tchecked: function( elem ) {\n    \t\t\treturn elem.checked === true;\n    \t\t},\n    \t\t\n    \t\tselected: function( elem ) {\n    \t\t\t// Accessing this property makes selected-by-default\n    \t\t\t// options in Safari work properly\n    \t\t\tif ( elem.parentNode ) {\n    \t\t\t\telem.parentNode.selectedIndex;\n    \t\t\t}\n    \t\t\t\n    \t\t\treturn elem.selected === true;\n    \t\t},\n    \n    \t\tparent: function( elem ) {\n    \t\t\treturn !!elem.firstChild;\n    \t\t},\n    \n    \t\tempty: function( elem ) {\n    \t\t\treturn !elem.firstChild;\n    \t\t},\n    \n    \t\thas: function( elem, i, match ) {\n    \t\t\treturn !!Sizzle( match[3], elem ).length;\n    \t\t},\n    \n    \t\theader: function( elem ) {\n    \t\t\treturn (/h\\d/i).test( elem.nodeName );\n    \t\t},\n    \n    \t\ttext: function( elem ) {\n    \t\t\tvar attr = elem.getAttribute( \"type\" ), type = elem.type;\n    \t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) \n    \t\t\t// use getAttribute instead to test this case\n    \t\t\treturn elem.nodeName.toLowerCase() === \"input\" && \"text\" === type && ( attr === type || attr === null );\n    \t\t},\n    \n    \t\tradio: function( elem ) {\n    \t\t\treturn elem.nodeName.toLowerCase() === \"input\" && \"radio\" === elem.type;\n    \t\t},\n    \n    \t\tcheckbox: function( elem ) {\n    \t\t\treturn elem.nodeName.toLowerCase() === \"input\" && \"checkbox\" === elem.type;\n    \t\t},\n    \n    \t\tfile: function( elem ) {\n    \t\t\treturn elem.nodeName.toLowerCase() === \"input\" && \"file\" === elem.type;\n    \t\t},\n    \n    \t\tpassword: function( elem ) {\n    \t\t\treturn elem.nodeName.toLowerCase() === \"input\" && \"password\" === elem.type;\n    \t\t},\n    \n    \t\tsubmit: function( elem ) {\n    \t\t\tvar name = elem.nodeName.toLowerCase();\n    \t\t\treturn (name === \"input\" || name === \"button\") && \"submit\" === elem.type;\n    \t\t},\n    \n    \t\timage: function( elem ) {\n    \t\t\treturn elem.nodeName.toLowerCase() === \"input\" && \"image\" === elem.type;\n    \t\t},\n    \n    \t\treset: function( elem ) {\n    \t\t\tvar name = elem.nodeName.toLowerCase();\n    \t\t\treturn (name === \"input\" || name === \"button\") && \"reset\" === elem.type;\n    \t\t},\n    \n    \t\tbutton: function( elem ) {\n    \t\t\tvar name = elem.nodeName.toLowerCase();\n    \t\t\treturn name === \"input\" && \"button\" === elem.type || name === \"button\";\n    \t\t},\n    \n    \t\tinput: function( elem ) {\n    \t\t\treturn (/input|select|textarea|button/i).test( elem.nodeName );\n    \t\t},\n    \n    \t\tfocus: function( elem ) {\n    \t\t\treturn elem === elem.ownerDocument.activeElement;\n    \t\t}\n    \t},\n    \tsetFilters: {\n    \t\tfirst: function( elem, i ) {\n    \t\t\treturn i === 0;\n    \t\t},\n    \n    \t\tlast: function( elem, i, match, array ) {\n    \t\t\treturn i === array.length - 1;\n    \t\t},\n    \n    \t\teven: function( elem, i ) {\n    \t\t\treturn i % 2 === 0;\n    \t\t},\n    \n    \t\todd: function( elem, i ) {\n    \t\t\treturn i % 2 === 1;\n    \t\t},\n    \n    \t\tlt: function( elem, i, match ) {\n    \t\t\treturn i < match[3] - 0;\n    \t\t},\n    \n    \t\tgt: function( elem, i, match ) {\n    \t\t\treturn i > match[3] - 0;\n    \t\t},\n    \n    \t\tnth: function( elem, i, match ) {\n    \t\t\treturn match[3] - 0 === i;\n    \t\t},\n    \n    \t\teq: function( elem, i, match ) {\n    \t\t\treturn match[3] - 0 === i;\n    \t\t}\n    \t},\n    \tfilter: {\n    \t\tPSEUDO: function( elem, match, i, array ) {\n    \t\t\tvar name = match[1],\n    \t\t\t\tfilter = Expr.filters[ name ];\n    \n    \t\t\tif ( filter ) {\n    \t\t\t\treturn filter( elem, i, match, array );\n    \n    \t\t\t} else if ( name === \"contains\" ) {\n    \t\t\t\treturn (elem.textContent || elem.innerText || getText([ elem ]) || \"\").indexOf(match[3]) >= 0;\n    \n    \t\t\t} else if ( name === \"not\" ) {\n    \t\t\t\tvar not = match[3];\n    \n    \t\t\t\tfor ( var j = 0, l = not.length; j < l; j++ ) {\n    \t\t\t\t\tif ( not[j] === elem ) {\n    \t\t\t\t\t\treturn false;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\treturn true;\n    \n    \t\t\t} else {\n    \t\t\t\tSizzle.error( name );\n    \t\t\t}\n    \t\t},\n    \n    \t\tCHILD: function( elem, match ) {\n    \t\t\tvar first, last,\n    \t\t\t\tdoneName, parent, cache,\n    \t\t\t\tcount, diff,\n    \t\t\t\ttype = match[1],\n    \t\t\t\tnode = elem;\n    \n    \t\t\tswitch ( type ) {\n    \t\t\t\tcase \"only\":\n    \t\t\t\tcase \"first\":\n    \t\t\t\t\twhile ( (node = node.previousSibling) )\t {\n    \t\t\t\t\t\tif ( node.nodeType === 1 ) { \n    \t\t\t\t\t\t\treturn false; \n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \n    \t\t\t\t\tif ( type === \"first\" ) { \n    \t\t\t\t\t\treturn true; \n    \t\t\t\t\t}\n    \n    \t\t\t\t\tnode = elem;\n    \n    \t\t\t\tcase \"last\":\n    \t\t\t\t\twhile ( (node = node.nextSibling) )\t {\n    \t\t\t\t\t\tif ( node.nodeType === 1 ) { \n    \t\t\t\t\t\t\treturn false; \n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \n    \t\t\t\t\treturn true;\n    \n    \t\t\t\tcase \"nth\":\n    \t\t\t\t\tfirst = match[2];\n    \t\t\t\t\tlast = match[3];\n    \n    \t\t\t\t\tif ( first === 1 && last === 0 ) {\n    \t\t\t\t\t\treturn true;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tdoneName = match[0];\n    \t\t\t\t\tparent = elem.parentNode;\n    \t\n    \t\t\t\t\tif ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {\n    \t\t\t\t\t\tcount = 0;\n    \t\t\t\t\t\t\n    \t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n    \t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n    \t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t} \n    \n    \t\t\t\t\t\tparent[ expando ] = doneName;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tdiff = elem.nodeIndex - last;\n    \n    \t\t\t\t\tif ( first === 0 ) {\n    \t\t\t\t\t\treturn diff === 0;\n    \n    \t\t\t\t\t} else {\n    \t\t\t\t\t\treturn ( diff % first === 0 && diff / first >= 0 );\n    \t\t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \n    \t\tID: function( elem, match ) {\n    \t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n    \t\t},\n    \n    \t\tTAG: function( elem, match ) {\n    \t\t\treturn (match === \"*\" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;\n    \t\t},\n    \t\t\n    \t\tCLASS: function( elem, match ) {\n    \t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\n    \t\t\t\t.indexOf( match ) > -1;\n    \t\t},\n    \n    \t\tATTR: function( elem, match ) {\n    \t\t\tvar name = match[1],\n    \t\t\t\tresult = Sizzle.attr ?\n    \t\t\t\t\tSizzle.attr( elem, name ) :\n    \t\t\t\t\tExpr.attrHandle[ name ] ?\n    \t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n    \t\t\t\t\telem[ name ] != null ?\n    \t\t\t\t\t\telem[ name ] :\n    \t\t\t\t\t\telem.getAttribute( name ),\n    \t\t\t\tvalue = result + \"\",\n    \t\t\t\ttype = match[2],\n    \t\t\t\tcheck = match[4];\n    \n    \t\t\treturn result == null ?\n    \t\t\t\ttype === \"!=\" :\n    \t\t\t\t!type && Sizzle.attr ?\n    \t\t\t\tresult != null :\n    \t\t\t\ttype === \"=\" ?\n    \t\t\t\tvalue === check :\n    \t\t\t\ttype === \"*=\" ?\n    \t\t\t\tvalue.indexOf(check) >= 0 :\n    \t\t\t\ttype === \"~=\" ?\n    \t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n    \t\t\t\t!check ?\n    \t\t\t\tvalue && result !== false :\n    \t\t\t\ttype === \"!=\" ?\n    \t\t\t\tvalue !== check :\n    \t\t\t\ttype === \"^=\" ?\n    \t\t\t\tvalue.indexOf(check) === 0 :\n    \t\t\t\ttype === \"$=\" ?\n    \t\t\t\tvalue.substr(value.length - check.length) === check :\n    \t\t\t\ttype === \"|=\" ?\n    \t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n    \t\t\t\tfalse;\n    \t\t},\n    \n    \t\tPOS: function( elem, match, i, array ) {\n    \t\t\tvar name = match[2],\n    \t\t\t\tfilter = Expr.setFilters[ name ];\n    \n    \t\t\tif ( filter ) {\n    \t\t\t\treturn filter( elem, i, match, array );\n    \t\t\t}\n    \t\t}\n    \t}\n    };\n    \n    var origPOS = Expr.match.POS,\n    \tfescape = function(all, num){\n    \t\treturn \"\\\\\" + (num - 0 + 1);\n    \t};\n    \n    for ( var type in Expr.match ) {\n    \tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\\[]*\\])(?![^\\(]*\\))/.source) );\n    \tExpr.leftMatch[ type ] = new RegExp( /(^(?:.|\\r|\\n)*?)/.source + Expr.match[ type ].source.replace(/\\\\(\\d+)/g, fescape) );\n    }\n    \n    var makeArray = function( array, results ) {\n    \tarray = Array.prototype.slice.call( array, 0 );\n    \n    \tif ( results ) {\n    \t\tresults.push.apply( results, array );\n    \t\treturn results;\n    \t}\n    \t\n    \treturn array;\n    };\n    \n    // Perform a simple check to determine if the browser is capable of\n    // converting a NodeList to an array using builtin methods.\n    // Also verifies that the returned array holds DOM nodes\n    // (which is not the case in the Blackberry browser)\n    try {\n    \tArray.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;\n    \n    // Provide a fallback method if it does not work\n    } catch( e ) {\n    \tmakeArray = function( array, results ) {\n    \t\tvar i = 0,\n    \t\t\tret = results || [];\n    \n    \t\tif ( toString.call(array) === \"[object Array]\" ) {\n    \t\t\tArray.prototype.push.apply( ret, array );\n    \n    \t\t} else {\n    \t\t\tif ( typeof array.length === \"number\" ) {\n    \t\t\t\tfor ( var l = array.length; i < l; i++ ) {\n    \t\t\t\t\tret.push( array[i] );\n    \t\t\t\t}\n    \n    \t\t\t} else {\n    \t\t\t\tfor ( ; array[i]; i++ ) {\n    \t\t\t\t\tret.push( array[i] );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn ret;\n    \t};\n    }\n    \n    var sortOrder, siblingCheck;\n    \n    if ( document.documentElement.compareDocumentPosition ) {\n    \tsortOrder = function( a, b ) {\n    \t\tif ( a === b ) {\n    \t\t\thasDuplicate = true;\n    \t\t\treturn 0;\n    \t\t}\n    \n    \t\tif ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {\n    \t\t\treturn a.compareDocumentPosition ? -1 : 1;\n    \t\t}\n    \n    \t\treturn a.compareDocumentPosition(b) & 4 ? -1 : 1;\n    \t};\n    \n    } else {\n    \tsortOrder = function( a, b ) {\n    \t\t// The nodes are identical, we can exit early\n    \t\tif ( a === b ) {\n    \t\t\thasDuplicate = true;\n    \t\t\treturn 0;\n    \n    \t\t// Fallback to using sourceIndex (in IE) if it's available on both nodes\n    \t\t} else if ( a.sourceIndex && b.sourceIndex ) {\n    \t\t\treturn a.sourceIndex - b.sourceIndex;\n    \t\t}\n    \n    \t\tvar al, bl,\n    \t\t\tap = [],\n    \t\t\tbp = [],\n    \t\t\taup = a.parentNode,\n    \t\t\tbup = b.parentNode,\n    \t\t\tcur = aup;\n    \n    \t\t// If the nodes are siblings (or identical) we can do a quick check\n    \t\tif ( aup === bup ) {\n    \t\t\treturn siblingCheck( a, b );\n    \n    \t\t// If no parents were found then the nodes are disconnected\n    \t\t} else if ( !aup ) {\n    \t\t\treturn -1;\n    \n    \t\t} else if ( !bup ) {\n    \t\t\treturn 1;\n    \t\t}\n    \n    \t\t// Otherwise they're somewhere else in the tree so we need\n    \t\t// to build up a full list of the parentNodes for comparison\n    \t\twhile ( cur ) {\n    \t\t\tap.unshift( cur );\n    \t\t\tcur = cur.parentNode;\n    \t\t}\n    \n    \t\tcur = bup;\n    \n    \t\twhile ( cur ) {\n    \t\t\tbp.unshift( cur );\n    \t\t\tcur = cur.parentNode;\n    \t\t}\n    \n    \t\tal = ap.length;\n    \t\tbl = bp.length;\n    \n    \t\t// Start walking down the tree looking for a discrepancy\n    \t\tfor ( var i = 0; i < al && i < bl; i++ ) {\n    \t\t\tif ( ap[i] !== bp[i] ) {\n    \t\t\t\treturn siblingCheck( ap[i], bp[i] );\n    \t\t\t}\n    \t\t}\n    \n    \t\t// We ended someplace up the tree so do a sibling check\n    \t\treturn i === al ?\n    \t\t\tsiblingCheck( a, bp[i], -1 ) :\n    \t\t\tsiblingCheck( ap[i], b, 1 );\n    \t};\n    \n    \tsiblingCheck = function( a, b, ret ) {\n    \t\tif ( a === b ) {\n    \t\t\treturn ret;\n    \t\t}\n    \n    \t\tvar cur = a.nextSibling;\n    \n    \t\twhile ( cur ) {\n    \t\t\tif ( cur === b ) {\n    \t\t\t\treturn -1;\n    \t\t\t}\n    \n    \t\t\tcur = cur.nextSibling;\n    \t\t}\n    \n    \t\treturn 1;\n    \t};\n    }\n    \n    // Check to see if the browser returns elements by name when\n    // querying by getElementById (and provide a workaround)\n    (function(){\n    \t// We're going to inject a fake input element with a specified name\n    \tvar form = document.createElement(\"div\"),\n    \t\tid = \"script\" + (new Date()).getTime(),\n    \t\troot = document.documentElement;\n    \n    \tform.innerHTML = \"<a name='\" + id + \"'/>\";\n    \n    \t// Inject it into the root element, check its status, and remove it quickly\n    \troot.insertBefore( form, root.firstChild );\n    \n    \t// The workaround has to do additional checks after a getElementById\n    \t// Which slows things down for other browsers (hence the branching)\n    \tif ( document.getElementById( id ) ) {\n    \t\tExpr.find.ID = function( match, context, isXML ) {\n    \t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n    \t\t\t\tvar m = context.getElementById(match[1]);\n    \n    \t\t\t\treturn m ?\n    \t\t\t\t\tm.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ?\n    \t\t\t\t\t\t[m] :\n    \t\t\t\t\t\tundefined :\n    \t\t\t\t\t[];\n    \t\t\t}\n    \t\t};\n    \n    \t\tExpr.filter.ID = function( elem, match ) {\n    \t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n    \n    \t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n    \t\t};\n    \t}\n    \n    \troot.removeChild( form );\n    \n    \t// release memory in IE\n    \troot = form = null;\n    })();\n    \n    (function(){\n    \t// Check to see if the browser returns only elements\n    \t// when doing getElementsByTagName(\"*\")\n    \n    \t// Create a fake element\n    \tvar div = document.createElement(\"div\");\n    \tdiv.appendChild( document.createComment(\"\") );\n    \n    \t// Make sure no comments are found\n    \tif ( div.getElementsByTagName(\"*\").length > 0 ) {\n    \t\tExpr.find.TAG = function( match, context ) {\n    \t\t\tvar results = context.getElementsByTagName( match[1] );\n    \n    \t\t\t// Filter out possible comments\n    \t\t\tif ( match[1] === \"*\" ) {\n    \t\t\t\tvar tmp = [];\n    \n    \t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n    \t\t\t\t\tif ( results[i].nodeType === 1 ) {\n    \t\t\t\t\t\ttmp.push( results[i] );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\tresults = tmp;\n    \t\t\t}\n    \n    \t\t\treturn results;\n    \t\t};\n    \t}\n    \n    \t// Check to see if an attribute returns normalized href attributes\n    \tdiv.innerHTML = \"<a href='#'></a>\";\n    \n    \tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\n    \t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\n    \n    \t\tExpr.attrHandle.href = function( elem ) {\n    \t\t\treturn elem.getAttribute( \"href\", 2 );\n    \t\t};\n    \t}\n    \n    \t// release memory in IE\n    \tdiv = null;\n    })();\n    \n    if ( document.querySelectorAll ) {\n    \t(function(){\n    \t\tvar oldSizzle = Sizzle,\n    \t\t\tdiv = document.createElement(\"div\"),\n    \t\t\tid = \"__sizzle__\";\n    \n    \t\tdiv.innerHTML = \"<p class='TEST'></p>\";\n    \n    \t\t// Safari can't handle uppercase or unicode characters when\n    \t\t// in quirks mode.\n    \t\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\n    \t\t\treturn;\n    \t\t}\n    \t\n    \t\tSizzle = function( query, context, extra, seed ) {\n    \t\t\tcontext = context || document;\n    \n    \t\t\t// Only use querySelectorAll on non-XML documents\n    \t\t\t// (ID selectors don't work in non-HTML documents)\n    \t\t\tif ( !seed && !Sizzle.isXML(context) ) {\n    \t\t\t\t// See if we find a selector to speed up\n    \t\t\t\tvar match = /^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec( query );\n    \t\t\t\t\n    \t\t\t\tif ( match && (context.nodeType === 1 || context.nodeType === 9) ) {\n    \t\t\t\t\t// Speed-up: Sizzle(\"TAG\")\n    \t\t\t\t\tif ( match[1] ) {\n    \t\t\t\t\t\treturn makeArray( context.getElementsByTagName( query ), extra );\n    \t\t\t\t\t\n    \t\t\t\t\t// Speed-up: Sizzle(\".CLASS\")\n    \t\t\t\t\t} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {\n    \t\t\t\t\t\treturn makeArray( context.getElementsByClassName( match[2] ), extra );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif ( context.nodeType === 9 ) {\n    \t\t\t\t\t// Speed-up: Sizzle(\"body\")\n    \t\t\t\t\t// The body element only exists once, optimize finding it\n    \t\t\t\t\tif ( query === \"body\" && context.body ) {\n    \t\t\t\t\t\treturn makeArray( [ context.body ], extra );\n    \t\t\t\t\t\t\n    \t\t\t\t\t// Speed-up: Sizzle(\"#ID\")\n    \t\t\t\t\t} else if ( match && match[3] ) {\n    \t\t\t\t\t\tvar elem = context.getElementById( match[3] );\n    \n    \t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n    \t\t\t\t\t\t// nodes that are no longer in the document #6963\n    \t\t\t\t\t\tif ( elem && elem.parentNode ) {\n    \t\t\t\t\t\t\t// Handle the case where IE and Opera return items\n    \t\t\t\t\t\t\t// by name instead of ID\n    \t\t\t\t\t\t\tif ( elem.id === match[3] ) {\n    \t\t\t\t\t\t\t\treturn makeArray( [ elem ], extra );\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\treturn makeArray( [], extra );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n    \t\t\t\t\t} catch(qsaError) {}\n    \n    \t\t\t\t// qSA works strangely on Element-rooted queries\n    \t\t\t\t// We can work around this by specifying an extra ID on the root\n    \t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n    \t\t\t\t// IE 8 doesn't work on object elements\n    \t\t\t\t} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n    \t\t\t\t\tvar oldContext = context,\n    \t\t\t\t\t\told = context.getAttribute( \"id\" ),\n    \t\t\t\t\t\tnid = old || id,\n    \t\t\t\t\t\thasParent = context.parentNode,\n    \t\t\t\t\t\trelativeHierarchySelector = /^\\s*[+~]/.test( query );\n    \n    \t\t\t\t\tif ( !old ) {\n    \t\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tnid = nid.replace( /'/g, \"\\\\$&\" );\n    \t\t\t\t\t}\n    \t\t\t\t\tif ( relativeHierarchySelector && hasParent ) {\n    \t\t\t\t\t\tcontext = context.parentNode;\n    \t\t\t\t\t}\n    \n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tif ( !relativeHierarchySelector || hasParent ) {\n    \t\t\t\t\t\t\treturn makeArray( context.querySelectorAll( \"[id='\" + nid + \"'] \" + query ), extra );\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t} catch(pseudoError) {\n    \t\t\t\t\t} finally {\n    \t\t\t\t\t\tif ( !old ) {\n    \t\t\t\t\t\t\toldContext.removeAttribute( \"id\" );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\n    \t\t\treturn oldSizzle(query, context, extra, seed);\n    \t\t};\n    \n    \t\tfor ( var prop in oldSizzle ) {\n    \t\t\tSizzle[ prop ] = oldSizzle[ prop ];\n    \t\t}\n    \n    \t\t// release memory in IE\n    \t\tdiv = null;\n    \t})();\n    }\n    \n    (function(){\n    \tvar html = document.documentElement,\n    \t\tmatches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;\n    \n    \tif ( matches ) {\n    \t\t// Check to see if it's possible to do matchesSelector\n    \t\t// on a disconnected node (IE 9 fails this)\n    \t\tvar disconnectedMatch = !matches.call( document.createElement( \"div\" ), \"div\" ),\n    \t\t\tpseudoWorks = false;\n    \n    \t\ttry {\n    \t\t\t// This should fail with an exception\n    \t\t\t// Gecko does not error, returns false instead\n    \t\t\tmatches.call( document.documentElement, \"[test!='']:sizzle\" );\n    \t\n    \t\t} catch( pseudoError ) {\n    \t\t\tpseudoWorks = true;\n    \t\t}\n    \n    \t\tSizzle.matchesSelector = function( node, expr ) {\n    \t\t\t// Make sure that attribute selectors are quoted\n    \t\t\texpr = expr.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g, \"='$1']\");\n    \n    \t\t\tif ( !Sizzle.isXML( node ) ) {\n    \t\t\t\ttry { \n    \t\t\t\t\tif ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {\n    \t\t\t\t\t\tvar ret = matches.call( node, expr );\n    \n    \t\t\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n    \t\t\t\t\t\tif ( ret || !disconnectedMatch ||\n    \t\t\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n    \t\t\t\t\t\t\t\t// fragment in IE 9, so check for that\n    \t\t\t\t\t\t\t\tnode.document && node.document.nodeType !== 11 ) {\n    \t\t\t\t\t\t\treturn ret;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t} catch(e) {}\n    \t\t\t}\n    \n    \t\t\treturn Sizzle(expr, null, null, [node]).length > 0;\n    \t\t};\n    \t}\n    })();\n    \n    (function(){\n    \tvar div = document.createElement(\"div\");\n    \n    \tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\n    \n    \t// Opera can't find a second classname (in 9.6)\n    \t// Also, make sure that getElementsByClassName actually exists\n    \tif ( !div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0 ) {\n    \t\treturn;\n    \t}\n    \n    \t// Safari caches class attributes, doesn't catch changes (in 3.2)\n    \tdiv.lastChild.className = \"e\";\n    \n    \tif ( div.getElementsByClassName(\"e\").length === 1 ) {\n    \t\treturn;\n    \t}\n    \t\n    \tExpr.order.splice(1, 0, \"CLASS\");\n    \tExpr.find.CLASS = function( match, context, isXML ) {\n    \t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\n    \t\t\treturn context.getElementsByClassName(match[1]);\n    \t\t}\n    \t};\n    \n    \t// release memory in IE\n    \tdiv = null;\n    })();\n    \n    function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n    \tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n    \t\tvar elem = checkSet[i];\n    \n    \t\tif ( elem ) {\n    \t\t\tvar match = false;\n    \n    \t\t\telem = elem[dir];\n    \n    \t\t\twhile ( elem ) {\n    \t\t\t\tif ( elem[ expando ] === doneName ) {\n    \t\t\t\t\tmatch = checkSet[elem.sizset];\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \n    \t\t\t\tif ( elem.nodeType === 1 && !isXML ){\n    \t\t\t\t\telem[ expando ] = doneName;\n    \t\t\t\t\telem.sizset = i;\n    \t\t\t\t}\n    \n    \t\t\t\tif ( elem.nodeName.toLowerCase() === cur ) {\n    \t\t\t\t\tmatch = elem;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \n    \t\t\t\telem = elem[dir];\n    \t\t\t}\n    \n    \t\t\tcheckSet[i] = match;\n    \t\t}\n    \t}\n    }\n    \n    function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n    \tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n    \t\tvar elem = checkSet[i];\n    \n    \t\tif ( elem ) {\n    \t\t\tvar match = false;\n    \t\t\t\n    \t\t\telem = elem[dir];\n    \n    \t\t\twhile ( elem ) {\n    \t\t\t\tif ( elem[ expando ] === doneName ) {\n    \t\t\t\t\tmatch = checkSet[elem.sizset];\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \n    \t\t\t\tif ( elem.nodeType === 1 ) {\n    \t\t\t\t\tif ( !isXML ) {\n    \t\t\t\t\t\telem[ expando ] = doneName;\n    \t\t\t\t\t\telem.sizset = i;\n    \t\t\t\t\t}\n    \n    \t\t\t\t\tif ( typeof cur !== \"string\" ) {\n    \t\t\t\t\t\tif ( elem === cur ) {\n    \t\t\t\t\t\t\tmatch = true;\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n    \t\t\t\t\t\tmatch = elem;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\telem = elem[dir];\n    \t\t\t}\n    \n    \t\t\tcheckSet[i] = match;\n    \t\t}\n    \t}\n    }\n    \n    if ( document.documentElement.contains ) {\n    \tSizzle.contains = function( a, b ) {\n    \t\treturn a !== b && (a.contains ? a.contains(b) : true);\n    \t};\n    \n    } else if ( document.documentElement.compareDocumentPosition ) {\n    \tSizzle.contains = function( a, b ) {\n    \t\treturn !!(a.compareDocumentPosition(b) & 16);\n    \t};\n    \n    } else {\n    \tSizzle.contains = function() {\n    \t\treturn false;\n    \t};\n    }\n    \n    Sizzle.isXML = function( elem ) {\n    \t// documentElement is verified for cases where it doesn't yet exist\n    \t// (such as loading iframes in IE - #4833) \n    \tvar documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;\n    \n    \treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n    };\n    \n    var posProcess = function( selector, context, seed ) {\n    \tvar match,\n    \t\ttmpSet = [],\n    \t\tlater = \"\",\n    \t\troot = context.nodeType ? [context] : context;\n    \n    \t// Position selectors must be done after the filter\n    \t// And so must :not(positional) so we move all PSEUDOs to the end\n    \twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n    \t\tlater += match[0];\n    \t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\n    \t}\n    \n    \tselector = Expr.relative[selector] ? selector + \"*\" : selector;\n    \n    \tfor ( var i = 0, l = root.length; i < l; i++ ) {\n    \t\tSizzle( selector, root[i], tmpSet, seed );\n    \t}\n    \n    \treturn Sizzle.filter( later, tmpSet );\n    };\n    \n    // EXPOSE\n    // Override sizzle attribute retrieval\n    Sizzle.attr = jQuery.attr;\n    Sizzle.selectors.attrMap = {};\n    jQuery.find = Sizzle;\n    jQuery.expr = Sizzle.selectors;\n    jQuery.expr[\":\"] = jQuery.expr.filters;\n    jQuery.unique = Sizzle.uniqueSort;\n    jQuery.text = Sizzle.getText;\n    jQuery.isXMLDoc = Sizzle.isXML;\n    jQuery.contains = Sizzle.contains;\n    \n    \n    })();\n    \n    \n    var runtil = /Until$/,\n    \trparentsprev = /^(?:parents|prevUntil|prevAll)/,\n    \t// Note: This RegExp should be improved, or likely pulled from Sizzle\n    \trmultiselector = /,/,\n    \tisSimple = /^.[^:#\\[\\.,]*$/,\n    \tslice = Array.prototype.slice,\n    \tPOS = jQuery.expr.match.POS,\n    \t// methods guaranteed to produce a unique set when starting from a unique set\n    \tguaranteedUnique = {\n    \t\tchildren: true,\n    \t\tcontents: true,\n    \t\tnext: true,\n    \t\tprev: true\n    \t};\n    \n    jQuery.fn.extend({\n    \tfind: function( selector ) {\n    \t\tvar self = this,\n    \t\t\ti, l;\n    \n    \t\tif ( typeof selector !== \"string\" ) {\n    \t\t\treturn jQuery( selector ).filter(function() {\n    \t\t\t\tfor ( i = 0, l = self.length; i < l; i++ ) {\n    \t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n    \t\t\t\t\t\treturn true;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t});\n    \t\t}\n    \n    \t\tvar ret = this.pushStack( \"\", \"find\", selector ),\n    \t\t\tlength, n, r;\n    \n    \t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n    \t\t\tlength = ret.length;\n    \t\t\tjQuery.find( selector, this[i], ret );\n    \n    \t\t\tif ( i > 0 ) {\n    \t\t\t\t// Make sure that the results are unique\n    \t\t\t\tfor ( n = length; n < ret.length; n++ ) {\n    \t\t\t\t\tfor ( r = 0; r < length; r++ ) {\n    \t\t\t\t\t\tif ( ret[r] === ret[n] ) {\n    \t\t\t\t\t\t\tret.splice(n--, 1);\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn ret;\n    \t},\n    \n    \thas: function( target ) {\n    \t\tvar targets = jQuery( target );\n    \t\treturn this.filter(function() {\n    \t\t\tfor ( var i = 0, l = targets.length; i < l; i++ ) {\n    \t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n    \t\t\t\t\treturn true;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t});\n    \t},\n    \n    \tnot: function( selector ) {\n    \t\treturn this.pushStack( winnow(this, selector, false), \"not\", selector);\n    \t},\n    \n    \tfilter: function( selector ) {\n    \t\treturn this.pushStack( winnow(this, selector, true), \"filter\", selector );\n    \t},\n    \n    \tis: function( selector ) {\n    \t\treturn !!selector && ( \n    \t\t\ttypeof selector === \"string\" ?\n    \t\t\t\t// If this is a positional selector, check membership in the returned set\n    \t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n    \t\t\t\tPOS.test( selector ) ? \n    \t\t\t\t\tjQuery( selector, this.context ).index( this[0] ) >= 0 :\n    \t\t\t\t\tjQuery.filter( selector, this ).length > 0 :\n    \t\t\t\tthis.filter( selector ).length > 0 );\n    \t},\n    \n    \tclosest: function( selectors, context ) {\n    \t\tvar ret = [], i, l, cur = this[0];\n    \t\t\n    \t\t// Array (deprecated as of jQuery 1.7)\n    \t\tif ( jQuery.isArray( selectors ) ) {\n    \t\t\tvar level = 1;\n    \n    \t\t\twhile ( cur && cur.ownerDocument && cur !== context ) {\n    \t\t\t\tfor ( i = 0; i < selectors.length; i++ ) {\n    \n    \t\t\t\t\tif ( jQuery( cur ).is( selectors[ i ] ) ) {\n    \t\t\t\t\t\tret.push({ selector: selectors[ i ], elem: cur, level: level });\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\tcur = cur.parentNode;\n    \t\t\t\tlevel++;\n    \t\t\t}\n    \n    \t\t\treturn ret;\n    \t\t}\n    \n    \t\t// String\n    \t\tvar pos = POS.test( selectors ) || typeof selectors !== \"string\" ?\n    \t\t\t\tjQuery( selectors, context || this.context ) :\n    \t\t\t\t0;\n    \n    \t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n    \t\t\tcur = this[i];\n    \n    \t\t\twhile ( cur ) {\n    \t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {\n    \t\t\t\t\tret.push( cur );\n    \t\t\t\t\tbreak;\n    \n    \t\t\t\t} else {\n    \t\t\t\t\tcur = cur.parentNode;\n    \t\t\t\t\tif ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\tret = ret.length > 1 ? jQuery.unique( ret ) : ret;\n    \n    \t\treturn this.pushStack( ret, \"closest\", selectors );\n    \t},\n    \n    \t// Determine the position of an element within\n    \t// the matched set of elements\n    \tindex: function( elem ) {\n    \n    \t\t// No argument, return index in parent\n    \t\tif ( !elem ) {\n    \t\t\treturn ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;\n    \t\t}\n    \n    \t\t// index in selector\n    \t\tif ( typeof elem === \"string\" ) {\n    \t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n    \t\t}\n    \n    \t\t// Locate the position of the desired element\n    \t\treturn jQuery.inArray(\n    \t\t\t// If it receives a jQuery object, the first element is used\n    \t\t\telem.jquery ? elem[0] : elem, this );\n    \t},\n    \n    \tadd: function( selector, context ) {\n    \t\tvar set = typeof selector === \"string\" ?\n    \t\t\t\tjQuery( selector, context ) :\n    \t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n    \t\t\tall = jQuery.merge( this.get(), set );\n    \n    \t\treturn this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?\n    \t\t\tall :\n    \t\t\tjQuery.unique( all ) );\n    \t},\n    \n    \tandSelf: function() {\n    \t\treturn this.add( this.prevObject );\n    \t}\n    });\n    \n    // A painfully simple check to see if an element is disconnected\n    // from a document (should be improved, where feasible).\n    function isDisconnected( node ) {\n    \treturn !node || !node.parentNode || node.parentNode.nodeType === 11;\n    }\n    \n    jQuery.each({\n    \tparent: function( elem ) {\n    \t\tvar parent = elem.parentNode;\n    \t\treturn parent && parent.nodeType !== 11 ? parent : null;\n    \t},\n    \tparents: function( elem ) {\n    \t\treturn jQuery.dir( elem, \"parentNode\" );\n    \t},\n    \tparentsUntil: function( elem, i, until ) {\n    \t\treturn jQuery.dir( elem, \"parentNode\", until );\n    \t},\n    \tnext: function( elem ) {\n    \t\treturn jQuery.nth( elem, 2, \"nextSibling\" );\n    \t},\n    \tprev: function( elem ) {\n    \t\treturn jQuery.nth( elem, 2, \"previousSibling\" );\n    \t},\n    \tnextAll: function( elem ) {\n    \t\treturn jQuery.dir( elem, \"nextSibling\" );\n    \t},\n    \tprevAll: function( elem ) {\n    \t\treturn jQuery.dir( elem, \"previousSibling\" );\n    \t},\n    \tnextUntil: function( elem, i, until ) {\n    \t\treturn jQuery.dir( elem, \"nextSibling\", until );\n    \t},\n    \tprevUntil: function( elem, i, until ) {\n    \t\treturn jQuery.dir( elem, \"previousSibling\", until );\n    \t},\n    \tsiblings: function( elem ) {\n    \t\treturn jQuery.sibling( elem.parentNode.firstChild, elem );\n    \t},\n    \tchildren: function( elem ) {\n    \t\treturn jQuery.sibling( elem.firstChild );\n    \t},\n    \tcontents: function( elem ) {\n    \t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n    \t\t\telem.contentDocument || elem.contentWindow.document :\n    \t\t\tjQuery.makeArray( elem.childNodes );\n    \t}\n    }, function( name, fn ) {\n    \tjQuery.fn[ name ] = function( until, selector ) {\n    \t\tvar ret = jQuery.map( this, fn, until );\n    \n    \t\tif ( !runtil.test( name ) ) {\n    \t\t\tselector = until;\n    \t\t}\n    \n    \t\tif ( selector && typeof selector === \"string\" ) {\n    \t\t\tret = jQuery.filter( selector, ret );\n    \t\t}\n    \n    \t\tret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;\n    \n    \t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n    \t\t\tret = ret.reverse();\n    \t\t}\n    \n    \t\treturn this.pushStack( ret, name, slice.call( arguments ).join(\",\") );\n    \t};\n    });\n    \n    jQuery.extend({\n    \tfilter: function( expr, elems, not ) {\n    \t\tif ( not ) {\n    \t\t\texpr = \":not(\" + expr + \")\";\n    \t\t}\n    \n    \t\treturn elems.length === 1 ?\n    \t\t\tjQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :\n    \t\t\tjQuery.find.matches(expr, elems);\n    \t},\n    \n    \tdir: function( elem, dir, until ) {\n    \t\tvar matched = [],\n    \t\t\tcur = elem[ dir ];\n    \n    \t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n    \t\t\tif ( cur.nodeType === 1 ) {\n    \t\t\t\tmatched.push( cur );\n    \t\t\t}\n    \t\t\tcur = cur[dir];\n    \t\t}\n    \t\treturn matched;\n    \t},\n    \n    \tnth: function( cur, result, dir, elem ) {\n    \t\tresult = result || 1;\n    \t\tvar num = 0;\n    \n    \t\tfor ( ; cur; cur = cur[dir] ) {\n    \t\t\tif ( cur.nodeType === 1 && ++num === result ) {\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn cur;\n    \t},\n    \n    \tsibling: function( n, elem ) {\n    \t\tvar r = [];\n    \n    \t\tfor ( ; n; n = n.nextSibling ) {\n    \t\t\tif ( n.nodeType === 1 && n !== elem ) {\n    \t\t\t\tr.push( n );\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn r;\n    \t}\n    });\n    \n    // Implement the identical functionality for filter and not\n    function winnow( elements, qualifier, keep ) {\n    \n    \t// Can't pass null or undefined to indexOf in Firefox 4\n    \t// Set to 0 to skip string check\n    \tqualifier = qualifier || 0;\n    \n    \tif ( jQuery.isFunction( qualifier ) ) {\n    \t\treturn jQuery.grep(elements, function( elem, i ) {\n    \t\t\tvar retVal = !!qualifier.call( elem, i, elem );\n    \t\t\treturn retVal === keep;\n    \t\t});\n    \n    \t} else if ( qualifier.nodeType ) {\n    \t\treturn jQuery.grep(elements, function( elem, i ) {\n    \t\t\treturn ( elem === qualifier ) === keep;\n    \t\t});\n    \n    \t} else if ( typeof qualifier === \"string\" ) {\n    \t\tvar filtered = jQuery.grep(elements, function( elem ) {\n    \t\t\treturn elem.nodeType === 1;\n    \t\t});\n    \n    \t\tif ( isSimple.test( qualifier ) ) {\n    \t\t\treturn jQuery.filter(qualifier, filtered, !keep);\n    \t\t} else {\n    \t\t\tqualifier = jQuery.filter( qualifier, filtered );\n    \t\t}\n    \t}\n    \n    \treturn jQuery.grep(elements, function( elem, i ) {\n    \t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;\n    \t});\n    }\n    \n    \n    \n    \n    function createSafeFragment( document ) {\n    \tvar list = nodeNames.split( \"|\" ),\n    \tsafeFrag = document.createDocumentFragment();\n    \n    \tif ( safeFrag.createElement ) {\n    \t\twhile ( list.length ) {\n    \t\t\tsafeFrag.createElement(\n    \t\t\t\tlist.pop()\n    \t\t\t);\n    \t\t}\n    \t}\n    \treturn safeFrag;\n    }\n    \n    var nodeNames = \"abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|\" +\n    \t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n    \trinlinejQuery = / jQuery\\d+=\"(?:\\d+|null)\"/g,\n    \trleadingWhitespace = /^\\s+/,\n    \trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    \trtagName = /<([\\w:]+)/,\n    \trtbody = /<tbody/i,\n    \trhtml = /<|&#?\\w+;/,\n    \trnoInnerhtml = /<(?:script|style)/i,\n    \trnocache = /<(?:script|object|embed|option|style)/i,\n    \trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")\", \"i\"),\n    \t// checked=\"checked\" or checked\n    \trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n    \trscriptType = /\\/(java|ecma)script/i,\n    \trcleanScript = /^\\s*<!(?:\\[CDATA\\[|\\-\\-)/,\n    \twrapMap = {\n    \t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n    \t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n    \t\tthead: [ 1, \"<table>\", \"</table>\" ],\n    \t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n    \t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n    \t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n    \t\tarea: [ 1, \"<map>\", \"</map>\" ],\n    \t\t_default: [ 0, \"\", \"\" ]\n    \t},\n    \tsafeFragment = createSafeFragment( document );\n    \n    wrapMap.optgroup = wrapMap.option;\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n    wrapMap.th = wrapMap.td;\n    \n    // IE can't serialize <link> and <script> tags normally\n    if ( !jQuery.support.htmlSerialize ) {\n    \twrapMap._default = [ 1, \"div<div>\", \"</div>\" ];\n    }\n    \n    jQuery.fn.extend({\n    \ttext: function( text ) {\n    \t\tif ( jQuery.isFunction(text) ) {\n    \t\t\treturn this.each(function(i) {\n    \t\t\t\tvar self = jQuery( this );\n    \n    \t\t\t\tself.text( text.call(this, i, self.text()) );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( typeof text !== \"object\" && text !== undefined ) {\n    \t\t\treturn this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );\n    \t\t}\n    \n    \t\treturn jQuery.text( this );\n    \t},\n    \n    \twrapAll: function( html ) {\n    \t\tif ( jQuery.isFunction( html ) ) {\n    \t\t\treturn this.each(function(i) {\n    \t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( this[0] ) {\n    \t\t\t// The elements to wrap the target around\n    \t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n    \n    \t\t\tif ( this[0].parentNode ) {\n    \t\t\t\twrap.insertBefore( this[0] );\n    \t\t\t}\n    \n    \t\t\twrap.map(function() {\n    \t\t\t\tvar elem = this;\n    \n    \t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n    \t\t\t\t\telem = elem.firstChild;\n    \t\t\t\t}\n    \n    \t\t\t\treturn elem;\n    \t\t\t}).append( this );\n    \t\t}\n    \n    \t\treturn this;\n    \t},\n    \n    \twrapInner: function( html ) {\n    \t\tif ( jQuery.isFunction( html ) ) {\n    \t\t\treturn this.each(function(i) {\n    \t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n    \t\t\t});\n    \t\t}\n    \n    \t\treturn this.each(function() {\n    \t\t\tvar self = jQuery( this ),\n    \t\t\t\tcontents = self.contents();\n    \n    \t\t\tif ( contents.length ) {\n    \t\t\t\tcontents.wrapAll( html );\n    \n    \t\t\t} else {\n    \t\t\t\tself.append( html );\n    \t\t\t}\n    \t\t});\n    \t},\n    \n    \twrap: function( html ) {\n    \t\tvar isFunction = jQuery.isFunction( html );\n    \n    \t\treturn this.each(function(i) {\n    \t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n    \t\t});\n    \t},\n    \n    \tunwrap: function() {\n    \t\treturn this.parent().each(function() {\n    \t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n    \t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n    \t\t\t}\n    \t\t}).end();\n    \t},\n    \n    \tappend: function() {\n    \t\treturn this.domManip(arguments, true, function( elem ) {\n    \t\t\tif ( this.nodeType === 1 ) {\n    \t\t\t\tthis.appendChild( elem );\n    \t\t\t}\n    \t\t});\n    \t},\n    \n    \tprepend: function() {\n    \t\treturn this.domManip(arguments, true, function( elem ) {\n    \t\t\tif ( this.nodeType === 1 ) {\n    \t\t\t\tthis.insertBefore( elem, this.firstChild );\n    \t\t\t}\n    \t\t});\n    \t},\n    \n    \tbefore: function() {\n    \t\tif ( this[0] && this[0].parentNode ) {\n    \t\t\treturn this.domManip(arguments, false, function( elem ) {\n    \t\t\t\tthis.parentNode.insertBefore( elem, this );\n    \t\t\t});\n    \t\t} else if ( arguments.length ) {\n    \t\t\tvar set = jQuery.clean( arguments );\n    \t\t\tset.push.apply( set, this.toArray() );\n    \t\t\treturn this.pushStack( set, \"before\", arguments );\n    \t\t}\n    \t},\n    \n    \tafter: function() {\n    \t\tif ( this[0] && this[0].parentNode ) {\n    \t\t\treturn this.domManip(arguments, false, function( elem ) {\n    \t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n    \t\t\t});\n    \t\t} else if ( arguments.length ) {\n    \t\t\tvar set = this.pushStack( this, \"after\", arguments );\n    \t\t\tset.push.apply( set, jQuery.clean(arguments) );\n    \t\t\treturn set;\n    \t\t}\n    \t},\n    \n    \t// keepData is for internal use only--do not document\n    \tremove: function( selector, keepData ) {\n    \t\tfor ( var i = 0, elem; (elem = this[i]) != null; i++ ) {\n    \t\t\tif ( !selector || jQuery.filter( selector, [ elem ] ).length ) {\n    \t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n    \t\t\t\t\tjQuery.cleanData( elem.getElementsByTagName(\"*\") );\n    \t\t\t\t\tjQuery.cleanData( [ elem ] );\n    \t\t\t\t}\n    \n    \t\t\t\tif ( elem.parentNode ) {\n    \t\t\t\t\telem.parentNode.removeChild( elem );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn this;\n    \t},\n    \n    \tempty: function() {\n    \t\tfor ( var i = 0, elem; (elem = this[i]) != null; i++ ) {\n    \t\t\t// Remove element nodes and prevent memory leaks\n    \t\t\tif ( elem.nodeType === 1 ) {\n    \t\t\t\tjQuery.cleanData( elem.getElementsByTagName(\"*\") );\n    \t\t\t}\n    \n    \t\t\t// Remove any remaining nodes\n    \t\t\twhile ( elem.firstChild ) {\n    \t\t\t\telem.removeChild( elem.firstChild );\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn this;\n    \t},\n    \n    \tclone: function( dataAndEvents, deepDataAndEvents ) {\n    \t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n    \t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n    \n    \t\treturn this.map( function () {\n    \t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n    \t\t});\n    \t},\n    \n    \thtml: function( value ) {\n    \t\tif ( value === undefined ) {\n    \t\t\treturn this[0] && this[0].nodeType === 1 ?\n    \t\t\t\tthis[0].innerHTML.replace(rinlinejQuery, \"\") :\n    \t\t\t\tnull;\n    \n    \t\t// See if we can take a shortcut and just use innerHTML\n    \t\t} else if ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n    \t\t\t(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&\n    \t\t\t!wrapMap[ (rtagName.exec( value ) || [\"\", \"\"])[1].toLowerCase() ] ) {\n    \n    \t\t\tvalue = value.replace(rxhtmlTag, \"<$1></$2>\");\n    \n    \t\t\ttry {\n    \t\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n    \t\t\t\t\t// Remove element nodes and prevent memory leaks\n    \t\t\t\t\tif ( this[i].nodeType === 1 ) {\n    \t\t\t\t\t\tjQuery.cleanData( this[i].getElementsByTagName(\"*\") );\n    \t\t\t\t\t\tthis[i].innerHTML = value;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t// If using innerHTML throws an exception, use the fallback method\n    \t\t\t} catch(e) {\n    \t\t\t\tthis.empty().append( value );\n    \t\t\t}\n    \n    \t\t} else if ( jQuery.isFunction( value ) ) {\n    \t\t\tthis.each(function(i){\n    \t\t\t\tvar self = jQuery( this );\n    \n    \t\t\t\tself.html( value.call(this, i, self.html()) );\n    \t\t\t});\n    \n    \t\t} else {\n    \t\t\tthis.empty().append( value );\n    \t\t}\n    \n    \t\treturn this;\n    \t},\n    \n    \treplaceWith: function( value ) {\n    \t\tif ( this[0] && this[0].parentNode ) {\n    \t\t\t// Make sure that the elements are removed from the DOM before they are inserted\n    \t\t\t// this can help fix replacing a parent with child elements\n    \t\t\tif ( jQuery.isFunction( value ) ) {\n    \t\t\t\treturn this.each(function(i) {\n    \t\t\t\t\tvar self = jQuery(this), old = self.html();\n    \t\t\t\t\tself.replaceWith( value.call( this, i, old ) );\n    \t\t\t\t});\n    \t\t\t}\n    \n    \t\t\tif ( typeof value !== \"string\" ) {\n    \t\t\t\tvalue = jQuery( value ).detach();\n    \t\t\t}\n    \n    \t\t\treturn this.each(function() {\n    \t\t\t\tvar next = this.nextSibling,\n    \t\t\t\t\tparent = this.parentNode;\n    \n    \t\t\t\tjQuery( this ).remove();\n    \n    \t\t\t\tif ( next ) {\n    \t\t\t\t\tjQuery(next).before( value );\n    \t\t\t\t} else {\n    \t\t\t\t\tjQuery(parent).append( value );\n    \t\t\t\t}\n    \t\t\t});\n    \t\t} else {\n    \t\t\treturn this.length ?\n    \t\t\t\tthis.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), \"replaceWith\", value ) :\n    \t\t\t\tthis;\n    \t\t}\n    \t},\n    \n    \tdetach: function( selector ) {\n    \t\treturn this.remove( selector, true );\n    \t},\n    \n    \tdomManip: function( args, table, callback ) {\n    \t\tvar results, first, fragment, parent,\n    \t\t\tvalue = args[0],\n    \t\t\tscripts = [];\n    \n    \t\t// We can't cloneNode fragments that contain checked, in WebKit\n    \t\tif ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === \"string\" && rchecked.test( value ) ) {\n    \t\t\treturn this.each(function() {\n    \t\t\t\tjQuery(this).domManip( args, table, callback, true );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( jQuery.isFunction(value) ) {\n    \t\t\treturn this.each(function(i) {\n    \t\t\t\tvar self = jQuery(this);\n    \t\t\t\targs[0] = value.call(this, i, table ? self.html() : undefined);\n    \t\t\t\tself.domManip( args, table, callback );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( this[0] ) {\n    \t\t\tparent = value && value.parentNode;\n    \n    \t\t\t// If we're in a fragment, just use that instead of building a new one\n    \t\t\tif ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {\n    \t\t\t\tresults = { fragment: parent };\n    \n    \t\t\t} else {\n    \t\t\t\tresults = jQuery.buildFragment( args, this, scripts );\n    \t\t\t}\n    \n    \t\t\tfragment = results.fragment;\n    \n    \t\t\tif ( fragment.childNodes.length === 1 ) {\n    \t\t\t\tfirst = fragment = fragment.firstChild;\n    \t\t\t} else {\n    \t\t\t\tfirst = fragment.firstChild;\n    \t\t\t}\n    \n    \t\t\tif ( first ) {\n    \t\t\t\ttable = table && jQuery.nodeName( first, \"tr\" );\n    \n    \t\t\t\tfor ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {\n    \t\t\t\t\tcallback.call(\n    \t\t\t\t\t\ttable ?\n    \t\t\t\t\t\t\troot(this[i], first) :\n    \t\t\t\t\t\t\tthis[i],\n    \t\t\t\t\t\t// Make sure that we do not leak memory by inadvertently discarding\n    \t\t\t\t\t\t// the original fragment (which might have attached data) instead of\n    \t\t\t\t\t\t// using it; in addition, use the original fragment object for the last\n    \t\t\t\t\t\t// item instead of first because it can end up being emptied incorrectly\n    \t\t\t\t\t\t// in certain situations (Bug #8070).\n    \t\t\t\t\t\t// Fragments from the fragment cache must always be cloned and never used\n    \t\t\t\t\t\t// in place.\n    \t\t\t\t\t\tresults.cacheable || ( l > 1 && i < lastIndex ) ?\n    \t\t\t\t\t\t\tjQuery.clone( fragment, true, true ) :\n    \t\t\t\t\t\t\tfragment\n    \t\t\t\t\t);\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\tif ( scripts.length ) {\n    \t\t\t\tjQuery.each( scripts, evalScript );\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn this;\n    \t}\n    });\n    \n    function root( elem, cur ) {\n    \treturn jQuery.nodeName(elem, \"table\") ?\n    \t\t(elem.getElementsByTagName(\"tbody\")[0] ||\n    \t\telem.appendChild(elem.ownerDocument.createElement(\"tbody\"))) :\n    \t\telem;\n    }\n    \n    function cloneCopyEvent( src, dest ) {\n    \n    \tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n    \t\treturn;\n    \t}\n    \n    \tvar type, i, l,\n    \t\toldData = jQuery._data( src ),\n    \t\tcurData = jQuery._data( dest, oldData ),\n    \t\tevents = oldData.events;\n    \n    \tif ( events ) {\n    \t\tdelete curData.handle;\n    \t\tcurData.events = {};\n    \n    \t\tfor ( type in events ) {\n    \t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n    \t\t\t\tjQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? \".\" : \"\" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \t// make the cloned public data object a copy from the original\n    \tif ( curData.data ) {\n    \t\tcurData.data = jQuery.extend( {}, curData.data );\n    \t}\n    }\n    \n    function cloneFixAttributes( src, dest ) {\n    \tvar nodeName;\n    \n    \t// We do not need to do anything for non-Elements\n    \tif ( dest.nodeType !== 1 ) {\n    \t\treturn;\n    \t}\n    \n    \t// clearAttributes removes the attributes, which we don't want,\n    \t// but also removes the attachEvent events, which we *do* want\n    \tif ( dest.clearAttributes ) {\n    \t\tdest.clearAttributes();\n    \t}\n    \n    \t// mergeAttributes, in contrast, only merges back on the\n    \t// original attributes, not the events\n    \tif ( dest.mergeAttributes ) {\n    \t\tdest.mergeAttributes( src );\n    \t}\n    \n    \tnodeName = dest.nodeName.toLowerCase();\n    \n    \t// IE6-8 fail to clone children inside object elements that use\n    \t// the proprietary classid attribute value (rather than the type\n    \t// attribute) to identify the type of content to display\n    \tif ( nodeName === \"object\" ) {\n    \t\tdest.outerHTML = src.outerHTML;\n    \n    \t} else if ( nodeName === \"input\" && (src.type === \"checkbox\" || src.type === \"radio\") ) {\n    \t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n    \t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n    \t\t// a checked appearance if the defaultChecked value isn't also set\n    \t\tif ( src.checked ) {\n    \t\t\tdest.defaultChecked = dest.checked = src.checked;\n    \t\t}\n    \n    \t\t// IE6-7 get confused and end up setting the value of a cloned\n    \t\t// checkbox/radio button to an empty string instead of \"on\"\n    \t\tif ( dest.value !== src.value ) {\n    \t\t\tdest.value = src.value;\n    \t\t}\n    \n    \t// IE6-8 fails to return the selected option to the default selected\n    \t// state when cloning options\n    \t} else if ( nodeName === \"option\" ) {\n    \t\tdest.selected = src.defaultSelected;\n    \n    \t// IE6-8 fails to set the defaultValue to the correct value when\n    \t// cloning other types of input fields\n    \t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n    \t\tdest.defaultValue = src.defaultValue;\n    \t}\n    \n    \t// Event data gets referenced instead of copied if the expando\n    \t// gets copied too\n    \tdest.removeAttribute( jQuery.expando );\n    }\n    \n    jQuery.buildFragment = function( args, nodes, scripts ) {\n    \tvar fragment, cacheable, cacheresults, doc,\n    \tfirst = args[ 0 ];\n    \n    \t// nodes may contain either an explicit document object,\n    \t// a jQuery collection or context object.\n    \t// If nodes[0] contains a valid object to assign to doc\n    \tif ( nodes && nodes[0] ) {\n    \t\tdoc = nodes[0].ownerDocument || nodes[0];\n    \t}\n    \n    \t// Ensure that an attr object doesn't incorrectly stand in as a document object\n    \t// Chrome and Firefox seem to allow this to occur and will throw exception\n    \t// Fixes #8950\n    \tif ( !doc.createDocumentFragment ) {\n    \t\tdoc = document;\n    \t}\n    \n    \t// Only cache \"small\" (1/2 KB) HTML strings that are associated with the main document\n    \t// Cloning options loses the selected state, so don't cache them\n    \t// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment\n    \t// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache\n    \t// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501\n    \tif ( args.length === 1 && typeof first === \"string\" && first.length < 512 && doc === document &&\n    \t\tfirst.charAt(0) === \"<\" && !rnocache.test( first ) &&\n    \t\t(jQuery.support.checkClone || !rchecked.test( first )) &&\n    \t\t(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {\n    \n    \t\tcacheable = true;\n    \n    \t\tcacheresults = jQuery.fragments[ first ];\n    \t\tif ( cacheresults && cacheresults !== 1 ) {\n    \t\t\tfragment = cacheresults;\n    \t\t}\n    \t}\n    \n    \tif ( !fragment ) {\n    \t\tfragment = doc.createDocumentFragment();\n    \t\tjQuery.clean( args, doc, fragment, scripts );\n    \t}\n    \n    \tif ( cacheable ) {\n    \t\tjQuery.fragments[ first ] = cacheresults ? fragment : 1;\n    \t}\n    \n    \treturn { fragment: fragment, cacheable: cacheable };\n    };\n    \n    jQuery.fragments = {};\n    \n    jQuery.each({\n    \tappendTo: \"append\",\n    \tprependTo: \"prepend\",\n    \tinsertBefore: \"before\",\n    \tinsertAfter: \"after\",\n    \treplaceAll: \"replaceWith\"\n    }, function( name, original ) {\n    \tjQuery.fn[ name ] = function( selector ) {\n    \t\tvar ret = [],\n    \t\t\tinsert = jQuery( selector ),\n    \t\t\tparent = this.length === 1 && this[0].parentNode;\n    \n    \t\tif ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {\n    \t\t\tinsert[ original ]( this[0] );\n    \t\t\treturn this;\n    \n    \t\t} else {\n    \t\t\tfor ( var i = 0, l = insert.length; i < l; i++ ) {\n    \t\t\t\tvar elems = ( i > 0 ? this.clone(true) : this ).get();\n    \t\t\t\tjQuery( insert[i] )[ original ]( elems );\n    \t\t\t\tret = ret.concat( elems );\n    \t\t\t}\n    \n    \t\t\treturn this.pushStack( ret, name, insert.selector );\n    \t\t}\n    \t};\n    });\n    \n    function getAll( elem ) {\n    \tif ( typeof elem.getElementsByTagName !== \"undefined\" ) {\n    \t\treturn elem.getElementsByTagName( \"*\" );\n    \n    \t} else if ( typeof elem.querySelectorAll !== \"undefined\" ) {\n    \t\treturn elem.querySelectorAll( \"*\" );\n    \n    \t} else {\n    \t\treturn [];\n    \t}\n    }\n    \n    // Used in clean, fixes the defaultChecked property\n    function fixDefaultChecked( elem ) {\n    \tif ( elem.type === \"checkbox\" || elem.type === \"radio\" ) {\n    \t\telem.defaultChecked = elem.checked;\n    \t}\n    }\n    // Finds all inputs and passes them to fixDefaultChecked\n    function findInputs( elem ) {\n    \tvar nodeName = ( elem.nodeName || \"\" ).toLowerCase();\n    \tif ( nodeName === \"input\" ) {\n    \t\tfixDefaultChecked( elem );\n    \t// Skip scripts, get other children\n    \t} else if ( nodeName !== \"script\" && typeof elem.getElementsByTagName !== \"undefined\" ) {\n    \t\tjQuery.grep( elem.getElementsByTagName(\"input\"), fixDefaultChecked );\n    \t}\n    }\n    \n    // Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js\n    function shimCloneNode( elem ) {\n    \tvar div = document.createElement( \"div\" );\n    \tsafeFragment.appendChild( div );\n    \n    \tdiv.innerHTML = elem.outerHTML;\n    \treturn div.firstChild;\n    }\n    \n    jQuery.extend({\n    \tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n    \t\tvar srcElements,\n    \t\t\tdestElements,\n    \t\t\ti,\n    \t\t\t// IE<=8 does not properly clone detached, unknown element nodes\n    \t\t\tclone = jQuery.support.html5Clone || !rnoshimcache.test( \"<\" + elem.nodeName ) ?\n    \t\t\t\telem.cloneNode( true ) :\n    \t\t\t\tshimCloneNode( elem );\n    \n    \t\tif ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n    \t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n    \t\t\t// IE copies events bound via attachEvent when using cloneNode.\n    \t\t\t// Calling detachEvent on the clone will also remove the events\n    \t\t\t// from the original. In order to get around this, we use some\n    \t\t\t// proprietary methods to clear the events. Thanks to MooTools\n    \t\t\t// guys for this hotness.\n    \n    \t\t\tcloneFixAttributes( elem, clone );\n    \n    \t\t\t// Using Sizzle here is crazy slow, so we use getElementsByTagName instead\n    \t\t\tsrcElements = getAll( elem );\n    \t\t\tdestElements = getAll( clone );\n    \n    \t\t\t// Weird iteration because IE will replace the length property\n    \t\t\t// with an element if you are cloning the body and one of the\n    \t\t\t// elements on the page has a name or id of \"length\"\n    \t\t\tfor ( i = 0; srcElements[i]; ++i ) {\n    \t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n    \t\t\t\tif ( destElements[i] ) {\n    \t\t\t\t\tcloneFixAttributes( srcElements[i], destElements[i] );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Copy the events from the original to the clone\n    \t\tif ( dataAndEvents ) {\n    \t\t\tcloneCopyEvent( elem, clone );\n    \n    \t\t\tif ( deepDataAndEvents ) {\n    \t\t\t\tsrcElements = getAll( elem );\n    \t\t\t\tdestElements = getAll( clone );\n    \n    \t\t\t\tfor ( i = 0; srcElements[i]; ++i ) {\n    \t\t\t\t\tcloneCopyEvent( srcElements[i], destElements[i] );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\tsrcElements = destElements = null;\n    \n    \t\t// Return the cloned set\n    \t\treturn clone;\n    \t},\n    \n    \tclean: function( elems, context, fragment, scripts ) {\n    \t\tvar checkScriptType;\n    \n    \t\tcontext = context || document;\n    \n    \t\t// !context.createElement fails in IE with an error but returns typeof 'object'\n    \t\tif ( typeof context.createElement === \"undefined\" ) {\n    \t\t\tcontext = context.ownerDocument || context[0] && context[0].ownerDocument || document;\n    \t\t}\n    \n    \t\tvar ret = [], j;\n    \n    \t\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n    \t\t\tif ( typeof elem === \"number\" ) {\n    \t\t\t\telem += \"\";\n    \t\t\t}\n    \n    \t\t\tif ( !elem ) {\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \n    \t\t\t// Convert html string into DOM nodes\n    \t\t\tif ( typeof elem === \"string\" ) {\n    \t\t\t\tif ( !rhtml.test( elem ) ) {\n    \t\t\t\t\telem = context.createTextNode( elem );\n    \t\t\t\t} else {\n    \t\t\t\t\t// Fix \"XHTML\"-style tags in all browsers\n    \t\t\t\t\telem = elem.replace(rxhtmlTag, \"<$1></$2>\");\n    \n    \t\t\t\t\t// Trim whitespace, otherwise indexOf won't work as expected\n    \t\t\t\t\tvar tag = ( rtagName.exec( elem ) || [\"\", \"\"] )[1].toLowerCase(),\n    \t\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default,\n    \t\t\t\t\t\tdepth = wrap[0],\n    \t\t\t\t\t\tdiv = context.createElement(\"div\");\n    \n    \t\t\t\t\t// Append wrapper element to unknown element safe doc fragment\n    \t\t\t\t\tif ( context === document ) {\n    \t\t\t\t\t\t// Use the fragment we've already created for this document\n    \t\t\t\t\t\tsafeFragment.appendChild( div );\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\t// Use a fragment created with the owner document\n    \t\t\t\t\t\tcreateSafeFragment( context ).appendChild( div );\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Go to html and back, then peel off extra wrappers\n    \t\t\t\t\tdiv.innerHTML = wrap[1] + elem + wrap[2];\n    \n    \t\t\t\t\t// Move to the right depth\n    \t\t\t\t\twhile ( depth-- ) {\n    \t\t\t\t\t\tdiv = div.lastChild;\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n    \t\t\t\t\tif ( !jQuery.support.tbody ) {\n    \n    \t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n    \t\t\t\t\t\tvar hasBody = rtbody.test(elem),\n    \t\t\t\t\t\t\ttbody = tag === \"table\" && !hasBody ?\n    \t\t\t\t\t\t\t\tdiv.firstChild && div.firstChild.childNodes :\n    \n    \t\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n    \t\t\t\t\t\t\t\twrap[1] === \"<table>\" && !hasBody ?\n    \t\t\t\t\t\t\t\t\tdiv.childNodes :\n    \t\t\t\t\t\t\t\t\t[];\n    \n    \t\t\t\t\t\tfor ( j = tbody.length - 1; j >= 0 ; --j ) {\n    \t\t\t\t\t\t\tif ( jQuery.nodeName( tbody[ j ], \"tbody\" ) && !tbody[ j ].childNodes.length ) {\n    \t\t\t\t\t\t\t\ttbody[ j ].parentNode.removeChild( tbody[ j ] );\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// IE completely kills leading whitespace when innerHTML is used\n    \t\t\t\t\tif ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n    \t\t\t\t\t\tdiv.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );\n    \t\t\t\t\t}\n    \n    \t\t\t\t\telem = div.childNodes;\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// Resets defaultChecked for any radios and checkboxes\n    \t\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n    \t\t\tvar len;\n    \t\t\tif ( !jQuery.support.appendChecked ) {\n    \t\t\t\tif ( elem[0] && typeof (len = elem.length) === \"number\" ) {\n    \t\t\t\t\tfor ( j = 0; j < len; j++ ) {\n    \t\t\t\t\t\tfindInputs( elem[j] );\n    \t\t\t\t\t}\n    \t\t\t\t} else {\n    \t\t\t\t\tfindInputs( elem );\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\tif ( elem.nodeType ) {\n    \t\t\t\tret.push( elem );\n    \t\t\t} else {\n    \t\t\t\tret = jQuery.merge( ret, elem );\n    \t\t\t}\n    \t\t}\n    \n    \t\tif ( fragment ) {\n    \t\t\tcheckScriptType = function( elem ) {\n    \t\t\t\treturn !elem.type || rscriptType.test( elem.type );\n    \t\t\t};\n    \t\t\tfor ( i = 0; ret[i]; i++ ) {\n    \t\t\t\tif ( scripts && jQuery.nodeName( ret[i], \"script\" ) && (!ret[i].type || ret[i].type.toLowerCase() === \"text/javascript\") ) {\n    \t\t\t\t\tscripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );\n    \n    \t\t\t\t} else {\n    \t\t\t\t\tif ( ret[i].nodeType === 1 ) {\n    \t\t\t\t\t\tvar jsTags = jQuery.grep( ret[i].getElementsByTagName( \"script\" ), checkScriptType );\n    \n    \t\t\t\t\t\tret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );\n    \t\t\t\t\t}\n    \t\t\t\t\tfragment.appendChild( ret[i] );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn ret;\n    \t},\n    \n    \tcleanData: function( elems ) {\n    \t\tvar data, id,\n    \t\t\tcache = jQuery.cache,\n    \t\t\tspecial = jQuery.event.special,\n    \t\t\tdeleteExpando = jQuery.support.deleteExpando;\n    \n    \t\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n    \t\t\tif ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \n    \t\t\tid = elem[ jQuery.expando ];\n    \n    \t\t\tif ( id ) {\n    \t\t\t\tdata = cache[ id ];\n    \n    \t\t\t\tif ( data && data.events ) {\n    \t\t\t\t\tfor ( var type in data.events ) {\n    \t\t\t\t\t\tif ( special[ type ] ) {\n    \t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n    \n    \t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Null the DOM reference to avoid IE6/7/8 leak (#7054)\n    \t\t\t\t\tif ( data.handle ) {\n    \t\t\t\t\t\tdata.handle.elem = null;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\tif ( deleteExpando ) {\n    \t\t\t\t\tdelete elem[ jQuery.expando ];\n    \n    \t\t\t\t} else if ( elem.removeAttribute ) {\n    \t\t\t\t\telem.removeAttribute( jQuery.expando );\n    \t\t\t\t}\n    \n    \t\t\t\tdelete cache[ id ];\n    \t\t\t}\n    \t\t}\n    \t}\n    });\n    \n    function evalScript( i, elem ) {\n    \tif ( elem.src ) {\n    \t\tjQuery.ajax({\n    \t\t\turl: elem.src,\n    \t\t\tasync: false,\n    \t\t\tdataType: \"script\"\n    \t\t});\n    \t} else {\n    \t\tjQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || \"\" ).replace( rcleanScript, \"/*$0*/\" ) );\n    \t}\n    \n    \tif ( elem.parentNode ) {\n    \t\telem.parentNode.removeChild( elem );\n    \t}\n    }\n    \n    \n    \n    \n    var ralpha = /alpha\\([^)]*\\)/i,\n    \tropacity = /opacity=([^)]*)/,\n    \t// fixed for IE9, see #8346\n    \trupper = /([A-Z]|^ms)/g,\n    \trnumpx = /^-?\\d+(?:px)?$/i,\n    \trnum = /^-?\\d/,\n    \trrelNum = /^([\\-+])=([\\-+.\\de]+)/,\n    \n    \tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n    \tcssWidth = [ \"Left\", \"Right\" ],\n    \tcssHeight = [ \"Top\", \"Bottom\" ],\n    \tcurCSS,\n    \n    \tgetComputedStyle,\n    \tcurrentStyle;\n    \n    jQuery.fn.css = function( name, value ) {\n    \t// Setting 'undefined' is a no-op\n    \tif ( arguments.length === 2 && value === undefined ) {\n    \t\treturn this;\n    \t}\n    \n    \treturn jQuery.access( this, name, value, true, function( elem, name, value ) {\n    \t\treturn value !== undefined ?\n    \t\t\tjQuery.style( elem, name, value ) :\n    \t\t\tjQuery.css( elem, name );\n    \t});\n    };\n    \n    jQuery.extend({\n    \t// Add in style property hooks for overriding the default\n    \t// behavior of getting and setting a style property\n    \tcssHooks: {\n    \t\topacity: {\n    \t\t\tget: function( elem, computed ) {\n    \t\t\t\tif ( computed ) {\n    \t\t\t\t\t// We should always get a number back from opacity\n    \t\t\t\t\tvar ret = curCSS( elem, \"opacity\", \"opacity\" );\n    \t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n    \n    \t\t\t\t} else {\n    \t\t\t\t\treturn elem.style.opacity;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t},\n    \n    \t// Exclude the following css properties to add px\n    \tcssNumber: {\n    \t\t\"fillOpacity\": true,\n    \t\t\"fontWeight\": true,\n    \t\t\"lineHeight\": true,\n    \t\t\"opacity\": true,\n    \t\t\"orphans\": true,\n    \t\t\"widows\": true,\n    \t\t\"zIndex\": true,\n    \t\t\"zoom\": true\n    \t},\n    \n    \t// Add in properties whose names you wish to fix before\n    \t// setting or getting the value\n    \tcssProps: {\n    \t\t// normalize float css property\n    \t\t\"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n    \t},\n    \n    \t// Get and set the style property on a DOM Node\n    \tstyle: function( elem, name, value, extra ) {\n    \t\t// Don't set styles on text and comment nodes\n    \t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n    \t\t\treturn;\n    \t\t}\n    \n    \t\t// Make sure that we're working with the right name\n    \t\tvar ret, type, origName = jQuery.camelCase( name ),\n    \t\t\tstyle = elem.style, hooks = jQuery.cssHooks[ origName ];\n    \n    \t\tname = jQuery.cssProps[ origName ] || origName;\n    \n    \t\t// Check if we're setting a value\n    \t\tif ( value !== undefined ) {\n    \t\t\ttype = typeof value;\n    \n    \t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n    \t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n    \t\t\t\tvalue = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );\n    \t\t\t\t// Fixes bug #9237\n    \t\t\t\ttype = \"number\";\n    \t\t\t}\n    \n    \t\t\t// Make sure that NaN and null values aren't set. See: #7116\n    \t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n    \t\t\t\treturn;\n    \t\t\t}\n    \n    \t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n    \t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n    \t\t\t\tvalue += \"px\";\n    \t\t\t}\n    \n    \t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n    \t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {\n    \t\t\t\t// Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n    \t\t\t\t// Fixes bug #5509\n    \t\t\t\ttry {\n    \t\t\t\t\tstyle[ name ] = value;\n    \t\t\t\t} catch(e) {}\n    \t\t\t}\n    \n    \t\t} else {\n    \t\t\t// If a hook was provided get the non-computed value from there\n    \t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n    \t\t\t\treturn ret;\n    \t\t\t}\n    \n    \t\t\t// Otherwise just get the value from the style object\n    \t\t\treturn style[ name ];\n    \t\t}\n    \t},\n    \n    \tcss: function( elem, name, extra ) {\n    \t\tvar ret, hooks;\n    \n    \t\t// Make sure that we're working with the right name\n    \t\tname = jQuery.camelCase( name );\n    \t\thooks = jQuery.cssHooks[ name ];\n    \t\tname = jQuery.cssProps[ name ] || name;\n    \n    \t\t// cssFloat needs a special treatment\n    \t\tif ( name === \"cssFloat\" ) {\n    \t\t\tname = \"float\";\n    \t\t}\n    \n    \t\t// If a hook was provided get the computed value from there\n    \t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {\n    \t\t\treturn ret;\n    \n    \t\t// Otherwise, if a way to get the computed value exists, use that\n    \t\t} else if ( curCSS ) {\n    \t\t\treturn curCSS( elem, name );\n    \t\t}\n    \t},\n    \n    \t// A method for quickly swapping in/out CSS properties to get correct calculations\n    \tswap: function( elem, options, callback ) {\n    \t\tvar old = {};\n    \n    \t\t// Remember the old values, and insert the new ones\n    \t\tfor ( var name in options ) {\n    \t\t\told[ name ] = elem.style[ name ];\n    \t\t\telem.style[ name ] = options[ name ];\n    \t\t}\n    \n    \t\tcallback.call( elem );\n    \n    \t\t// Revert the old values\n    \t\tfor ( name in options ) {\n    \t\t\telem.style[ name ] = old[ name ];\n    \t\t}\n    \t}\n    });\n    \n    // DEPRECATED, Use jQuery.css() instead\n    jQuery.curCSS = jQuery.css;\n    \n    jQuery.each([\"height\", \"width\"], function( i, name ) {\n    \tjQuery.cssHooks[ name ] = {\n    \t\tget: function( elem, computed, extra ) {\n    \t\t\tvar val;\n    \n    \t\t\tif ( computed ) {\n    \t\t\t\tif ( elem.offsetWidth !== 0 ) {\n    \t\t\t\t\treturn getWH( elem, name, extra );\n    \t\t\t\t} else {\n    \t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n    \t\t\t\t\t\tval = getWH( elem, name, extra );\n    \t\t\t\t\t});\n    \t\t\t\t}\n    \n    \t\t\t\treturn val;\n    \t\t\t}\n    \t\t},\n    \n    \t\tset: function( elem, value ) {\n    \t\t\tif ( rnumpx.test( value ) ) {\n    \t\t\t\t// ignore negative width and height values #1599\n    \t\t\t\tvalue = parseFloat( value );\n    \n    \t\t\t\tif ( value >= 0 ) {\n    \t\t\t\t\treturn value + \"px\";\n    \t\t\t\t}\n    \n    \t\t\t} else {\n    \t\t\t\treturn value;\n    \t\t\t}\n    \t\t}\n    \t};\n    });\n    \n    if ( !jQuery.support.opacity ) {\n    \tjQuery.cssHooks.opacity = {\n    \t\tget: function( elem, computed ) {\n    \t\t\t// IE uses filters for opacity\n    \t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n    \t\t\t\t( parseFloat( RegExp.$1 ) / 100 ) + \"\" :\n    \t\t\t\tcomputed ? \"1\" : \"\";\n    \t\t},\n    \n    \t\tset: function( elem, value ) {\n    \t\t\tvar style = elem.style,\n    \t\t\t\tcurrentStyle = elem.currentStyle,\n    \t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n    \t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n    \n    \t\t\t// IE has trouble with opacity if it does not have layout\n    \t\t\t// Force it by setting the zoom level\n    \t\t\tstyle.zoom = 1;\n    \n    \t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n    \t\t\tif ( value >= 1 && jQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" ) {\n    \n    \t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n    \t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n    \t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n    \t\t\t\tstyle.removeAttribute( \"filter\" );\n    \n    \t\t\t\t// if there there is no filter style applied in a css rule, we are done\n    \t\t\t\tif ( currentStyle && !currentStyle.filter ) {\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// otherwise, set new filter values\n    \t\t\tstyle.filter = ralpha.test( filter ) ?\n    \t\t\t\tfilter.replace( ralpha, opacity ) :\n    \t\t\t\tfilter + \" \" + opacity;\n    \t\t}\n    \t};\n    }\n    \n    jQuery(function() {\n    \t// This hook cannot be added until DOM ready because the support test\n    \t// for it is not run until after DOM ready\n    \tif ( !jQuery.support.reliableMarginRight ) {\n    \t\tjQuery.cssHooks.marginRight = {\n    \t\t\tget: function( elem, computed ) {\n    \t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n    \t\t\t\t// Work around by temporarily setting element display to inline-block\n    \t\t\t\tvar ret;\n    \t\t\t\tjQuery.swap( elem, { \"display\": \"inline-block\" }, function() {\n    \t\t\t\t\tif ( computed ) {\n    \t\t\t\t\t\tret = curCSS( elem, \"margin-right\", \"marginRight\" );\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tret = elem.style.marginRight;\n    \t\t\t\t\t}\n    \t\t\t\t});\n    \t\t\t\treturn ret;\n    \t\t\t}\n    \t\t};\n    \t}\n    });\n    \n    if ( document.defaultView && document.defaultView.getComputedStyle ) {\n    \tgetComputedStyle = function( elem, name ) {\n    \t\tvar ret, defaultView, computedStyle;\n    \n    \t\tname = name.replace( rupper, \"-$1\" ).toLowerCase();\n    \n    \t\tif ( (defaultView = elem.ownerDocument.defaultView) &&\n    \t\t\t\t(computedStyle = defaultView.getComputedStyle( elem, null )) ) {\n    \t\t\tret = computedStyle.getPropertyValue( name );\n    \t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {\n    \t\t\t\tret = jQuery.style( elem, name );\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn ret;\n    \t};\n    }\n    \n    if ( document.documentElement.currentStyle ) {\n    \tcurrentStyle = function( elem, name ) {\n    \t\tvar left, rsLeft, uncomputed,\n    \t\t\tret = elem.currentStyle && elem.currentStyle[ name ],\n    \t\t\tstyle = elem.style;\n    \n    \t\t// Avoid setting ret to empty string here\n    \t\t// so we don't default to auto\n    \t\tif ( ret === null && style && (uncomputed = style[ name ]) ) {\n    \t\t\tret = uncomputed;\n    \t\t}\n    \n    \t\t// From the awesome hack by Dean Edwards\n    \t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n    \n    \t\t// If we're not dealing with a regular pixel number\n    \t\t// but a number that has a weird ending, we need to convert it to pixels\n    \t\tif ( !rnumpx.test( ret ) && rnum.test( ret ) ) {\n    \n    \t\t\t// Remember the original values\n    \t\t\tleft = style.left;\n    \t\t\trsLeft = elem.runtimeStyle && elem.runtimeStyle.left;\n    \n    \t\t\t// Put in the new values to get a computed value out\n    \t\t\tif ( rsLeft ) {\n    \t\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n    \t\t\t}\n    \t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ( ret || 0 );\n    \t\t\tret = style.pixelLeft + \"px\";\n    \n    \t\t\t// Revert the changed values\n    \t\t\tstyle.left = left;\n    \t\t\tif ( rsLeft ) {\n    \t\t\t\telem.runtimeStyle.left = rsLeft;\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn ret === \"\" ? \"auto\" : ret;\n    \t};\n    }\n    \n    curCSS = getComputedStyle || currentStyle;\n    \n    function getWH( elem, name, extra ) {\n    \n    \t// Start with offset property\n    \tvar val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n    \t\twhich = name === \"width\" ? cssWidth : cssHeight,\n    \t\ti = 0,\n    \t\tlen = which.length;\n    \n    \tif ( val > 0 ) {\n    \t\tif ( extra !== \"border\" ) {\n    \t\t\tfor ( ; i < len; i++ ) {\n    \t\t\t\tif ( !extra ) {\n    \t\t\t\t\tval -= parseFloat( jQuery.css( elem, \"padding\" + which[ i ] ) ) || 0;\n    \t\t\t\t}\n    \t\t\t\tif ( extra === \"margin\" ) {\n    \t\t\t\t\tval += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;\n    \t\t\t\t} else {\n    \t\t\t\t\tval -= parseFloat( jQuery.css( elem, \"border\" + which[ i ] + \"Width\" ) ) || 0;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn val + \"px\";\n    \t}\n    \n    \t// Fall back to computed then uncomputed css if necessary\n    \tval = curCSS( elem, name, name );\n    \tif ( val < 0 || val == null ) {\n    \t\tval = elem.style[ name ] || 0;\n    \t}\n    \t// Normalize \"\", auto, and prepare for extra\n    \tval = parseFloat( val ) || 0;\n    \n    \t// Add padding, border, margin\n    \tif ( extra ) {\n    \t\tfor ( ; i < len; i++ ) {\n    \t\t\tval += parseFloat( jQuery.css( elem, \"padding\" + which[ i ] ) ) || 0;\n    \t\t\tif ( extra !== \"padding\" ) {\n    \t\t\t\tval += parseFloat( jQuery.css( elem, \"border\" + which[ i ] + \"Width\" ) ) || 0;\n    \t\t\t}\n    \t\t\tif ( extra === \"margin\" ) {\n    \t\t\t\tval += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \treturn val + \"px\";\n    }\n    \n    if ( jQuery.expr && jQuery.expr.filters ) {\n    \tjQuery.expr.filters.hidden = function( elem ) {\n    \t\tvar width = elem.offsetWidth,\n    \t\t\theight = elem.offsetHeight;\n    \n    \t\treturn ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n    \t};\n    \n    \tjQuery.expr.filters.visible = function( elem ) {\n    \t\treturn !jQuery.expr.filters.hidden( elem );\n    \t};\n    }\n    \n    \n    \n    \n    var r20 = /%20/g,\n    \trbracket = /\\[\\]$/,\n    \trCRLF = /\\r?\\n/g,\n    \trhash = /#.*$/,\n    \trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n    \trinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,\n    \t// #7653, #8125, #8152: local protocol detection\n    \trlocalProtocol = /^(?:about|app|app\\-storage|.+\\-extension|file|res|widget):$/,\n    \trnoContent = /^(?:GET|HEAD)$/,\n    \trprotocol = /^\\/\\//,\n    \trquery = /\\?/,\n    \trscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n    \trselectTextarea = /^(?:select|textarea)/i,\n    \trspacesAjax = /\\s+/,\n    \trts = /([?&])_=[^&]*/,\n    \trurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/,\n    \n    \t// Keep a copy of the old load method\n    \t_load = jQuery.fn.load,\n    \n    \t/* Prefilters\n    \t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n    \t * 2) These are called:\n    \t *    - BEFORE asking for a transport\n    \t *    - AFTER param serialization (s.data is a string if s.processData is true)\n    \t * 3) key is the dataType\n    \t * 4) the catchall symbol \"*\" can be used\n    \t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n    \t */\n    \tprefilters = {},\n    \n    \t/* Transports bindings\n    \t * 1) key is the dataType\n    \t * 2) the catchall symbol \"*\" can be used\n    \t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n    \t */\n    \ttransports = {},\n    \n    \t// Document location\n    \tajaxLocation,\n    \n    \t// Document location segments\n    \tajaxLocParts,\n    \n    \t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n    \tallTypes = [\"*/\"] + [\"*\"];\n    \n    // #8138, IE may throw an exception when accessing\n    // a field from window.location if document.domain has been set\n    try {\n    \tajaxLocation = location.href;\n    } catch( e ) {\n    \t// Use the href attribute of an A element\n    \t// since IE will modify it given document.location\n    \tajaxLocation = document.createElement( \"a\" );\n    \tajaxLocation.href = \"\";\n    \tajaxLocation = ajaxLocation.href;\n    }\n    \n    // Segment location into parts\n    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n    \n    // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n    function addToPrefiltersOrTransports( structure ) {\n    \n    \t// dataTypeExpression is optional and defaults to \"*\"\n    \treturn function( dataTypeExpression, func ) {\n    \n    \t\tif ( typeof dataTypeExpression !== \"string\" ) {\n    \t\t\tfunc = dataTypeExpression;\n    \t\t\tdataTypeExpression = \"*\";\n    \t\t}\n    \n    \t\tif ( jQuery.isFunction( func ) ) {\n    \t\t\tvar dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),\n    \t\t\t\ti = 0,\n    \t\t\t\tlength = dataTypes.length,\n    \t\t\t\tdataType,\n    \t\t\t\tlist,\n    \t\t\t\tplaceBefore;\n    \n    \t\t\t// For each dataType in the dataTypeExpression\n    \t\t\tfor ( ; i < length; i++ ) {\n    \t\t\t\tdataType = dataTypes[ i ];\n    \t\t\t\t// We control if we're asked to add before\n    \t\t\t\t// any existing element\n    \t\t\t\tplaceBefore = /^\\+/.test( dataType );\n    \t\t\t\tif ( placeBefore ) {\n    \t\t\t\t\tdataType = dataType.substr( 1 ) || \"*\";\n    \t\t\t\t}\n    \t\t\t\tlist = structure[ dataType ] = structure[ dataType ] || [];\n    \t\t\t\t// then we add to the structure accordingly\n    \t\t\t\tlist[ placeBefore ? \"unshift\" : \"push\" ]( func );\n    \t\t\t}\n    \t\t}\n    \t};\n    }\n    \n    // Base inspection function for prefilters and transports\n    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,\n    \t\tdataType /* internal */, inspected /* internal */ ) {\n    \n    \tdataType = dataType || options.dataTypes[ 0 ];\n    \tinspected = inspected || {};\n    \n    \tinspected[ dataType ] = true;\n    \n    \tvar list = structure[ dataType ],\n    \t\ti = 0,\n    \t\tlength = list ? list.length : 0,\n    \t\texecuteOnly = ( structure === prefilters ),\n    \t\tselection;\n    \n    \tfor ( ; i < length && ( executeOnly || !selection ); i++ ) {\n    \t\tselection = list[ i ]( options, originalOptions, jqXHR );\n    \t\t// If we got redirected to another dataType\n    \t\t// we try there if executing only and not done already\n    \t\tif ( typeof selection === \"string\" ) {\n    \t\t\tif ( !executeOnly || inspected[ selection ] ) {\n    \t\t\t\tselection = undefined;\n    \t\t\t} else {\n    \t\t\t\toptions.dataTypes.unshift( selection );\n    \t\t\t\tselection = inspectPrefiltersOrTransports(\n    \t\t\t\t\t\tstructure, options, originalOptions, jqXHR, selection, inspected );\n    \t\t\t}\n    \t\t}\n    \t}\n    \t// If we're only executing or nothing was selected\n    \t// we try the catchall dataType if not done already\n    \tif ( ( executeOnly || !selection ) && !inspected[ \"*\" ] ) {\n    \t\tselection = inspectPrefiltersOrTransports(\n    \t\t\t\tstructure, options, originalOptions, jqXHR, \"*\", inspected );\n    \t}\n    \t// unnecessary when only executing (prefilters)\n    \t// but it'll be ignored by the caller in that case\n    \treturn selection;\n    }\n    \n    // A special extend for ajax options\n    // that takes \"flat\" options (not to be deep extended)\n    // Fixes #9887\n    function ajaxExtend( target, src ) {\n    \tvar key, deep,\n    \t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n    \tfor ( key in src ) {\n    \t\tif ( src[ key ] !== undefined ) {\n    \t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n    \t\t}\n    \t}\n    \tif ( deep ) {\n    \t\tjQuery.extend( true, target, deep );\n    \t}\n    }\n    \n    jQuery.fn.extend({\n    \tload: function( url, params, callback ) {\n    \t\tif ( typeof url !== \"string\" && _load ) {\n    \t\t\treturn _load.apply( this, arguments );\n    \n    \t\t// Don't do a request if no elements are being requested\n    \t\t} else if ( !this.length ) {\n    \t\t\treturn this;\n    \t\t}\n    \n    \t\tvar off = url.indexOf( \" \" );\n    \t\tif ( off >= 0 ) {\n    \t\t\tvar selector = url.slice( off, url.length );\n    \t\t\turl = url.slice( 0, off );\n    \t\t}\n    \n    \t\t// Default to a GET request\n    \t\tvar type = \"GET\";\n    \n    \t\t// If the second parameter was provided\n    \t\tif ( params ) {\n    \t\t\t// If it's a function\n    \t\t\tif ( jQuery.isFunction( params ) ) {\n    \t\t\t\t// We assume that it's the callback\n    \t\t\t\tcallback = params;\n    \t\t\t\tparams = undefined;\n    \n    \t\t\t// Otherwise, build a param string\n    \t\t\t} else if ( typeof params === \"object\" ) {\n    \t\t\t\tparams = jQuery.param( params, jQuery.ajaxSettings.traditional );\n    \t\t\t\ttype = \"POST\";\n    \t\t\t}\n    \t\t}\n    \n    \t\tvar self = this;\n    \n    \t\t// Request the remote document\n    \t\tjQuery.ajax({\n    \t\t\turl: url,\n    \t\t\ttype: type,\n    \t\t\tdataType: \"html\",\n    \t\t\tdata: params,\n    \t\t\t// Complete callback (responseText is used internally)\n    \t\t\tcomplete: function( jqXHR, status, responseText ) {\n    \t\t\t\t// Store the response as specified by the jqXHR object\n    \t\t\t\tresponseText = jqXHR.responseText;\n    \t\t\t\t// If successful, inject the HTML into all the matched elements\n    \t\t\t\tif ( jqXHR.isResolved() ) {\n    \t\t\t\t\t// #4825: Get the actual response in case\n    \t\t\t\t\t// a dataFilter is present in ajaxSettings\n    \t\t\t\t\tjqXHR.done(function( r ) {\n    \t\t\t\t\t\tresponseText = r;\n    \t\t\t\t\t});\n    \t\t\t\t\t// See if a selector was specified\n    \t\t\t\t\tself.html( selector ?\n    \t\t\t\t\t\t// Create a dummy div to hold the results\n    \t\t\t\t\t\tjQuery(\"<div>\")\n    \t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n    \t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n    \t\t\t\t\t\t\t.append(responseText.replace(rscript, \"\"))\n    \n    \t\t\t\t\t\t\t// Locate the specified elements\n    \t\t\t\t\t\t\t.find(selector) :\n    \n    \t\t\t\t\t\t// If not, just inject the full result\n    \t\t\t\t\t\tresponseText );\n    \t\t\t\t}\n    \n    \t\t\t\tif ( callback ) {\n    \t\t\t\t\tself.each( callback, [ responseText, status, jqXHR ] );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t});\n    \n    \t\treturn this;\n    \t},\n    \n    \tserialize: function() {\n    \t\treturn jQuery.param( this.serializeArray() );\n    \t},\n    \n    \tserializeArray: function() {\n    \t\treturn this.map(function(){\n    \t\t\treturn this.elements ? jQuery.makeArray( this.elements ) : this;\n    \t\t})\n    \t\t.filter(function(){\n    \t\t\treturn this.name && !this.disabled &&\n    \t\t\t\t( this.checked || rselectTextarea.test( this.nodeName ) ||\n    \t\t\t\t\trinput.test( this.type ) );\n    \t\t})\n    \t\t.map(function( i, elem ){\n    \t\t\tvar val = jQuery( this ).val();\n    \n    \t\t\treturn val == null ?\n    \t\t\t\tnull :\n    \t\t\t\tjQuery.isArray( val ) ?\n    \t\t\t\t\tjQuery.map( val, function( val, i ){\n    \t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n    \t\t\t\t\t}) :\n    \t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n    \t\t}).get();\n    \t}\n    });\n    \n    // Attach a bunch of functions for handling common AJAX events\n    jQuery.each( \"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split( \" \" ), function( i, o ){\n    \tjQuery.fn[ o ] = function( f ){\n    \t\treturn this.on( o, f );\n    \t};\n    });\n    \n    jQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n    \tjQuery[ method ] = function( url, data, callback, type ) {\n    \t\t// shift arguments if data argument was omitted\n    \t\tif ( jQuery.isFunction( data ) ) {\n    \t\t\ttype = type || callback;\n    \t\t\tcallback = data;\n    \t\t\tdata = undefined;\n    \t\t}\n    \n    \t\treturn jQuery.ajax({\n    \t\t\ttype: method,\n    \t\t\turl: url,\n    \t\t\tdata: data,\n    \t\t\tsuccess: callback,\n    \t\t\tdataType: type\n    \t\t});\n    \t};\n    });\n    \n    jQuery.extend({\n    \n    \tgetScript: function( url, callback ) {\n    \t\treturn jQuery.get( url, undefined, callback, \"script\" );\n    \t},\n    \n    \tgetJSON: function( url, data, callback ) {\n    \t\treturn jQuery.get( url, data, callback, \"json\" );\n    \t},\n    \n    \t// Creates a full fledged settings object into target\n    \t// with both ajaxSettings and settings fields.\n    \t// If target is omitted, writes into ajaxSettings.\n    \tajaxSetup: function( target, settings ) {\n    \t\tif ( settings ) {\n    \t\t\t// Building a settings object\n    \t\t\tajaxExtend( target, jQuery.ajaxSettings );\n    \t\t} else {\n    \t\t\t// Extending ajaxSettings\n    \t\t\tsettings = target;\n    \t\t\ttarget = jQuery.ajaxSettings;\n    \t\t}\n    \t\tajaxExtend( target, settings );\n    \t\treturn target;\n    \t},\n    \n    \tajaxSettings: {\n    \t\turl: ajaxLocation,\n    \t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n    \t\tglobal: true,\n    \t\ttype: \"GET\",\n    \t\tcontentType: \"application/x-www-form-urlencoded\",\n    \t\tprocessData: true,\n    \t\tasync: true,\n    \t\t/*\n    \t\ttimeout: 0,\n    \t\tdata: null,\n    \t\tdataType: null,\n    \t\tusername: null,\n    \t\tpassword: null,\n    \t\tcache: null,\n    \t\ttraditional: false,\n    \t\theaders: {},\n    \t\t*/\n    \n    \t\taccepts: {\n    \t\t\txml: \"application/xml, text/xml\",\n    \t\t\thtml: \"text/html\",\n    \t\t\ttext: \"text/plain\",\n    \t\t\tjson: \"application/json, text/javascript\",\n    \t\t\t\"*\": allTypes\n    \t\t},\n    \n    \t\tcontents: {\n    \t\t\txml: /xml/,\n    \t\t\thtml: /html/,\n    \t\t\tjson: /json/\n    \t\t},\n    \n    \t\tresponseFields: {\n    \t\t\txml: \"responseXML\",\n    \t\t\ttext: \"responseText\"\n    \t\t},\n    \n    \t\t// List of data converters\n    \t\t// 1) key format is \"source_type destination_type\" (a single space in-between)\n    \t\t// 2) the catchall symbol \"*\" can be used for source_type\n    \t\tconverters: {\n    \n    \t\t\t// Convert anything to text\n    \t\t\t\"* text\": window.String,\n    \n    \t\t\t// Text to html (true = no transformation)\n    \t\t\t\"text html\": true,\n    \n    \t\t\t// Evaluate text as a json expression\n    \t\t\t\"text json\": jQuery.parseJSON,\n    \n    \t\t\t// Parse text as xml\n    \t\t\t\"text xml\": jQuery.parseXML\n    \t\t},\n    \n    \t\t// For options that shouldn't be deep extended:\n    \t\t// you can add your own custom options here if\n    \t\t// and when you create one that shouldn't be\n    \t\t// deep extended (see ajaxExtend)\n    \t\tflatOptions: {\n    \t\t\tcontext: true,\n    \t\t\turl: true\n    \t\t}\n    \t},\n    \n    \tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n    \tajaxTransport: addToPrefiltersOrTransports( transports ),\n    \n    \t// Main method\n    \tajax: function( url, options ) {\n    \n    \t\t// If url is an object, simulate pre-1.5 signature\n    \t\tif ( typeof url === \"object\" ) {\n    \t\t\toptions = url;\n    \t\t\turl = undefined;\n    \t\t}\n    \n    \t\t// Force options to be an object\n    \t\toptions = options || {};\n    \n    \t\tvar // Create the final options object\n    \t\t\ts = jQuery.ajaxSetup( {}, options ),\n    \t\t\t// Callbacks context\n    \t\t\tcallbackContext = s.context || s,\n    \t\t\t// Context for global events\n    \t\t\t// It's the callbackContext if one was provided in the options\n    \t\t\t// and if it's a DOM node or a jQuery collection\n    \t\t\tglobalEventContext = callbackContext !== s &&\n    \t\t\t\t( callbackContext.nodeType || callbackContext instanceof jQuery ) ?\n    \t\t\t\t\t\tjQuery( callbackContext ) : jQuery.event,\n    \t\t\t// Deferreds\n    \t\t\tdeferred = jQuery.Deferred(),\n    \t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n    \t\t\t// Status-dependent callbacks\n    \t\t\tstatusCode = s.statusCode || {},\n    \t\t\t// ifModified key\n    \t\t\tifModifiedKey,\n    \t\t\t// Headers (they are sent all at once)\n    \t\t\trequestHeaders = {},\n    \t\t\trequestHeadersNames = {},\n    \t\t\t// Response headers\n    \t\t\tresponseHeadersString,\n    \t\t\tresponseHeaders,\n    \t\t\t// transport\n    \t\t\ttransport,\n    \t\t\t// timeout handle\n    \t\t\ttimeoutTimer,\n    \t\t\t// Cross-domain detection vars\n    \t\t\tparts,\n    \t\t\t// The jqXHR state\n    \t\t\tstate = 0,\n    \t\t\t// To know if global events are to be dispatched\n    \t\t\tfireGlobals,\n    \t\t\t// Loop variable\n    \t\t\ti,\n    \t\t\t// Fake xhr\n    \t\t\tjqXHR = {\n    \n    \t\t\t\treadyState: 0,\n    \n    \t\t\t\t// Caches the header\n    \t\t\t\tsetRequestHeader: function( name, value ) {\n    \t\t\t\t\tif ( !state ) {\n    \t\t\t\t\t\tvar lname = name.toLowerCase();\n    \t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n    \t\t\t\t\t\trequestHeaders[ name ] = value;\n    \t\t\t\t\t}\n    \t\t\t\t\treturn this;\n    \t\t\t\t},\n    \n    \t\t\t\t// Raw string\n    \t\t\t\tgetAllResponseHeaders: function() {\n    \t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n    \t\t\t\t},\n    \n    \t\t\t\t// Builds headers hashtable if needed\n    \t\t\t\tgetResponseHeader: function( key ) {\n    \t\t\t\t\tvar match;\n    \t\t\t\t\tif ( state === 2 ) {\n    \t\t\t\t\t\tif ( !responseHeaders ) {\n    \t\t\t\t\t\t\tresponseHeaders = {};\n    \t\t\t\t\t\t\twhile( ( match = rheaders.exec( responseHeadersString ) ) ) {\n    \t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n    \t\t\t\t\t}\n    \t\t\t\t\treturn match === undefined ? null : match;\n    \t\t\t\t},\n    \n    \t\t\t\t// Overrides response content-type header\n    \t\t\t\toverrideMimeType: function( type ) {\n    \t\t\t\t\tif ( !state ) {\n    \t\t\t\t\t\ts.mimeType = type;\n    \t\t\t\t\t}\n    \t\t\t\t\treturn this;\n    \t\t\t\t},\n    \n    \t\t\t\t// Cancel the request\n    \t\t\t\tabort: function( statusText ) {\n    \t\t\t\t\tstatusText = statusText || \"abort\";\n    \t\t\t\t\tif ( transport ) {\n    \t\t\t\t\t\ttransport.abort( statusText );\n    \t\t\t\t\t}\n    \t\t\t\t\tdone( 0, statusText );\n    \t\t\t\t\treturn this;\n    \t\t\t\t}\n    \t\t\t};\n    \n    \t\t// Callback for when everything is done\n    \t\t// It is defined here because jslint complains if it is declared\n    \t\t// at the end of the function (which would be more logical and readable)\n    \t\tfunction done( status, nativeStatusText, responses, headers ) {\n    \n    \t\t\t// Called once\n    \t\t\tif ( state === 2 ) {\n    \t\t\t\treturn;\n    \t\t\t}\n    \n    \t\t\t// State is \"done\" now\n    \t\t\tstate = 2;\n    \n    \t\t\t// Clear timeout if it exists\n    \t\t\tif ( timeoutTimer ) {\n    \t\t\t\tclearTimeout( timeoutTimer );\n    \t\t\t}\n    \n    \t\t\t// Dereference transport for early garbage collection\n    \t\t\t// (no matter how long the jqXHR object will be used)\n    \t\t\ttransport = undefined;\n    \n    \t\t\t// Cache response headers\n    \t\t\tresponseHeadersString = headers || \"\";\n    \n    \t\t\t// Set readyState\n    \t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n    \n    \t\t\tvar isSuccess,\n    \t\t\t\tsuccess,\n    \t\t\t\terror,\n    \t\t\t\tstatusText = nativeStatusText,\n    \t\t\t\tresponse = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,\n    \t\t\t\tlastModified,\n    \t\t\t\tetag;\n    \n    \t\t\t// If successful, handle type chaining\n    \t\t\tif ( status >= 200 && status < 300 || status === 304 ) {\n    \n    \t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n    \t\t\t\tif ( s.ifModified ) {\n    \n    \t\t\t\t\tif ( ( lastModified = jqXHR.getResponseHeader( \"Last-Modified\" ) ) ) {\n    \t\t\t\t\t\tjQuery.lastModified[ ifModifiedKey ] = lastModified;\n    \t\t\t\t\t}\n    \t\t\t\t\tif ( ( etag = jqXHR.getResponseHeader( \"Etag\" ) ) ) {\n    \t\t\t\t\t\tjQuery.etag[ ifModifiedKey ] = etag;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\t// If not modified\n    \t\t\t\tif ( status === 304 ) {\n    \n    \t\t\t\t\tstatusText = \"notmodified\";\n    \t\t\t\t\tisSuccess = true;\n    \n    \t\t\t\t// If we have data\n    \t\t\t\t} else {\n    \n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tsuccess = ajaxConvert( s, response );\n    \t\t\t\t\t\tstatusText = \"success\";\n    \t\t\t\t\t\tisSuccess = true;\n    \t\t\t\t\t} catch(e) {\n    \t\t\t\t\t\t// We have a parsererror\n    \t\t\t\t\t\tstatusText = \"parsererror\";\n    \t\t\t\t\t\terror = e;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t} else {\n    \t\t\t\t// We extract error from statusText\n    \t\t\t\t// then normalize statusText and status for non-aborts\n    \t\t\t\terror = statusText;\n    \t\t\t\tif ( !statusText || status ) {\n    \t\t\t\t\tstatusText = \"error\";\n    \t\t\t\t\tif ( status < 0 ) {\n    \t\t\t\t\t\tstatus = 0;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// Set data for the fake xhr object\n    \t\t\tjqXHR.status = status;\n    \t\t\tjqXHR.statusText = \"\" + ( nativeStatusText || statusText );\n    \n    \t\t\t// Success/Error\n    \t\t\tif ( isSuccess ) {\n    \t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n    \t\t\t} else {\n    \t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n    \t\t\t}\n    \n    \t\t\t// Status-dependent callbacks\n    \t\t\tjqXHR.statusCode( statusCode );\n    \t\t\tstatusCode = undefined;\n    \n    \t\t\tif ( fireGlobals ) {\n    \t\t\t\tglobalEventContext.trigger( \"ajax\" + ( isSuccess ? \"Success\" : \"Error\" ),\n    \t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n    \t\t\t}\n    \n    \t\t\t// Complete\n    \t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n    \n    \t\t\tif ( fireGlobals ) {\n    \t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n    \t\t\t\t// Handle the global AJAX counter\n    \t\t\t\tif ( !( --jQuery.active ) ) {\n    \t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Attach deferreds\n    \t\tdeferred.promise( jqXHR );\n    \t\tjqXHR.success = jqXHR.done;\n    \t\tjqXHR.error = jqXHR.fail;\n    \t\tjqXHR.complete = completeDeferred.add;\n    \n    \t\t// Status-dependent callbacks\n    \t\tjqXHR.statusCode = function( map ) {\n    \t\t\tif ( map ) {\n    \t\t\t\tvar tmp;\n    \t\t\t\tif ( state < 2 ) {\n    \t\t\t\t\tfor ( tmp in map ) {\n    \t\t\t\t\t\tstatusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];\n    \t\t\t\t\t}\n    \t\t\t\t} else {\n    \t\t\t\t\ttmp = map[ jqXHR.status ];\n    \t\t\t\t\tjqXHR.then( tmp, tmp );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn this;\n    \t\t};\n    \n    \t\t// Remove hash character (#7531: and string promotion)\n    \t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n    \t\t// We also use the url parameter if available\n    \t\ts.url = ( ( url || s.url ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n    \n    \t\t// Extract dataTypes list\n    \t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().split( rspacesAjax );\n    \n    \t\t// Determine if a cross-domain request is in order\n    \t\tif ( s.crossDomain == null ) {\n    \t\t\tparts = rurl.exec( s.url.toLowerCase() );\n    \t\t\ts.crossDomain = !!( parts &&\n    \t\t\t\t( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||\n    \t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? 80 : 443 ) ) !=\n    \t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? 80 : 443 ) ) )\n    \t\t\t);\n    \t\t}\n    \n    \t\t// Convert data if not already a string\n    \t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n    \t\t\ts.data = jQuery.param( s.data, s.traditional );\n    \t\t}\n    \n    \t\t// Apply prefilters\n    \t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n    \n    \t\t// If request was aborted inside a prefiler, stop there\n    \t\tif ( state === 2 ) {\n    \t\t\treturn false;\n    \t\t}\n    \n    \t\t// We can fire global events as of now if asked to\n    \t\tfireGlobals = s.global;\n    \n    \t\t// Uppercase the type\n    \t\ts.type = s.type.toUpperCase();\n    \n    \t\t// Determine if request has content\n    \t\ts.hasContent = !rnoContent.test( s.type );\n    \n    \t\t// Watch for a new set of requests\n    \t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n    \t\t\tjQuery.event.trigger( \"ajaxStart\" );\n    \t\t}\n    \n    \t\t// More options handling for requests with no content\n    \t\tif ( !s.hasContent ) {\n    \n    \t\t\t// If data is available, append data to url\n    \t\t\tif ( s.data ) {\n    \t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.data;\n    \t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n    \t\t\t\tdelete s.data;\n    \t\t\t}\n    \n    \t\t\t// Get ifModifiedKey before adding the anti-cache parameter\n    \t\t\tifModifiedKey = s.url;\n    \n    \t\t\t// Add anti-cache in url if needed\n    \t\t\tif ( s.cache === false ) {\n    \n    \t\t\t\tvar ts = jQuery.now(),\n    \t\t\t\t\t// try replacing _= if it is there\n    \t\t\t\t\tret = s.url.replace( rts, \"$1_=\" + ts );\n    \n    \t\t\t\t// if nothing was replaced, add timestamp to the end\n    \t\t\t\ts.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? \"&\" : \"?\" ) + \"_=\" + ts : \"\" );\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Set the correct header, if data is being sent\n    \t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n    \t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n    \t\t}\n    \n    \t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n    \t\tif ( s.ifModified ) {\n    \t\t\tifModifiedKey = ifModifiedKey || s.url;\n    \t\t\tif ( jQuery.lastModified[ ifModifiedKey ] ) {\n    \t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ ifModifiedKey ] );\n    \t\t\t}\n    \t\t\tif ( jQuery.etag[ ifModifiedKey ] ) {\n    \t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ ifModifiedKey ] );\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Set the Accepts header for the server, depending on the dataType\n    \t\tjqXHR.setRequestHeader(\n    \t\t\t\"Accept\",\n    \t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n    \t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n    \t\t\t\ts.accepts[ \"*\" ]\n    \t\t);\n    \n    \t\t// Check for headers option\n    \t\tfor ( i in s.headers ) {\n    \t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n    \t\t}\n    \n    \t\t// Allow custom headers/mimetypes and early abort\n    \t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n    \t\t\t\t// Abort if not done already\n    \t\t\t\tjqXHR.abort();\n    \t\t\t\treturn false;\n    \n    \t\t}\n    \n    \t\t// Install callbacks on deferreds\n    \t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n    \t\t\tjqXHR[ i ]( s[ i ] );\n    \t\t}\n    \n    \t\t// Get transport\n    \t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n    \n    \t\t// If no transport, we auto-abort\n    \t\tif ( !transport ) {\n    \t\t\tdone( -1, \"No Transport\" );\n    \t\t} else {\n    \t\t\tjqXHR.readyState = 1;\n    \t\t\t// Send global event\n    \t\t\tif ( fireGlobals ) {\n    \t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n    \t\t\t}\n    \t\t\t// Timeout\n    \t\t\tif ( s.async && s.timeout > 0 ) {\n    \t\t\t\ttimeoutTimer = setTimeout( function(){\n    \t\t\t\t\tjqXHR.abort( \"timeout\" );\n    \t\t\t\t}, s.timeout );\n    \t\t\t}\n    \n    \t\t\ttry {\n    \t\t\t\tstate = 1;\n    \t\t\t\ttransport.send( requestHeaders, done );\n    \t\t\t} catch (e) {\n    \t\t\t\t// Propagate exception as error if not done\n    \t\t\t\tif ( state < 2 ) {\n    \t\t\t\t\tdone( -1, e );\n    \t\t\t\t// Simply rethrow otherwise\n    \t\t\t\t} else {\n    \t\t\t\t\tthrow e;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\treturn jqXHR;\n    \t},\n    \n    \t// Serialize an array of form elements or a set of\n    \t// key/values into a query string\n    \tparam: function( a, traditional ) {\n    \t\tvar s = [],\n    \t\t\tadd = function( key, value ) {\n    \t\t\t\t// If value is a function, invoke it and return its value\n    \t\t\t\tvalue = jQuery.isFunction( value ) ? value() : value;\n    \t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n    \t\t\t};\n    \n    \t\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n    \t\tif ( traditional === undefined ) {\n    \t\t\ttraditional = jQuery.ajaxSettings.traditional;\n    \t\t}\n    \n    \t\t// If an array was passed in, assume that it is an array of form elements.\n    \t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n    \t\t\t// Serialize the form elements\n    \t\t\tjQuery.each( a, function() {\n    \t\t\t\tadd( this.name, this.value );\n    \t\t\t});\n    \n    \t\t} else {\n    \t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n    \t\t\t// did it), otherwise encode params recursively.\n    \t\t\tfor ( var prefix in a ) {\n    \t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Return the resulting serialization\n    \t\treturn s.join( \"&\" ).replace( r20, \"+\" );\n    \t}\n    });\n    \n    function buildParams( prefix, obj, traditional, add ) {\n    \tif ( jQuery.isArray( obj ) ) {\n    \t\t// Serialize array item.\n    \t\tjQuery.each( obj, function( i, v ) {\n    \t\t\tif ( traditional || rbracket.test( prefix ) ) {\n    \t\t\t\t// Treat each array item as a scalar.\n    \t\t\t\tadd( prefix, v );\n    \n    \t\t\t} else {\n    \t\t\t\t// If array item is non-scalar (array or object), encode its\n    \t\t\t\t// numeric index to resolve deserialization ambiguity issues.\n    \t\t\t\t// Note that rack (as of 1.0.0) can't currently deserialize\n    \t\t\t\t// nested arrays properly, and attempting to do so may cause\n    \t\t\t\t// a server error. Possible fixes are to modify rack's\n    \t\t\t\t// deserialization algorithm or to provide an option or flag\n    \t\t\t\t// to force array serialization to be shallow.\n    \t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" || jQuery.isArray(v) ? i : \"\" ) + \"]\", v, traditional, add );\n    \t\t\t}\n    \t\t});\n    \n    \t} else if ( !traditional && obj != null && typeof obj === \"object\" ) {\n    \t\t// Serialize object item.\n    \t\tfor ( var name in obj ) {\n    \t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n    \t\t}\n    \n    \t} else {\n    \t\t// Serialize scalar item.\n    \t\tadd( prefix, obj );\n    \t}\n    }\n    \n    // This is still on the jQuery object... for now\n    // Want to move this to jQuery.ajax some day\n    jQuery.extend({\n    \n    \t// Counter for holding the number of active queries\n    \tactive: 0,\n    \n    \t// Last-Modified header cache for next request\n    \tlastModified: {},\n    \tetag: {}\n    \n    });\n    \n    /* Handles responses to an ajax request:\n     * - sets all responseXXX fields accordingly\n     * - finds the right dataType (mediates between content-type and expected dataType)\n     * - returns the corresponding response\n     */\n    function ajaxHandleResponses( s, jqXHR, responses ) {\n    \n    \tvar contents = s.contents,\n    \t\tdataTypes = s.dataTypes,\n    \t\tresponseFields = s.responseFields,\n    \t\tct,\n    \t\ttype,\n    \t\tfinalDataType,\n    \t\tfirstDataType;\n    \n    \t// Fill responseXXX fields\n    \tfor ( type in responseFields ) {\n    \t\tif ( type in responses ) {\n    \t\t\tjqXHR[ responseFields[type] ] = responses[ type ];\n    \t\t}\n    \t}\n    \n    \t// Remove auto dataType and get content-type in the process\n    \twhile( dataTypes[ 0 ] === \"*\" ) {\n    \t\tdataTypes.shift();\n    \t\tif ( ct === undefined ) {\n    \t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"content-type\" );\n    \t\t}\n    \t}\n    \n    \t// Check if we're dealing with a known content-type\n    \tif ( ct ) {\n    \t\tfor ( type in contents ) {\n    \t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n    \t\t\t\tdataTypes.unshift( type );\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \t// Check to see if we have a response for the expected dataType\n    \tif ( dataTypes[ 0 ] in responses ) {\n    \t\tfinalDataType = dataTypes[ 0 ];\n    \t} else {\n    \t\t// Try convertible dataTypes\n    \t\tfor ( type in responses ) {\n    \t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n    \t\t\t\tfinalDataType = type;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tif ( !firstDataType ) {\n    \t\t\t\tfirstDataType = type;\n    \t\t\t}\n    \t\t}\n    \t\t// Or just use first one\n    \t\tfinalDataType = finalDataType || firstDataType;\n    \t}\n    \n    \t// If we found a dataType\n    \t// We add the dataType to the list if needed\n    \t// and return the corresponding response\n    \tif ( finalDataType ) {\n    \t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n    \t\t\tdataTypes.unshift( finalDataType );\n    \t\t}\n    \t\treturn responses[ finalDataType ];\n    \t}\n    }\n    \n    // Chain conversions given the request and the original response\n    function ajaxConvert( s, response ) {\n    \n    \t// Apply the dataFilter if provided\n    \tif ( s.dataFilter ) {\n    \t\tresponse = s.dataFilter( response, s.dataType );\n    \t}\n    \n    \tvar dataTypes = s.dataTypes,\n    \t\tconverters = {},\n    \t\ti,\n    \t\tkey,\n    \t\tlength = dataTypes.length,\n    \t\ttmp,\n    \t\t// Current and previous dataTypes\n    \t\tcurrent = dataTypes[ 0 ],\n    \t\tprev,\n    \t\t// Conversion expression\n    \t\tconversion,\n    \t\t// Conversion function\n    \t\tconv,\n    \t\t// Conversion functions (transitive conversion)\n    \t\tconv1,\n    \t\tconv2;\n    \n    \t// For each dataType in the chain\n    \tfor ( i = 1; i < length; i++ ) {\n    \n    \t\t// Create converters map\n    \t\t// with lowercased keys\n    \t\tif ( i === 1 ) {\n    \t\t\tfor ( key in s.converters ) {\n    \t\t\t\tif ( typeof key === \"string\" ) {\n    \t\t\t\t\tconverters[ key.toLowerCase() ] = s.converters[ key ];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\t// Get the dataTypes\n    \t\tprev = current;\n    \t\tcurrent = dataTypes[ i ];\n    \n    \t\t// If current is auto dataType, update it to prev\n    \t\tif ( current === \"*\" ) {\n    \t\t\tcurrent = prev;\n    \t\t// If no auto and dataTypes are actually different\n    \t\t} else if ( prev !== \"*\" && prev !== current ) {\n    \n    \t\t\t// Get the converter\n    \t\t\tconversion = prev + \" \" + current;\n    \t\t\tconv = converters[ conversion ] || converters[ \"* \" + current ];\n    \n    \t\t\t// If there is no direct converter, search transitively\n    \t\t\tif ( !conv ) {\n    \t\t\t\tconv2 = undefined;\n    \t\t\t\tfor ( conv1 in converters ) {\n    \t\t\t\t\ttmp = conv1.split( \" \" );\n    \t\t\t\t\tif ( tmp[ 0 ] === prev || tmp[ 0 ] === \"*\" ) {\n    \t\t\t\t\t\tconv2 = converters[ tmp[1] + \" \" + current ];\n    \t\t\t\t\t\tif ( conv2 ) {\n    \t\t\t\t\t\t\tconv1 = converters[ conv1 ];\n    \t\t\t\t\t\t\tif ( conv1 === true ) {\n    \t\t\t\t\t\t\t\tconv = conv2;\n    \t\t\t\t\t\t\t} else if ( conv2 === true ) {\n    \t\t\t\t\t\t\t\tconv = conv1;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t// If we found no converter, dispatch an error\n    \t\t\tif ( !( conv || conv2 ) ) {\n    \t\t\t\tjQuery.error( \"No conversion from \" + conversion.replace(\" \",\" to \") );\n    \t\t\t}\n    \t\t\t// If found converter is not an equivalence\n    \t\t\tif ( conv !== true ) {\n    \t\t\t\t// Convert with 1 or 2 converters accordingly\n    \t\t\t\tresponse = conv ? conv( response ) : conv2( conv1(response) );\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn response;\n    }\n    \n    \n    \n    \n    var jsc = jQuery.now(),\n    \tjsre = /(\\=)\\?(&|$)|\\?\\?/i;\n    \n    // Default jsonp settings\n    jQuery.ajaxSetup({\n    \tjsonp: \"callback\",\n    \tjsonpCallback: function() {\n    \t\treturn jQuery.expando + \"_\" + ( jsc++ );\n    \t}\n    });\n    \n    // Detect, normalize options and install callbacks for jsonp requests\n    jQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n    \n    \tvar inspectData = s.contentType === \"application/x-www-form-urlencoded\" &&\n    \t\t( typeof s.data === \"string\" );\n    \n    \tif ( s.dataTypes[ 0 ] === \"jsonp\" ||\n    \t\ts.jsonp !== false && ( jsre.test( s.url ) ||\n    \t\t\t\tinspectData && jsre.test( s.data ) ) ) {\n    \n    \t\tvar responseContainer,\n    \t\t\tjsonpCallback = s.jsonpCallback =\n    \t\t\t\tjQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,\n    \t\t\tprevious = window[ jsonpCallback ],\n    \t\t\turl = s.url,\n    \t\t\tdata = s.data,\n    \t\t\treplace = \"$1\" + jsonpCallback + \"$2\";\n    \n    \t\tif ( s.jsonp !== false ) {\n    \t\t\turl = url.replace( jsre, replace );\n    \t\t\tif ( s.url === url ) {\n    \t\t\t\tif ( inspectData ) {\n    \t\t\t\t\tdata = data.replace( jsre, replace );\n    \t\t\t\t}\n    \t\t\t\tif ( s.data === data ) {\n    \t\t\t\t\t// Add callback manually\n    \t\t\t\t\turl += (/\\?/.test( url ) ? \"&\" : \"?\") + s.jsonp + \"=\" + jsonpCallback;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\ts.url = url;\n    \t\ts.data = data;\n    \n    \t\t// Install callback\n    \t\twindow[ jsonpCallback ] = function( response ) {\n    \t\t\tresponseContainer = [ response ];\n    \t\t};\n    \n    \t\t// Clean-up function\n    \t\tjqXHR.always(function() {\n    \t\t\t// Set callback back to previous value\n    \t\t\twindow[ jsonpCallback ] = previous;\n    \t\t\t// Call if it was a function and we have a response\n    \t\t\tif ( responseContainer && jQuery.isFunction( previous ) ) {\n    \t\t\t\twindow[ jsonpCallback ]( responseContainer[ 0 ] );\n    \t\t\t}\n    \t\t});\n    \n    \t\t// Use data converter to retrieve json after script execution\n    \t\ts.converters[\"script json\"] = function() {\n    \t\t\tif ( !responseContainer ) {\n    \t\t\t\tjQuery.error( jsonpCallback + \" was not called\" );\n    \t\t\t}\n    \t\t\treturn responseContainer[ 0 ];\n    \t\t};\n    \n    \t\t// force json dataType\n    \t\ts.dataTypes[ 0 ] = \"json\";\n    \n    \t\t// Delegate to script\n    \t\treturn \"script\";\n    \t}\n    });\n    \n    \n    \n    \n    // Install script dataType\n    jQuery.ajaxSetup({\n    \taccepts: {\n    \t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n    \t},\n    \tcontents: {\n    \t\tscript: /javascript|ecmascript/\n    \t},\n    \tconverters: {\n    \t\t\"text script\": function( text ) {\n    \t\t\tjQuery.globalEval( text );\n    \t\t\treturn text;\n    \t\t}\n    \t}\n    });\n    \n    // Handle cache's special case and global\n    jQuery.ajaxPrefilter( \"script\", function( s ) {\n    \tif ( s.cache === undefined ) {\n    \t\ts.cache = false;\n    \t}\n    \tif ( s.crossDomain ) {\n    \t\ts.type = \"GET\";\n    \t\ts.global = false;\n    \t}\n    });\n    \n    // Bind script tag hack transport\n    jQuery.ajaxTransport( \"script\", function(s) {\n    \n    \t// This transport only deals with cross domain requests\n    \tif ( s.crossDomain ) {\n    \n    \t\tvar script,\n    \t\t\thead = document.head || document.getElementsByTagName( \"head\" )[0] || document.documentElement;\n    \n    \t\treturn {\n    \n    \t\t\tsend: function( _, callback ) {\n    \n    \t\t\t\tscript = document.createElement( \"script\" );\n    \n    \t\t\t\tscript.async = \"async\";\n    \n    \t\t\t\tif ( s.scriptCharset ) {\n    \t\t\t\t\tscript.charset = s.scriptCharset;\n    \t\t\t\t}\n    \n    \t\t\t\tscript.src = s.url;\n    \n    \t\t\t\t// Attach handlers for all browsers\n    \t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n    \n    \t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n    \n    \t\t\t\t\t\t// Handle memory leak in IE\n    \t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n    \n    \t\t\t\t\t\t// Remove the script\n    \t\t\t\t\t\tif ( head && script.parentNode ) {\n    \t\t\t\t\t\t\thead.removeChild( script );\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t// Dereference the script\n    \t\t\t\t\t\tscript = undefined;\n    \n    \t\t\t\t\t\t// Callback if not abort\n    \t\t\t\t\t\tif ( !isAbort ) {\n    \t\t\t\t\t\t\tcallback( 200, \"success\" );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t};\n    \t\t\t\t// Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n    \t\t\t\t// This arises when a base node is used (#2709 and #4378).\n    \t\t\t\thead.insertBefore( script, head.firstChild );\n    \t\t\t},\n    \n    \t\t\tabort: function() {\n    \t\t\t\tif ( script ) {\n    \t\t\t\t\tscript.onload( 0, 1 );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t};\n    \t}\n    });\n    \n    \n    \n    \n    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload\n    \txhrOnUnloadAbort = window.ActiveXObject ? function() {\n    \t\t// Abort all pending requests\n    \t\tfor ( var key in xhrCallbacks ) {\n    \t\t\txhrCallbacks[ key ]( 0, 1 );\n    \t\t}\n    \t} : false,\n    \txhrId = 0,\n    \txhrCallbacks;\n    \n    // Functions to create xhrs\n    function createStandardXHR() {\n    \ttry {\n    \t\treturn new window.XMLHttpRequest();\n    \t} catch( e ) {}\n    }\n    \n    function createActiveXHR() {\n    \ttry {\n    \t\treturn new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n    \t} catch( e ) {}\n    }\n    \n    // Create the request object\n    // (This is still attached to ajaxSettings for backward compatibility)\n    jQuery.ajaxSettings.xhr = window.ActiveXObject ?\n    \t/* Microsoft failed to properly\n    \t * implement the XMLHttpRequest in IE7 (can't request local files),\n    \t * so we use the ActiveXObject when it is available\n    \t * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n    \t * we need a fallback.\n    \t */\n    \tfunction() {\n    \t\treturn !this.isLocal && createStandardXHR() || createActiveXHR();\n    \t} :\n    \t// For all other browsers, use the standard XMLHttpRequest object\n    \tcreateStandardXHR;\n    \n    // Determine support properties\n    (function( xhr ) {\n    \tjQuery.extend( jQuery.support, {\n    \t\tajax: !!xhr,\n    \t\tcors: !!xhr && ( \"withCredentials\" in xhr )\n    \t});\n    })( jQuery.ajaxSettings.xhr() );\n    \n    // Create transport if the browser can provide an xhr\n    if ( jQuery.support.ajax ) {\n    \n    \tjQuery.ajaxTransport(function( s ) {\n    \t\t// Cross domain only allowed if supported through XMLHttpRequest\n    \t\tif ( !s.crossDomain || jQuery.support.cors ) {\n    \n    \t\t\tvar callback;\n    \n    \t\t\treturn {\n    \t\t\t\tsend: function( headers, complete ) {\n    \n    \t\t\t\t\t// Get a new xhr\n    \t\t\t\t\tvar xhr = s.xhr(),\n    \t\t\t\t\t\thandle,\n    \t\t\t\t\t\ti;\n    \n    \t\t\t\t\t// Open the socket\n    \t\t\t\t\t// Passing null username, generates a login popup on Opera (#2865)\n    \t\t\t\t\tif ( s.username ) {\n    \t\t\t\t\t\txhr.open( s.type, s.url, s.async, s.username, s.password );\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\txhr.open( s.type, s.url, s.async );\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Apply custom fields if provided\n    \t\t\t\t\tif ( s.xhrFields ) {\n    \t\t\t\t\t\tfor ( i in s.xhrFields ) {\n    \t\t\t\t\t\t\txhr[ i ] = s.xhrFields[ i ];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Override mime type if needed\n    \t\t\t\t\tif ( s.mimeType && xhr.overrideMimeType ) {\n    \t\t\t\t\t\txhr.overrideMimeType( s.mimeType );\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// X-Requested-With header\n    \t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n    \t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n    \t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n    \t\t\t\t\t// For same-domain requests, won't change header if already provided.\n    \t\t\t\t\tif ( !s.crossDomain && !headers[\"X-Requested-With\"] ) {\n    \t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tfor ( i in headers ) {\n    \t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t} catch( _ ) {}\n    \n    \t\t\t\t\t// Do send the request\n    \t\t\t\t\t// This may raise an exception which is actually\n    \t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n    \t\t\t\t\txhr.send( ( s.hasContent && s.data ) || null );\n    \n    \t\t\t\t\t// Listener\n    \t\t\t\t\tcallback = function( _, isAbort ) {\n    \n    \t\t\t\t\t\tvar status,\n    \t\t\t\t\t\t\tstatusText,\n    \t\t\t\t\t\t\tresponseHeaders,\n    \t\t\t\t\t\t\tresponses,\n    \t\t\t\t\t\t\txml;\n    \n    \t\t\t\t\t\t// Firefox throws exceptions when accessing properties\n    \t\t\t\t\t\t// of an xhr when a network error occured\n    \t\t\t\t\t\t// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n    \t\t\t\t\t\ttry {\n    \n    \t\t\t\t\t\t\t// Was never called and is aborted or complete\n    \t\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n    \n    \t\t\t\t\t\t\t\t// Only called once\n    \t\t\t\t\t\t\t\tcallback = undefined;\n    \n    \t\t\t\t\t\t\t\t// Do not keep as active anymore\n    \t\t\t\t\t\t\t\tif ( handle ) {\n    \t\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n    \t\t\t\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n    \t\t\t\t\t\t\t\t\t\tdelete xhrCallbacks[ handle ];\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t\t\t// If it's an abort\n    \t\t\t\t\t\t\t\tif ( isAbort ) {\n    \t\t\t\t\t\t\t\t\t// Abort it manually if needed\n    \t\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n    \t\t\t\t\t\t\t\t\t\txhr.abort();\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t\t\tstatus = xhr.status;\n    \t\t\t\t\t\t\t\t\tresponseHeaders = xhr.getAllResponseHeaders();\n    \t\t\t\t\t\t\t\t\tresponses = {};\n    \t\t\t\t\t\t\t\t\txml = xhr.responseXML;\n    \n    \t\t\t\t\t\t\t\t\t// Construct response list\n    \t\t\t\t\t\t\t\t\tif ( xml && xml.documentElement /* #4958 */ ) {\n    \t\t\t\t\t\t\t\t\t\tresponses.xml = xml;\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n    \n    \t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n    \t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n    \t\t\t\t\t\t\t\t\ttry {\n    \t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n    \t\t\t\t\t\t\t\t\t} catch( e ) {\n    \t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n    \t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n    \t\t\t\t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n    \n    \t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n    \t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n    \t\t\t\t\t\t\t\t\t// can do given current implementations)\n    \t\t\t\t\t\t\t\t\tif ( !status && s.isLocal && !s.crossDomain ) {\n    \t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n    \t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n    \t\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n    \t\t\t\t\t\t\t\t\t\tstatus = 204;\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t} catch( firefoxAccessException ) {\n    \t\t\t\t\t\t\tif ( !isAbort ) {\n    \t\t\t\t\t\t\t\tcomplete( -1, firefoxAccessException );\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t// Call complete if needed\n    \t\t\t\t\t\tif ( responses ) {\n    \t\t\t\t\t\t\tcomplete( status, statusText, responses, responseHeaders );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t};\n    \n    \t\t\t\t\t// if we're in sync mode or it's in cache\n    \t\t\t\t\t// and has been retrieved directly (IE6 & IE7)\n    \t\t\t\t\t// we need to manually fire the callback\n    \t\t\t\t\tif ( !s.async || xhr.readyState === 4 ) {\n    \t\t\t\t\t\tcallback();\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\thandle = ++xhrId;\n    \t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n    \t\t\t\t\t\t\t// Create the active xhrs callbacks list if needed\n    \t\t\t\t\t\t\t// and attach the unload handler\n    \t\t\t\t\t\t\tif ( !xhrCallbacks ) {\n    \t\t\t\t\t\t\t\txhrCallbacks = {};\n    \t\t\t\t\t\t\t\tjQuery( window ).unload( xhrOnUnloadAbort );\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t// Add to list of active xhrs callbacks\n    \t\t\t\t\t\t\txhrCallbacks[ handle ] = callback;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\txhr.onreadystatechange = callback;\n    \t\t\t\t\t}\n    \t\t\t\t},\n    \n    \t\t\t\tabort: function() {\n    \t\t\t\t\tif ( callback ) {\n    \t\t\t\t\t\tcallback(0,1);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t};\n    \t\t}\n    \t});\n    }\n    \n    \n    \n    \n    var elemdisplay = {},\n    \tiframe, iframeDoc,\n    \trfxtypes = /^(?:toggle|show|hide)$/,\n    \trfxnum = /^([+\\-]=)?([\\d+.\\-]+)([a-z%]*)$/i,\n    \ttimerId,\n    \tfxAttrs = [\n    \t\t// height animations\n    \t\t[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n    \t\t// width animations\n    \t\t[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n    \t\t// opacity animations\n    \t\t[ \"opacity\" ]\n    \t],\n    \tfxNow;\n    \n    jQuery.fn.extend({\n    \tshow: function( speed, easing, callback ) {\n    \t\tvar elem, display;\n    \n    \t\tif ( speed || speed === 0 ) {\n    \t\t\treturn this.animate( genFx(\"show\", 3), speed, easing, callback );\n    \n    \t\t} else {\n    \t\t\tfor ( var i = 0, j = this.length; i < j; i++ ) {\n    \t\t\t\telem = this[ i ];\n    \n    \t\t\t\tif ( elem.style ) {\n    \t\t\t\t\tdisplay = elem.style.display;\n    \n    \t\t\t\t\t// Reset the inline display of this element to learn if it is\n    \t\t\t\t\t// being hidden by cascaded rules or not\n    \t\t\t\t\tif ( !jQuery._data(elem, \"olddisplay\") && display === \"none\" ) {\n    \t\t\t\t\t\tdisplay = elem.style.display = \"\";\n    \t\t\t\t\t}\n    \n    \t\t\t\t\t// Set elements which have been overridden with display: none\n    \t\t\t\t\t// in a stylesheet to whatever the default browser style is\n    \t\t\t\t\t// for such an element\n    \t\t\t\t\tif ( display === \"\" && jQuery.css(elem, \"display\") === \"none\" ) {\n    \t\t\t\t\t\tjQuery._data( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// Set the display of most of the elements in a second loop\n    \t\t\t// to avoid the constant reflow\n    \t\t\tfor ( i = 0; i < j; i++ ) {\n    \t\t\t\telem = this[ i ];\n    \n    \t\t\t\tif ( elem.style ) {\n    \t\t\t\t\tdisplay = elem.style.display;\n    \n    \t\t\t\t\tif ( display === \"\" || display === \"none\" ) {\n    \t\t\t\t\t\telem.style.display = jQuery._data( elem, \"olddisplay\" ) || \"\";\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\treturn this;\n    \t\t}\n    \t},\n    \n    \thide: function( speed, easing, callback ) {\n    \t\tif ( speed || speed === 0 ) {\n    \t\t\treturn this.animate( genFx(\"hide\", 3), speed, easing, callback);\n    \n    \t\t} else {\n    \t\t\tvar elem, display,\n    \t\t\t\ti = 0,\n    \t\t\t\tj = this.length;\n    \n    \t\t\tfor ( ; i < j; i++ ) {\n    \t\t\t\telem = this[i];\n    \t\t\t\tif ( elem.style ) {\n    \t\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n    \n    \t\t\t\t\tif ( display !== \"none\" && !jQuery._data( elem, \"olddisplay\" ) ) {\n    \t\t\t\t\t\tjQuery._data( elem, \"olddisplay\", display );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// Set the display of the elements in a second loop\n    \t\t\t// to avoid the constant reflow\n    \t\t\tfor ( i = 0; i < j; i++ ) {\n    \t\t\t\tif ( this[i].style ) {\n    \t\t\t\t\tthis[i].style.display = \"none\";\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\treturn this;\n    \t\t}\n    \t},\n    \n    \t// Save the old toggle function\n    \t_toggle: jQuery.fn.toggle,\n    \n    \ttoggle: function( fn, fn2, callback ) {\n    \t\tvar bool = typeof fn === \"boolean\";\n    \n    \t\tif ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {\n    \t\t\tthis._toggle.apply( this, arguments );\n    \n    \t\t} else if ( fn == null || bool ) {\n    \t\t\tthis.each(function() {\n    \t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n    \t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n    \t\t\t});\n    \n    \t\t} else {\n    \t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2, callback);\n    \t\t}\n    \n    \t\treturn this;\n    \t},\n    \n    \tfadeTo: function( speed, to, easing, callback ) {\n    \t\treturn this.filter(\":hidden\").css(\"opacity\", 0).show().end()\n    \t\t\t\t\t.animate({opacity: to}, speed, easing, callback);\n    \t},\n    \n    \tanimate: function( prop, speed, easing, callback ) {\n    \t\tvar optall = jQuery.speed( speed, easing, callback );\n    \n    \t\tif ( jQuery.isEmptyObject( prop ) ) {\n    \t\t\treturn this.each( optall.complete, [ false ] );\n    \t\t}\n    \n    \t\t// Do not change referenced properties as per-property easing will be lost\n    \t\tprop = jQuery.extend( {}, prop );\n    \n    \t\tfunction doAnimation() {\n    \t\t\t// XXX 'this' does not always have a nodeName when running the\n    \t\t\t// test suite\n    \n    \t\t\tif ( optall.queue === false ) {\n    \t\t\t\tjQuery._mark( this );\n    \t\t\t}\n    \n    \t\t\tvar opt = jQuery.extend( {}, optall ),\n    \t\t\t\tisElement = this.nodeType === 1,\n    \t\t\t\thidden = isElement && jQuery(this).is(\":hidden\"),\n    \t\t\t\tname, val, p, e,\n    \t\t\t\tparts, start, end, unit,\n    \t\t\t\tmethod;\n    \n    \t\t\t// will store per property easing and be used to determine when an animation is complete\n    \t\t\topt.animatedProperties = {};\n    \n    \t\t\tfor ( p in prop ) {\n    \n    \t\t\t\t// property name normalization\n    \t\t\t\tname = jQuery.camelCase( p );\n    \t\t\t\tif ( p !== name ) {\n    \t\t\t\t\tprop[ name ] = prop[ p ];\n    \t\t\t\t\tdelete prop[ p ];\n    \t\t\t\t}\n    \n    \t\t\t\tval = prop[ name ];\n    \n    \t\t\t\t// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)\n    \t\t\t\tif ( jQuery.isArray( val ) ) {\n    \t\t\t\t\topt.animatedProperties[ name ] = val[ 1 ];\n    \t\t\t\t\tval = prop[ name ] = val[ 0 ];\n    \t\t\t\t} else {\n    \t\t\t\t\topt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';\n    \t\t\t\t}\n    \n    \t\t\t\tif ( val === \"hide\" && hidden || val === \"show\" && !hidden ) {\n    \t\t\t\t\treturn opt.complete.call( this );\n    \t\t\t\t}\n    \n    \t\t\t\tif ( isElement && ( name === \"height\" || name === \"width\" ) ) {\n    \t\t\t\t\t// Make sure that nothing sneaks out\n    \t\t\t\t\t// Record all 3 overflow attributes because IE does not\n    \t\t\t\t\t// change the overflow attribute when overflowX and\n    \t\t\t\t\t// overflowY are set to the same value\n    \t\t\t\t\topt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];\n    \n    \t\t\t\t\t// Set display property to inline-block for height/width\n    \t\t\t\t\t// animations on inline elements that are having width/height animated\n    \t\t\t\t\tif ( jQuery.css( this, \"display\" ) === \"inline\" &&\n    \t\t\t\t\t\t\tjQuery.css( this, \"float\" ) === \"none\" ) {\n    \n    \t\t\t\t\t\t// inline-level elements accept inline-block;\n    \t\t\t\t\t\t// block-level elements need to be inline with layout\n    \t\t\t\t\t\tif ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === \"inline\" ) {\n    \t\t\t\t\t\t\tthis.style.display = \"inline-block\";\n    \n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\tthis.style.zoom = 1;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\tif ( opt.overflow != null ) {\n    \t\t\t\tthis.style.overflow = \"hidden\";\n    \t\t\t}\n    \n    \t\t\tfor ( p in prop ) {\n    \t\t\t\te = new jQuery.fx( this, opt, p );\n    \t\t\t\tval = prop[ p ];\n    \n    \t\t\t\tif ( rfxtypes.test( val ) ) {\n    \n    \t\t\t\t\t// Tracks whether to show or hide based on private\n    \t\t\t\t\t// data attached to the element\n    \t\t\t\t\tmethod = jQuery._data( this, \"toggle\" + p ) || ( val === \"toggle\" ? hidden ? \"show\" : \"hide\" : 0 );\n    \t\t\t\t\tif ( method ) {\n    \t\t\t\t\t\tjQuery._data( this, \"toggle\" + p, method === \"show\" ? \"hide\" : \"show\" );\n    \t\t\t\t\t\te[ method ]();\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\te[ val ]();\n    \t\t\t\t\t}\n    \n    \t\t\t\t} else {\n    \t\t\t\t\tparts = rfxnum.exec( val );\n    \t\t\t\t\tstart = e.cur();\n    \n    \t\t\t\t\tif ( parts ) {\n    \t\t\t\t\t\tend = parseFloat( parts[2] );\n    \t\t\t\t\t\tunit = parts[3] || ( jQuery.cssNumber[ p ] ? \"\" : \"px\" );\n    \n    \t\t\t\t\t\t// We need to compute starting value\n    \t\t\t\t\t\tif ( unit !== \"px\" ) {\n    \t\t\t\t\t\t\tjQuery.style( this, p, (end || 1) + unit);\n    \t\t\t\t\t\t\tstart = ( (end || 1) / e.cur() ) * start;\n    \t\t\t\t\t\t\tjQuery.style( this, p, start + unit);\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n    \t\t\t\t\t\tif ( parts[1] ) {\n    \t\t\t\t\t\t\tend = ( (parts[ 1 ] === \"-=\" ? -1 : 1) * end ) + start;\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t\te.custom( start, end, unit );\n    \n    \t\t\t\t\t} else {\n    \t\t\t\t\t\te.custom( start, val, \"\" );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// For JS strict compliance\n    \t\t\treturn true;\n    \t\t}\n    \n    \t\treturn optall.queue === false ?\n    \t\t\tthis.each( doAnimation ) :\n    \t\t\tthis.queue( optall.queue, doAnimation );\n    \t},\n    \n    \tstop: function( type, clearQueue, gotoEnd ) {\n    \t\tif ( typeof type !== \"string\" ) {\n    \t\t\tgotoEnd = clearQueue;\n    \t\t\tclearQueue = type;\n    \t\t\ttype = undefined;\n    \t\t}\n    \t\tif ( clearQueue && type !== false ) {\n    \t\t\tthis.queue( type || \"fx\", [] );\n    \t\t}\n    \n    \t\treturn this.each(function() {\n    \t\t\tvar index,\n    \t\t\t\thadTimers = false,\n    \t\t\t\ttimers = jQuery.timers,\n    \t\t\t\tdata = jQuery._data( this );\n    \n    \t\t\t// clear marker counters if we know they won't be\n    \t\t\tif ( !gotoEnd ) {\n    \t\t\t\tjQuery._unmark( true, this );\n    \t\t\t}\n    \n    \t\t\tfunction stopQueue( elem, data, index ) {\n    \t\t\t\tvar hooks = data[ index ];\n    \t\t\t\tjQuery.removeData( elem, index, true );\n    \t\t\t\thooks.stop( gotoEnd );\n    \t\t\t}\n    \n    \t\t\tif ( type == null ) {\n    \t\t\t\tfor ( index in data ) {\n    \t\t\t\t\tif ( data[ index ] && data[ index ].stop && index.indexOf(\".run\") === index.length - 4 ) {\n    \t\t\t\t\t\tstopQueue( this, data, index );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t} else if ( data[ index = type + \".run\" ] && data[ index ].stop ){\n    \t\t\t\tstopQueue( this, data, index );\n    \t\t\t}\n    \n    \t\t\tfor ( index = timers.length; index--; ) {\n    \t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n    \t\t\t\t\tif ( gotoEnd ) {\n    \n    \t\t\t\t\t\t// force the next step to be the last\n    \t\t\t\t\t\ttimers[ index ]( true );\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\ttimers[ index ].saveState();\n    \t\t\t\t\t}\n    \t\t\t\t\thadTimers = true;\n    \t\t\t\t\ttimers.splice( index, 1 );\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\t// start the next in the queue if the last step wasn't forced\n    \t\t\t// timers currently will call their complete callbacks, which will dequeue\n    \t\t\t// but only if they were gotoEnd\n    \t\t\tif ( !( gotoEnd && hadTimers ) ) {\n    \t\t\t\tjQuery.dequeue( this, type );\n    \t\t\t}\n    \t\t});\n    \t}\n    \n    });\n    \n    // Animations created synchronously will run synchronously\n    function createFxNow() {\n    \tsetTimeout( clearFxNow, 0 );\n    \treturn ( fxNow = jQuery.now() );\n    }\n    \n    function clearFxNow() {\n    \tfxNow = undefined;\n    }\n    \n    // Generate parameters to create a standard animation\n    function genFx( type, num ) {\n    \tvar obj = {};\n    \n    \tjQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {\n    \t\tobj[ this ] = type;\n    \t});\n    \n    \treturn obj;\n    }\n    \n    // Generate shortcuts for custom animations\n    jQuery.each({\n    \tslideDown: genFx( \"show\", 1 ),\n    \tslideUp: genFx( \"hide\", 1 ),\n    \tslideToggle: genFx( \"toggle\", 1 ),\n    \tfadeIn: { opacity: \"show\" },\n    \tfadeOut: { opacity: \"hide\" },\n    \tfadeToggle: { opacity: \"toggle\" }\n    }, function( name, props ) {\n    \tjQuery.fn[ name ] = function( speed, easing, callback ) {\n    \t\treturn this.animate( props, speed, easing, callback );\n    \t};\n    });\n    \n    jQuery.extend({\n    \tspeed: function( speed, easing, fn ) {\n    \t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n    \t\t\tcomplete: fn || !fn && easing ||\n    \t\t\t\tjQuery.isFunction( speed ) && speed,\n    \t\t\tduration: speed,\n    \t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n    \t\t};\n    \n    \t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n    \t\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n    \n    \t\t// normalize opt.queue - true/undefined/null -> \"fx\"\n    \t\tif ( opt.queue == null || opt.queue === true ) {\n    \t\t\topt.queue = \"fx\";\n    \t\t}\n    \n    \t\t// Queueing\n    \t\topt.old = opt.complete;\n    \n    \t\topt.complete = function( noUnmark ) {\n    \t\t\tif ( jQuery.isFunction( opt.old ) ) {\n    \t\t\t\topt.old.call( this );\n    \t\t\t}\n    \n    \t\t\tif ( opt.queue ) {\n    \t\t\t\tjQuery.dequeue( this, opt.queue );\n    \t\t\t} else if ( noUnmark !== false ) {\n    \t\t\t\tjQuery._unmark( this );\n    \t\t\t}\n    \t\t};\n    \n    \t\treturn opt;\n    \t},\n    \n    \teasing: {\n    \t\tlinear: function( p, n, firstNum, diff ) {\n    \t\t\treturn firstNum + diff * p;\n    \t\t},\n    \t\tswing: function( p, n, firstNum, diff ) {\n    \t\t\treturn ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;\n    \t\t}\n    \t},\n    \n    \ttimers: [],\n    \n    \tfx: function( elem, options, prop ) {\n    \t\tthis.options = options;\n    \t\tthis.elem = elem;\n    \t\tthis.prop = prop;\n    \n    \t\toptions.orig = options.orig || {};\n    \t}\n    \n    });\n    \n    jQuery.fx.prototype = {\n    \t// Simple function for setting a style value\n    \tupdate: function() {\n    \t\tif ( this.options.step ) {\n    \t\t\tthis.options.step.call( this.elem, this.now, this );\n    \t\t}\n    \n    \t\t( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );\n    \t},\n    \n    \t// Get the current size\n    \tcur: function() {\n    \t\tif ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {\n    \t\t\treturn this.elem[ this.prop ];\n    \t\t}\n    \n    \t\tvar parsed,\n    \t\t\tr = jQuery.css( this.elem, this.prop );\n    \t\t// Empty strings, null, undefined and \"auto\" are converted to 0,\n    \t\t// complex values such as \"rotate(1rad)\" are returned as is,\n    \t\t// simple values such as \"10px\" are parsed to Float.\n    \t\treturn isNaN( parsed = parseFloat( r ) ) ? !r || r === \"auto\" ? 0 : r : parsed;\n    \t},\n    \n    \t// Start an animation from one number to another\n    \tcustom: function( from, to, unit ) {\n    \t\tvar self = this,\n    \t\t\tfx = jQuery.fx;\n    \n    \t\tthis.startTime = fxNow || createFxNow();\n    \t\tthis.end = to;\n    \t\tthis.now = this.start = from;\n    \t\tthis.pos = this.state = 0;\n    \t\tthis.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? \"\" : \"px\" );\n    \n    \t\tfunction t( gotoEnd ) {\n    \t\t\treturn self.step( gotoEnd );\n    \t\t}\n    \n    \t\tt.queue = this.options.queue;\n    \t\tt.elem = this.elem;\n    \t\tt.saveState = function() {\n    \t\t\tif ( self.options.hide && jQuery._data( self.elem, \"fxshow\" + self.prop ) === undefined ) {\n    \t\t\t\tjQuery._data( self.elem, \"fxshow\" + self.prop, self.start );\n    \t\t\t}\n    \t\t};\n    \n    \t\tif ( t() && jQuery.timers.push(t) && !timerId ) {\n    \t\t\ttimerId = setInterval( fx.tick, fx.interval );\n    \t\t}\n    \t},\n    \n    \t// Simple 'show' function\n    \tshow: function() {\n    \t\tvar dataShow = jQuery._data( this.elem, \"fxshow\" + this.prop );\n    \n    \t\t// Remember where we started, so that we can go back to it later\n    \t\tthis.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );\n    \t\tthis.options.show = true;\n    \n    \t\t// Begin the animation\n    \t\t// Make sure that we start at a small width/height to avoid any flash of content\n    \t\tif ( dataShow !== undefined ) {\n    \t\t\t// This show is picking up where a previous hide or show left off\n    \t\t\tthis.custom( this.cur(), dataShow );\n    \t\t} else {\n    \t\t\tthis.custom( this.prop === \"width\" || this.prop === \"height\" ? 1 : 0, this.cur() );\n    \t\t}\n    \n    \t\t// Start by showing the element\n    \t\tjQuery( this.elem ).show();\n    \t},\n    \n    \t// Simple 'hide' function\n    \thide: function() {\n    \t\t// Remember where we started, so that we can go back to it later\n    \t\tthis.options.orig[ this.prop ] = jQuery._data( this.elem, \"fxshow\" + this.prop ) || jQuery.style( this.elem, this.prop );\n    \t\tthis.options.hide = true;\n    \n    \t\t// Begin the animation\n    \t\tthis.custom( this.cur(), 0 );\n    \t},\n    \n    \t// Each step of an animation\n    \tstep: function( gotoEnd ) {\n    \t\tvar p, n, complete,\n    \t\t\tt = fxNow || createFxNow(),\n    \t\t\tdone = true,\n    \t\t\telem = this.elem,\n    \t\t\toptions = this.options;\n    \n    \t\tif ( gotoEnd || t >= options.duration + this.startTime ) {\n    \t\t\tthis.now = this.end;\n    \t\t\tthis.pos = this.state = 1;\n    \t\t\tthis.update();\n    \n    \t\t\toptions.animatedProperties[ this.prop ] = true;\n    \n    \t\t\tfor ( p in options.animatedProperties ) {\n    \t\t\t\tif ( options.animatedProperties[ p ] !== true ) {\n    \t\t\t\t\tdone = false;\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\tif ( done ) {\n    \t\t\t\t// Reset the overflow\n    \t\t\t\tif ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {\n    \n    \t\t\t\t\tjQuery.each( [ \"\", \"X\", \"Y\" ], function( index, value ) {\n    \t\t\t\t\t\telem.style[ \"overflow\" + value ] = options.overflow[ index ];\n    \t\t\t\t\t});\n    \t\t\t\t}\n    \n    \t\t\t\t// Hide the element if the \"hide\" operation was done\n    \t\t\t\tif ( options.hide ) {\n    \t\t\t\t\tjQuery( elem ).hide();\n    \t\t\t\t}\n    \n    \t\t\t\t// Reset the properties, if the item has been hidden or shown\n    \t\t\t\tif ( options.hide || options.show ) {\n    \t\t\t\t\tfor ( p in options.animatedProperties ) {\n    \t\t\t\t\t\tjQuery.style( elem, p, options.orig[ p ] );\n    \t\t\t\t\t\tjQuery.removeData( elem, \"fxshow\" + p, true );\n    \t\t\t\t\t\t// Toggle data is no longer needed\n    \t\t\t\t\t\tjQuery.removeData( elem, \"toggle\" + p, true );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \n    \t\t\t\t// Execute the complete function\n    \t\t\t\t// in the event that the complete function throws an exception\n    \t\t\t\t// we must ensure it won't be called twice. #5684\n    \n    \t\t\t\tcomplete = options.complete;\n    \t\t\t\tif ( complete ) {\n    \n    \t\t\t\t\toptions.complete = false;\n    \t\t\t\t\tcomplete.call( elem );\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\treturn false;\n    \n    \t\t} else {\n    \t\t\t// classical easing cannot be used with an Infinity duration\n    \t\t\tif ( options.duration == Infinity ) {\n    \t\t\t\tthis.now = t;\n    \t\t\t} else {\n    \t\t\t\tn = t - this.startTime;\n    \t\t\t\tthis.state = n / options.duration;\n    \n    \t\t\t\t// Perform the easing function, defaults to swing\n    \t\t\t\tthis.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );\n    \t\t\t\tthis.now = this.start + ( (this.end - this.start) * this.pos );\n    \t\t\t}\n    \t\t\t// Perform the next step of the animation\n    \t\t\tthis.update();\n    \t\t}\n    \n    \t\treturn true;\n    \t}\n    };\n    \n    jQuery.extend( jQuery.fx, {\n    \ttick: function() {\n    \t\tvar timer,\n    \t\t\ttimers = jQuery.timers,\n    \t\t\ti = 0;\n    \n    \t\tfor ( ; i < timers.length; i++ ) {\n    \t\t\ttimer = timers[ i ];\n    \t\t\t// Checks the timer has not already been removed\n    \t\t\tif ( !timer() && timers[ i ] === timer ) {\n    \t\t\t\ttimers.splice( i--, 1 );\n    \t\t\t}\n    \t\t}\n    \n    \t\tif ( !timers.length ) {\n    \t\t\tjQuery.fx.stop();\n    \t\t}\n    \t},\n    \n    \tinterval: 13,\n    \n    \tstop: function() {\n    \t\tclearInterval( timerId );\n    \t\ttimerId = null;\n    \t},\n    \n    \tspeeds: {\n    \t\tslow: 600,\n    \t\tfast: 200,\n    \t\t// Default speed\n    \t\t_default: 400\n    \t},\n    \n    \tstep: {\n    \t\topacity: function( fx ) {\n    \t\t\tjQuery.style( fx.elem, \"opacity\", fx.now );\n    \t\t},\n    \n    \t\t_default: function( fx ) {\n    \t\t\tif ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {\n    \t\t\t\tfx.elem.style[ fx.prop ] = fx.now + fx.unit;\n    \t\t\t} else {\n    \t\t\t\tfx.elem[ fx.prop ] = fx.now;\n    \t\t\t}\n    \t\t}\n    \t}\n    });\n    \n    // Adds width/height step functions\n    // Do not set anything below 0\n    jQuery.each([ \"width\", \"height\" ], function( i, prop ) {\n    \tjQuery.fx.step[ prop ] = function( fx ) {\n    \t\tjQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );\n    \t};\n    });\n    \n    if ( jQuery.expr && jQuery.expr.filters ) {\n    \tjQuery.expr.filters.animated = function( elem ) {\n    \t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n    \t\t\treturn elem === fn.elem;\n    \t\t}).length;\n    \t};\n    }\n    \n    // Try to restore the default display value of an element\n    function defaultDisplay( nodeName ) {\n    \n    \tif ( !elemdisplay[ nodeName ] ) {\n    \n    \t\tvar body = document.body,\n    \t\t\telem = jQuery( \"<\" + nodeName + \">\" ).appendTo( body ),\n    \t\t\tdisplay = elem.css( \"display\" );\n    \t\telem.remove();\n    \n    \t\t// If the simple way fails,\n    \t\t// get element's real default display by attaching it to a temp iframe\n    \t\tif ( display === \"none\" || display === \"\" ) {\n    \t\t\t// No iframe to use yet, so create it\n    \t\t\tif ( !iframe ) {\n    \t\t\t\tiframe = document.createElement( \"iframe\" );\n    \t\t\t\tiframe.frameBorder = iframe.width = iframe.height = 0;\n    \t\t\t}\n    \n    \t\t\tbody.appendChild( iframe );\n    \n    \t\t\t// Create a cacheable copy of the iframe document on first call.\n    \t\t\t// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML\n    \t\t\t// document to it; WebKit & Firefox won't allow reusing the iframe document.\n    \t\t\tif ( !iframeDoc || !iframe.createElement ) {\n    \t\t\t\tiframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;\n    \t\t\t\tiframeDoc.write( ( document.compatMode === \"CSS1Compat\" ? \"<!doctype html>\" : \"\" ) + \"<html><body>\" );\n    \t\t\t\tiframeDoc.close();\n    \t\t\t}\n    \n    \t\t\telem = iframeDoc.createElement( nodeName );\n    \n    \t\t\tiframeDoc.body.appendChild( elem );\n    \n    \t\t\tdisplay = jQuery.css( elem, \"display\" );\n    \t\t\tbody.removeChild( iframe );\n    \t\t}\n    \n    \t\t// Store the correct default display\n    \t\telemdisplay[ nodeName ] = display;\n    \t}\n    \n    \treturn elemdisplay[ nodeName ];\n    }\n    \n    \n    \n    \n    var rtable = /^t(?:able|d|h)$/i,\n    \trroot = /^(?:body|html)$/i;\n    \n    if ( \"getBoundingClientRect\" in document.documentElement ) {\n    \tjQuery.fn.offset = function( options ) {\n    \t\tvar elem = this[0], box;\n    \n    \t\tif ( options ) {\n    \t\t\treturn this.each(function( i ) {\n    \t\t\t\tjQuery.offset.setOffset( this, options, i );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( !elem || !elem.ownerDocument ) {\n    \t\t\treturn null;\n    \t\t}\n    \n    \t\tif ( elem === elem.ownerDocument.body ) {\n    \t\t\treturn jQuery.offset.bodyOffset( elem );\n    \t\t}\n    \n    \t\ttry {\n    \t\t\tbox = elem.getBoundingClientRect();\n    \t\t} catch(e) {}\n    \n    \t\tvar doc = elem.ownerDocument,\n    \t\t\tdocElem = doc.documentElement;\n    \n    \t\t// Make sure we're not dealing with a disconnected DOM node\n    \t\tif ( !box || !jQuery.contains( docElem, elem ) ) {\n    \t\t\treturn box ? { top: box.top, left: box.left } : { top: 0, left: 0 };\n    \t\t}\n    \n    \t\tvar body = doc.body,\n    \t\t\twin = getWindow(doc),\n    \t\t\tclientTop  = docElem.clientTop  || body.clientTop  || 0,\n    \t\t\tclientLeft = docElem.clientLeft || body.clientLeft || 0,\n    \t\t\tscrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,\n    \t\t\tscrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,\n    \t\t\ttop  = box.top  + scrollTop  - clientTop,\n    \t\t\tleft = box.left + scrollLeft - clientLeft;\n    \n    \t\treturn { top: top, left: left };\n    \t};\n    \n    } else {\n    \tjQuery.fn.offset = function( options ) {\n    \t\tvar elem = this[0];\n    \n    \t\tif ( options ) {\n    \t\t\treturn this.each(function( i ) {\n    \t\t\t\tjQuery.offset.setOffset( this, options, i );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( !elem || !elem.ownerDocument ) {\n    \t\t\treturn null;\n    \t\t}\n    \n    \t\tif ( elem === elem.ownerDocument.body ) {\n    \t\t\treturn jQuery.offset.bodyOffset( elem );\n    \t\t}\n    \n    \t\tvar computedStyle,\n    \t\t\toffsetParent = elem.offsetParent,\n    \t\t\tprevOffsetParent = elem,\n    \t\t\tdoc = elem.ownerDocument,\n    \t\t\tdocElem = doc.documentElement,\n    \t\t\tbody = doc.body,\n    \t\t\tdefaultView = doc.defaultView,\n    \t\t\tprevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,\n    \t\t\ttop = elem.offsetTop,\n    \t\t\tleft = elem.offsetLeft;\n    \n    \t\twhile ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {\n    \t\t\tif ( jQuery.support.fixedPosition && prevComputedStyle.position === \"fixed\" ) {\n    \t\t\t\tbreak;\n    \t\t\t}\n    \n    \t\t\tcomputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;\n    \t\t\ttop  -= elem.scrollTop;\n    \t\t\tleft -= elem.scrollLeft;\n    \n    \t\t\tif ( elem === offsetParent ) {\n    \t\t\t\ttop  += elem.offsetTop;\n    \t\t\t\tleft += elem.offsetLeft;\n    \n    \t\t\t\tif ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {\n    \t\t\t\t\ttop  += parseFloat( computedStyle.borderTopWidth  ) || 0;\n    \t\t\t\t\tleft += parseFloat( computedStyle.borderLeftWidth ) || 0;\n    \t\t\t\t}\n    \n    \t\t\t\tprevOffsetParent = offsetParent;\n    \t\t\t\toffsetParent = elem.offsetParent;\n    \t\t\t}\n    \n    \t\t\tif ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== \"visible\" ) {\n    \t\t\t\ttop  += parseFloat( computedStyle.borderTopWidth  ) || 0;\n    \t\t\t\tleft += parseFloat( computedStyle.borderLeftWidth ) || 0;\n    \t\t\t}\n    \n    \t\t\tprevComputedStyle = computedStyle;\n    \t\t}\n    \n    \t\tif ( prevComputedStyle.position === \"relative\" || prevComputedStyle.position === \"static\" ) {\n    \t\t\ttop  += body.offsetTop;\n    \t\t\tleft += body.offsetLeft;\n    \t\t}\n    \n    \t\tif ( jQuery.support.fixedPosition && prevComputedStyle.position === \"fixed\" ) {\n    \t\t\ttop  += Math.max( docElem.scrollTop, body.scrollTop );\n    \t\t\tleft += Math.max( docElem.scrollLeft, body.scrollLeft );\n    \t\t}\n    \n    \t\treturn { top: top, left: left };\n    \t};\n    }\n    \n    jQuery.offset = {\n    \n    \tbodyOffset: function( body ) {\n    \t\tvar top = body.offsetTop,\n    \t\t\tleft = body.offsetLeft;\n    \n    \t\tif ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {\n    \t\t\ttop  += parseFloat( jQuery.css(body, \"marginTop\") ) || 0;\n    \t\t\tleft += parseFloat( jQuery.css(body, \"marginLeft\") ) || 0;\n    \t\t}\n    \n    \t\treturn { top: top, left: left };\n    \t},\n    \n    \tsetOffset: function( elem, options, i ) {\n    \t\tvar position = jQuery.css( elem, \"position\" );\n    \n    \t\t// set position first, in-case top/left are set even on static elem\n    \t\tif ( position === \"static\" ) {\n    \t\t\telem.style.position = \"relative\";\n    \t\t}\n    \n    \t\tvar curElem = jQuery( elem ),\n    \t\t\tcurOffset = curElem.offset(),\n    \t\t\tcurCSSTop = jQuery.css( elem, \"top\" ),\n    \t\t\tcurCSSLeft = jQuery.css( elem, \"left\" ),\n    \t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n    \t\t\tprops = {}, curPosition = {}, curTop, curLeft;\n    \n    \t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n    \t\tif ( calculatePosition ) {\n    \t\t\tcurPosition = curElem.position();\n    \t\t\tcurTop = curPosition.top;\n    \t\t\tcurLeft = curPosition.left;\n    \t\t} else {\n    \t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n    \t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n    \t\t}\n    \n    \t\tif ( jQuery.isFunction( options ) ) {\n    \t\t\toptions = options.call( elem, i, curOffset );\n    \t\t}\n    \n    \t\tif ( options.top != null ) {\n    \t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n    \t\t}\n    \t\tif ( options.left != null ) {\n    \t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n    \t\t}\n    \n    \t\tif ( \"using\" in options ) {\n    \t\t\toptions.using.call( elem, props );\n    \t\t} else {\n    \t\t\tcurElem.css( props );\n    \t\t}\n    \t}\n    };\n    \n    \n    jQuery.fn.extend({\n    \n    \tposition: function() {\n    \t\tif ( !this[0] ) {\n    \t\t\treturn null;\n    \t\t}\n    \n    \t\tvar elem = this[0],\n    \n    \t\t// Get *real* offsetParent\n    \t\toffsetParent = this.offsetParent(),\n    \n    \t\t// Get correct offsets\n    \t\toffset       = this.offset(),\n    \t\tparentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();\n    \n    \t\t// Subtract element margins\n    \t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n    \t\t// are the same in Safari causing offset.left to incorrectly be 0\n    \t\toffset.top  -= parseFloat( jQuery.css(elem, \"marginTop\") ) || 0;\n    \t\toffset.left -= parseFloat( jQuery.css(elem, \"marginLeft\") ) || 0;\n    \n    \t\t// Add offsetParent borders\n    \t\tparentOffset.top  += parseFloat( jQuery.css(offsetParent[0], \"borderTopWidth\") ) || 0;\n    \t\tparentOffset.left += parseFloat( jQuery.css(offsetParent[0], \"borderLeftWidth\") ) || 0;\n    \n    \t\t// Subtract the two offsets\n    \t\treturn {\n    \t\t\ttop:  offset.top  - parentOffset.top,\n    \t\t\tleft: offset.left - parentOffset.left\n    \t\t};\n    \t},\n    \n    \toffsetParent: function() {\n    \t\treturn this.map(function() {\n    \t\t\tvar offsetParent = this.offsetParent || document.body;\n    \t\t\twhile ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, \"position\") === \"static\") ) {\n    \t\t\t\toffsetParent = offsetParent.offsetParent;\n    \t\t\t}\n    \t\t\treturn offsetParent;\n    \t\t});\n    \t}\n    });\n    \n    \n    // Create scrollLeft and scrollTop methods\n    jQuery.each( [\"Left\", \"Top\"], function( i, name ) {\n    \tvar method = \"scroll\" + name;\n    \n    \tjQuery.fn[ method ] = function( val ) {\n    \t\tvar elem, win;\n    \n    \t\tif ( val === undefined ) {\n    \t\t\telem = this[ 0 ];\n    \n    \t\t\tif ( !elem ) {\n    \t\t\t\treturn null;\n    \t\t\t}\n    \n    \t\t\twin = getWindow( elem );\n    \n    \t\t\t// Return the scroll offset\n    \t\t\treturn win ? (\"pageXOffset\" in win) ? win[ i ? \"pageYOffset\" : \"pageXOffset\" ] :\n    \t\t\t\tjQuery.support.boxModel && win.document.documentElement[ method ] ||\n    \t\t\t\t\twin.document.body[ method ] :\n    \t\t\t\telem[ method ];\n    \t\t}\n    \n    \t\t// Set the scroll offset\n    \t\treturn this.each(function() {\n    \t\t\twin = getWindow( this );\n    \n    \t\t\tif ( win ) {\n    \t\t\t\twin.scrollTo(\n    \t\t\t\t\t!i ? val : jQuery( win ).scrollLeft(),\n    \t\t\t\t\t i ? val : jQuery( win ).scrollTop()\n    \t\t\t\t);\n    \n    \t\t\t} else {\n    \t\t\t\tthis[ method ] = val;\n    \t\t\t}\n    \t\t});\n    \t};\n    });\n    \n    function getWindow( elem ) {\n    \treturn jQuery.isWindow( elem ) ?\n    \t\telem :\n    \t\telem.nodeType === 9 ?\n    \t\t\telem.defaultView || elem.parentWindow :\n    \t\t\tfalse;\n    }\n    \n    \n    \n    \n    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods\n    jQuery.each([ \"Height\", \"Width\" ], function( i, name ) {\n    \n    \tvar type = name.toLowerCase();\n    \n    \t// innerHeight and innerWidth\n    \tjQuery.fn[ \"inner\" + name ] = function() {\n    \t\tvar elem = this[0];\n    \t\treturn elem ?\n    \t\t\telem.style ?\n    \t\t\tparseFloat( jQuery.css( elem, type, \"padding\" ) ) :\n    \t\t\tthis[ type ]() :\n    \t\t\tnull;\n    \t};\n    \n    \t// outerHeight and outerWidth\n    \tjQuery.fn[ \"outer\" + name ] = function( margin ) {\n    \t\tvar elem = this[0];\n    \t\treturn elem ?\n    \t\t\telem.style ?\n    \t\t\tparseFloat( jQuery.css( elem, type, margin ? \"margin\" : \"border\" ) ) :\n    \t\t\tthis[ type ]() :\n    \t\t\tnull;\n    \t};\n    \n    \tjQuery.fn[ type ] = function( size ) {\n    \t\t// Get window width or height\n    \t\tvar elem = this[0];\n    \t\tif ( !elem ) {\n    \t\t\treturn size == null ? null : this;\n    \t\t}\n    \n    \t\tif ( jQuery.isFunction( size ) ) {\n    \t\t\treturn this.each(function( i ) {\n    \t\t\t\tvar self = jQuery( this );\n    \t\t\t\tself[ type ]( size.call( this, i, self[ type ]() ) );\n    \t\t\t});\n    \t\t}\n    \n    \t\tif ( jQuery.isWindow( elem ) ) {\n    \t\t\t// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode\n    \t\t\t// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat\n    \t\t\tvar docElemProp = elem.document.documentElement[ \"client\" + name ],\n    \t\t\t\tbody = elem.document.body;\n    \t\t\treturn elem.document.compatMode === \"CSS1Compat\" && docElemProp ||\n    \t\t\t\tbody && body[ \"client\" + name ] || docElemProp;\n    \n    \t\t// Get document width or height\n    \t\t} else if ( elem.nodeType === 9 ) {\n    \t\t\t// Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n    \t\t\treturn Math.max(\n    \t\t\t\telem.documentElement[\"client\" + name],\n    \t\t\t\telem.body[\"scroll\" + name], elem.documentElement[\"scroll\" + name],\n    \t\t\t\telem.body[\"offset\" + name], elem.documentElement[\"offset\" + name]\n    \t\t\t);\n    \n    \t\t// Get or set width or height on the element\n    \t\t} else if ( size === undefined ) {\n    \t\t\tvar orig = jQuery.css( elem, type ),\n    \t\t\t\tret = parseFloat( orig );\n    \n    \t\t\treturn jQuery.isNumeric( ret ) ? ret : orig;\n    \n    \t\t// Set the width or height on the element (default to pixels if value is unitless)\n    \t\t} else {\n    \t\t\treturn this.css( type, typeof size === \"string\" ? size : size + \"px\" );\n    \t\t}\n    \t};\n    \n    });\n    \n    \n    \n    \n    // Expose jQuery to the global object\n    window.jQuery = window.$ = jQuery;\n    \n    // Expose jQuery as an AMD module, but only for AMD loaders that\n    // understand the issues with loading multiple versions of jQuery\n    // in a page that all might call define(). The loader will indicate\n    // they have special allowances for multiple jQuery versions by\n    // specifying define.amd.jQuery = true. Register as a named module,\n    // since jQuery can be concatenated with other files that may use define,\n    // but not use a proper concatenation script that understands anonymous\n    // AMD modules. A named AMD is safest and most robust way to register.\n    // Lowercase jquery is used because AMD module names are derived from\n    // file names, and jQuery is normally delivered in a lowercase file name.\n    // Do this after creating the global so that if an AMD module wants to call\n    // noConflict to hide this version of jQuery, it will work.\n    if ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n    \tdefine( \"jquery\", [], function () { return jQuery; } );\n    }\n    \n    \n    \n    })( window );\n\n    return noConflictMode ? window.jQuery.noConflict(true) : window.jQuery;\n  };\n\n  // For CommonJS\n  if (typeof module !== 'undefined') {\n    if (typeof window !== 'undefined') {\n      module.exports = create(window, true);\n    }\n    module.exports.create = create;\n\n  // For non-CommonJS\n  } else {\n    create(window, false);\n  }\n\n}());\n\n}).call(this);}\n});","mtime":1384435896717,"type":"commonjs","path":"npm://commonjs-jquery"},"jquery":{"name":"jquery","sources":"\n\n/*ZB:  */\nrequire.define('', {\n\n/*ZB:  /jquery */\n'jquery': function(exports, require, module) {(function() {\n(function() {\n  module.exports = require('commonjs-jquery');\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435525872,"type":"commonjs","path":"jquery.coffee"},"dom-mutation-observer":{"name":"dom-mutation-observer","sources":"\n\n/*ZB: dom-mutation-observer */\nrequire.define('dom-mutation-observer', {\n\n/*ZB:  dom-mutation-observer/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var $, MutationObserver, debug, dispatch_impl, error, ie_version, info, isDOMAttrModifiedSupported, nullog, observe, observe_dom_added, pubsubhub, root, warn, _ref,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  root = window;\n\n  $ = require('jquery');\n\n  pubsubhub = require('libprotein').pubsubhub;\n\n  dispatch_impl = require('libprotocol').dispatch_impl;\n\n  _ref = dispatch_impl('ILogger', 'MutationObserver'), info = _ref.info, warn = _ref.warn, error = _ref.error, debug = _ref.debug, nullog = _ref.nullog;\n\n  ie_version = function() {\n    var myNav;\n\n    myNav = root.navigator.userAgent.toLowerCase();\n    if (__indexOf.call(myNav, \"msie\") >= 0) {\n      return parseInt(myNav.split('msie')[1]);\n    } else {\n      return false;\n    }\n  };\n\n  MutationObserver = root.MutationObserver || root.WebKitMutationObserver || root.MozMutationObserver;\n\n  isDOMAttrModifiedSupported = (function() {\n    var flag, p;\n\n    p = root.document.createElement('p');\n    flag = false;\n    if (p.addEventListener) {\n      p.addEventListener('DOMAttrModified', function() {\n        return flag = true;\n      }, false);\n    } else if (p.attachEvent) {\n      p.attachEvent('onDOMAttrModified', function() {\n        return flag = true;\n      });\n    } else {\n      return false;\n    }\n    p.setAttribute('id', 'target');\n    return flag;\n  })();\n\n  observe = function(node, opts, handler) {\n    var observer;\n\n    if (MutationObserver) {\n      observer = new MutationObserver(function(mutations) {\n        return mutations.map(function(e) {\n          return handler(e.target, e.attributeName);\n        });\n      });\n      return observer.observe(node, {\n        attributes: true,\n        subtree: opts.subtree\n      });\n    } else if (isDOMAttrModifiedSupported) {\n      return ($(node)).bind('DOMAttrModified', function(e) {\n        return handler(this, e.attrName);\n      });\n    } else if (__indexOf.call(root.document.body, 'onpropertychange') >= 0) {\n      return ($(node)).bind('propertychange', function(e) {\n        return handler(this, root.event.propertyName);\n      });\n    } else {\n      throw \"DOM Mutation Observer not available\";\n    }\n  };\n\n  observe_dom_added = function(root_node, cont) {\n    var dom_parser, e, get_wrapper, is_ie, patch, pub, sub, _ref1;\n\n    is_ie = ie_version();\n    if (is_ie && is_ie < 9) {\n      _ref1 = pubsubhub(), pub = _ref1.pub, sub = _ref1.sub;\n      get_wrapper = function(orig_fn_name) {\n        return function() {\n          var args, ret;\n\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          ret = this[orig_fn_name].apply(this, args);\n          debug.apply(null, [\"Patched call: \" + orig_fn_name + \" with args:\"].concat(__slice.call(args)));\n          setTimeout(function() {\n            return pub.apply(null, ['node_changed'].concat(__slice.call(args)));\n          }, 0);\n          return ret;\n        };\n      };\n      patch = function(o, fn_name) {\n        var orig_fn_name;\n\n        orig_fn_name = '_' + fn_name;\n        o.prototype[orig_fn_name] = o.prototype[fn_name];\n        return o.prototype[fn_name] = get_wrapper(orig_fn_name);\n      };\n      try {\n        ['appendChild', 'insertChild', 'replaceChild', 'cloneNode', 'insertBefore'].map(function(fn_name) {\n          return patch(Element, fn_name);\n        });\n      } catch (_error) {\n        e = _error;\n        error(\"Can't init dom observer, don't use IE7\");\n      }\n      return sub('node_changed', function() {\n        var node, _arg;\n\n        _arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        node = _arg[0];\n        return cont(node);\n      });\n    } else {\n      dom_parser = dispatch_impl('IDom', root_node);\n      return dom_parser.add_event_listener(\"DOMNodeInserted\", function(event) {\n        return cont(event.target);\n      });\n    }\n  };\n\n  module.exports = {\n    observe: observe,\n    observe_dom_added: observe_dom_added\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435899059,"type":"commonjs","path":"npm://dom-mutation-observer@0.0.4"},"event-channel":{"name":"event-channel","sources":"\n\n/*ZB: event-channel */\nrequire.define('event-channel', {\n\n/*ZB:  event-channel/index */\n'index': function(exports, require, module) {(function() {\nmodule.exports = require('lib-js/ev_channel')\n}).call(this);},\n\n/*ZB:  event-channel/lib-js/ev_channel */\n'lib-js/ev_channel': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var Emitter, emitter,\n    __slice = [].slice;\n\n  Emitter = function() {\n    var callbacks, callbacks_map, pub, sub, unsub;\n\n    callbacks = {};\n    sub = function(ev, callback) {\n      var calls, evs, name, _i, _len, _results;\n\n      evs = ev.split(' ');\n      calls = callbacks;\n      _results = [];\n      for (_i = 0, _len = evs.length; _i < _len; _i++) {\n        name = evs[_i];\n        callbacks[name] || (callbacks[name] = []);\n        _results.push(callbacks[name].push(callback));\n      }\n      return _results;\n    };\n    pub = function() {\n      var args, callback, ev, _i, _len, _ref;\n\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      ev = args.shift();\n      if (!callbacks[ev]) {\n        return;\n      }\n      _ref = callbacks[ev];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        callback = _ref[_i];\n        if (callback.apply(null, args) === false) {\n          break;\n        }\n      }\n      return true;\n    };\n    unsub = function(ev, callback) {\n      var cb, evs, i, list, name, _i, _len, _results;\n\n      evs = ev.split(' ');\n      _results = [];\n      for (_i = 0, _len = evs.length; _i < _len; _i++) {\n        name = evs[_i];\n        list = callbacks[name];\n        if (!list) {\n          continue;\n        }\n        if (!callback) {\n          delete callbacks[name];\n          continue;\n        }\n        _results.push((function() {\n          var _j, _len1, _results1;\n\n          _results1 = [];\n          for (i = _j = 0, _len1 = list.length; _j < _len1; i = ++_j) {\n            cb = list[i];\n            if (!(cb === callback)) {\n              continue;\n            }\n            list = list.slice();\n            list.splice(i, 1);\n            callbacks[name] = list;\n            break;\n          }\n          return _results1;\n        })());\n      }\n      return _results;\n    };\n    callbacks_map = function() {\n      return callbacks;\n    };\n    return {\n      sub: sub,\n      pub: pub,\n      unsub: unsub,\n      callbacks_map: callbacks_map\n    };\n  };\n\n  emitter = new Emitter();\n\n  module.exports = {\n    emitter: emitter,\n    Emitter: Emitter\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435896703,"type":"commonjs","path":"npm://event-channel"},"dna-event-channel":{"name":"dna-event-channel","sources":"\n\n/*ZB: dna-event-channel */\nrequire.define('dna-event-channel', {\n\n/*ZB:  dna-event-channel/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var emitter, ev_channel_impl, ev_channel_protocol;\n\n  emitter = require('event-channel').emitter;\n\n  ev_channel_protocol = [['pub', ['ev', 'args']], ['sub', ['ev', 'handler']]];\n\n  ev_channel_impl = function() {\n    return {\n      pub: function(ev, args) {\n        return emitter.pub(ev, args);\n      },\n      sub: function(ev, handler) {\n        if (ev instanceof Function) {\n          return emitter.sub(ev(), handler);\n        } else {\n          return emitter.sub(ev, handler);\n        }\n      }\n    };\n  };\n\n  module.exports = {\n    protocols: {\n      definitions: {\n        EventChannel: ev_channel_protocol\n      },\n      implementations: {\n        EventChannel: ev_channel_impl\n      }\n    }\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435898701,"type":"commonjs","path":"npm://dna-event-channel"},"libprotein":{"name":"libprotein","sources":"\n\n/*ZB: libprotein */\nrequire.define('libprotein', {\n\n/*ZB:  libprotein/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var X,\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  X = {\n    partial: function() {\n      var f, partial_args, y;\n\n      f = arguments[0], partial_args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      y = function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return f.apply(null, partial_args.concat(args));\n      };\n      return X.metabolize(f, y);\n    },\n    complement: function(f) {\n      return function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return !(f.apply(null, args));\n      };\n    },\n    compose2: function(f, g) {\n      return function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return f(g.apply(null, args));\n      };\n    },\n    compose3: function(f, g, h) {\n      return function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return f(g(h.apply(null, args)));\n      };\n    },\n    first: function(s) {\n      return s[0];\n    },\n    identity: function(x) {\n      return x;\n    },\n    drop_while: function(f, s) {\n      var i, _i, _len;\n\n      for (_i = 0, _len = s.length; _i < _len; _i++) {\n        i = s[_i];\n        if (!(f(i))) {\n          return i;\n        }\n      }\n    },\n    is_function: function(v) {\n      return typeof v === 'function';\n    },\n    is_array: function(v) {\n      return Array.isArray(v);\n    },\n    is_object: function(v) {\n      if (X.is_array(v)) {\n        return false;\n      } else {\n        return v instanceof {}.constructor;\n      }\n    },\n    is_nan: function(v) {\n      return v !== v;\n    },\n    is_string: function(v) {\n      return typeof v === 'string';\n    },\n    bool: function(v) {\n      if (X.is_array(v)) {\n        return !!v.length;\n      } else if (X.is_object(v)) {\n        return !!(Object.keys(v).length);\n      } else {\n        return !!v;\n      }\n    },\n    and_: function() {\n      var args;\n\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return args.reduce(function(a, b) {\n        return (X.bool(a)) && (X.bool(b));\n      }, true);\n    },\n    or_: function() {\n      var args;\n\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return args.reduce(function(a, b) {\n        return (X.bool(a)) || (X.bool(b));\n      }, false);\n    },\n    to_hash: function(list_of_tuples) {\n      var h;\n\n      h = {};\n      list_of_tuples.map(function(_arg) {\n        var k, v;\n\n        k = _arg[0], v = _arg[1];\n        return h[k] = v;\n      });\n      return h;\n    },\n    metabolize: function(f, g) {\n      g.meta = f.meta;\n      return g;\n    },\n    data_to_opts: function(sufx, node) {\n      var $node, keys;\n\n      $node = jQuery(node);\n      if ($node.data()) {\n        keys = Object.keys($node.data());\n        return X.to_hash(keys.filter(function(key) {\n          return key.slice(0, sufx.length) === sufx;\n        }).map(function(key) {\n          return [key.slice(sufx.length), $node.data(key)];\n        }));\n      } else {\n        return {};\n      }\n    },\n    add2: function(a, b) {\n      var k, ret, v;\n\n      if ((X.is_array(a)) && (X.is_array(b))) {\n        return a.concat(b);\n      } else if ((X.is_object(a)) && (X.is_object(b))) {\n        ret = {};\n        for (k in a) {\n          if (!__hasProp.call(a, k)) continue;\n          v = a[k];\n          ret[k] = v;\n        }\n        for (k in b) {\n          if (!__hasProp.call(b, k)) continue;\n          v = b[k];\n          ret[k] = v;\n        }\n        return ret;\n      } else {\n        return a + b;\n      }\n    },\n    add: function() {\n      var values;\n\n      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return values.reduce(function(a, b) {\n        return X.add2(a, b);\n      });\n    },\n    pubsubhub: function() {\n      return (function() {\n        var q;\n\n        q = {};\n        return {\n          sub: function(name, f) {\n            q[name] || (q[name] = []);\n            return q[name].push(f);\n          },\n          pub: function() {\n            var data, name, _ref;\n\n            name = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n            return (_ref = q[name]) != null ? _ref.map(function(f) {\n              return f.apply(null, data);\n            }) : void 0;\n          },\n          unsub: function(name, f) {\n            if (q[name]) {\n              return q[name] = q[name].filter(function(s) {\n                return s !== f;\n              });\n            }\n          },\n          unsuball: function(name) {\n            if (q[name]) {\n              return q[name] = [];\n            }\n          }\n        };\n      })();\n    },\n    distinct: function(list) {\n      var i, k, t, v, _i, _len, _results;\n\n      t = {};\n      for (_i = 0, _len = list.length; _i < _len; _i++) {\n        i = list[_i];\n        t[i] = i;\n      }\n      _results = [];\n      for (k in t) {\n        v = t[k];\n        _results.push(v);\n      }\n      return _results;\n    },\n    repeat: function(v, n) {\n      var i, _i, _results;\n\n      _results = [];\n      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n        _results.push(v);\n      }\n      return _results;\n    },\n    make_lambda: function(expression) {\n      var expr;\n\n      if (expression === \"\" || expression === null) {\n        return X.identity;\n      } else if ((expression.indexOf(\"=>\")) === -1) {\n        return new Function(\"_,__,___,____\", \"return \" + expression);\n      } else {\n        expr = expression.match(/^[(\\s]*([^()]*?)[)\\s]*=>(.*)/);\n        return new Function(expr[1], \"return \" + expr[2]);\n      }\n    },\n    urlencode: function(d) {\n      var k, v;\n\n      return ((function() {\n        var _results;\n\n        _results = [];\n        for (k in d) {\n          v = d[k];\n          _results.push(\"\" + (encodeURIComponent(k)) + \"=\" + (encodeURIComponent(v)));\n        }\n        return _results;\n      })()).join('&');\n    },\n    add_params_to_url: function(url, params) {\n      var has_params, start_char;\n\n      has_params = (url.indexOf('?')) > -1;\n      start_char = has_params ? '&' : '?';\n      return url + start_char + (X.urlencode(params));\n    },\n    zip: function(one, two) {\n      var i, _i, _ref, _results;\n\n      _results = [];\n      for (i = _i = 0, _ref = Math.min(one.length, two.length); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n        _results.push([one[i], two[i]]);\n      }\n      return _results;\n    }\n  };\n\n  module.exports = X;\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435896722,"type":"commonjs","path":"npm://libprotein@0.0.79"},"libprotocol":{"name":"libprotocol","sources":"\n\n/*ZB: libprotocol */\nrequire.define('libprotocol', {\n\n/*ZB:  libprotocol/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var CONS, PROTO, THIS, debug, discover_protocols, dispatch_impl, dump_impls, error, get_arity, get_meta, get_meta_key, get_method, get_protocol, info, is_array, is_async, is_vararg, partial, register_protocol, register_protocol_impl, warn, _ref, _ref1,\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  _ref = require('console-logger'), info = _ref.info, warn = _ref.warn, error = _ref.error, debug = _ref.debug;\n\n  PROTO = {\n    Implementations: {},\n    Protocols: {}\n  };\n\n  THIS = 'this';\n\n  CONS = '*cons*';\n\n  _ref1 = require('libprotein'), partial = _ref1.partial, is_array = _ref1.is_array;\n\n  get_protocol = function(p) {\n    if (PROTO.Protocols.hasOwnProperty(p)) {\n      return PROTO.Protocols[p];\n    } else {\n      throw \"No such registered protocol: '\" + p + \"'\";\n    }\n  };\n\n  register_protocol = function(name, p) {\n    if (!PROTO.Protocols.hasOwnProperty(p)) {\n      return PROTO.Protocols[name] = p;\n    } else {\n      throw \"Such protocol is already registered: '\" + name + \"'\";\n    }\n  };\n\n  get_method = function(ns, method_name) {\n    var m, _ref2;\n\n    m = (_ref2 = PROTO.Protocols[ns]) != null ? _ref2.filter(function(_arg) {\n      var mn;\n\n      mn = _arg[0];\n      return mn === method_name;\n    }) : void 0;\n    if (m.length === 1) {\n      return m[0];\n    } else {\n      error(\"No such method:\", ns, method_name);\n      throw \"No such method\";\n    }\n  };\n\n  get_meta = function(ns, method_name) {\n    var meta, _, _ref2;\n\n    _ref2 = get_method(ns, method_name), _ = _ref2[0], _ = _ref2[1], meta = _ref2[2];\n    return meta || {};\n  };\n\n  get_meta_key = function(prop, ns, method_name) {\n    return (get_meta(ns, method_name))[prop];\n  };\n\n  is_async = partial(get_meta_key, 'async');\n\n  is_vararg = partial(get_meta_key, 'vararg');\n\n  get_arity = function(ns, method_name) {\n    var argums, _, _ref2;\n\n    _ref2 = get_method(ns, method_name), _ = _ref2[0], argums = _ref2[1], _ = 3 <= _ref2.length ? __slice.call(_ref2, 2) : [];\n    return argums.length;\n  };\n\n  register_protocol_impl = function(protocol, impl) {\n    if (!get_protocol(protocol)) {\n      throw \"Can't register implementation for an unknown protocol: '\" + protocol + \"'\";\n    }\n    if (!PROTO.Implementations.hasOwnProperty(protocol)) {\n\n    } else {\n\n    }\n    return PROTO.Implementations[protocol] = impl;\n  };\n\n  discover_protocols = function() {\n    var definition, e, exports, impl, modname, modules, protocol, _ref2, _ref3, _ref4, _results;\n\n    modules = (function() {\n      try {\n        return require.modules();\n      } catch (_error) {\n        e = _error;\n        return window.bootstrapper.modules;\n      }\n    })();\n    _results = [];\n    for (modname in modules) {\n      exports = require(modname);\n      if ((_ref2 = exports.protocols) != null ? _ref2.definitions : void 0) {\n        _ref3 = exports.protocols.definitions;\n        for (protocol in _ref3) {\n          definition = _ref3[protocol];\n          register_protocol(protocol, definition);\n        }\n      }\n      if ((_ref4 = exports.protocols) != null ? _ref4.implementations : void 0) {\n        _results.push((function() {\n          var _ref5, _results1;\n\n          _ref5 = exports.protocols.implementations;\n          _results1 = [];\n          for (protocol in _ref5) {\n            impl = _ref5[protocol];\n            _results1.push(register_protocol_impl(protocol, impl));\n          }\n          return _results1;\n        })());\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  dispatch_impl = function(protocol, opts) {\n    var concerns, cons, f, fun, k, meta, name, q, v, xopts, _i, _len, _ref2, _ref3, _ref4;\n\n    if (opts == null) {\n      opts = void 0;\n    }\n    if (!(PROTO.Protocols[protocol] && PROTO.Implementations[protocol])) {\n      discover_protocols();\n    }\n    if (PROTO.Protocols[protocol] && PROTO.Implementations[protocol]) {\n      cons = PROTO.Protocols[protocol].filter(function(m) {\n        return m[0] === CONS;\n      })[0];\n      if (cons) {\n        meta = get_meta(protocol, CONS);\n        if ((_ref2 = meta.concerns) != null ? _ref2.before : void 0) {\n          concerns = is_array(meta.concerns.before) ? meta.concerns.before : [meta.concerns.before];\n          xopts = [opts];\n          for (_i = 0, _len = concerns.length; _i < _len; _i++) {\n            f = concerns[_i];\n            xopts.push(f.apply(null, xopts));\n          }\n          opts = xopts;\n        }\n      }\n      q = (_ref3 = PROTO.Implementations)[protocol].apply(_ref3, (is_array(opts) ? opts : [opts]));\n      for (name in q) {\n        if (!__hasProp.call(q, name)) continue;\n        fun = q[name];\n        fun.meta || (fun.meta = {});\n        fun.meta.name = name;\n        fun.meta.protocol = protocol;\n        fun.meta.arity = get_arity(protocol, name);\n        _ref4 = get_meta(protocol, name);\n        for (k in _ref4) {\n          v = _ref4[k];\n          fun.meta[k] = v;\n        }\n      }\n      return q;\n    } else {\n      debug(\"Cant find implementations for protocol \" + protocol);\n      return null;\n    }\n  };\n\n  dump_impls = function() {\n    return debug(\"Currently registered PROTO.Implementations:\", PROTO.Implementations);\n  };\n\n  module.exports = {\n    register_protocol_impl: register_protocol_impl,\n    register_protocol: register_protocol,\n    get_protocol: get_protocol,\n    dispatch_impl: dispatch_impl,\n    dump_impls: dump_impls,\n    is_async: is_async,\n    is_vararg: is_vararg,\n    get_arity: get_arity,\n    discover_protocols: discover_protocols\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435898800,"type":"commonjs","path":"npm://libprotocol@0.0.76"},"libmonad":{"name":"libmonad","sources":"\n\n/*ZB: libmonad */\nrequire.define('libmonad', {\n\n/*ZB:  libmonad/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var OK, aop_m, aop_t, cont_m, cont_t, debug, domonad, drop_while, error, error_m, error_t, first, identity, identity_m, info, is_error, is_function, is_null, lift_async, lift_sync, logger_m, logger_t, maybe_m, maybe_t, metabolize, partial, warn, _ref, _ref1,\n    __slice = [].slice;\n\n  _ref = require('libprotein'), identity = _ref.identity, first = _ref.first, drop_while = _ref.drop_while, is_function = _ref.is_function, partial = _ref.partial, metabolize = _ref.metabolize;\n\n  _ref1 = require('console-logger'), info = _ref1.info, warn = _ref1.warn, error = _ref1.error, debug = _ref1.debug;\n\n  is_null = function() {\n    var v;\n\n    v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    if (v.length === 0) {\n      return null;\n    } else {\n      return v[0] === null;\n    }\n  };\n\n  domonad = function(_arg, functions, init_value) {\n    var bind, f0, result;\n\n    result = _arg.result, bind = _arg.bind;\n    f0 = bind(result(init_value), functions[0]);\n    return ([f0].concat(functions.slice(1))).reduce(function(a, b) {\n      return bind(a, b);\n    });\n  };\n\n  identity_m = function() {\n    return {\n      result: identity,\n      bind: function(mv, f) {\n        return f(mv);\n      }\n    };\n  };\n\n  OK = void 0;\n\n  is_error = function(_arg) {\n    var err, val;\n\n    err = _arg[0], val = _arg[1];\n    return err !== OK;\n  };\n\n  error_m = function() {\n    return {\n      result: function(v) {\n        return [OK, v];\n      },\n      bind: function(mv, f) {\n        if (is_error(mv)) {\n          return mv;\n        } else {\n          return f(mv[1]);\n        }\n      }\n    };\n  };\n\n  error_t = function(inner) {\n    return {\n      result: function(v) {\n        return [OK, inner.result(v)];\n      },\n      bind: function(mv, f) {\n        if (is_error(mv)) {\n          return mv;\n        } else {\n          return inner.bind(mv[1], f);\n        }\n      }\n    };\n  };\n\n  maybe_m = function(_arg) {\n    var is_error;\n\n    is_error = _arg.is_error;\n    return {\n      zero: function() {\n        return is_error();\n      },\n      result: function(v) {\n        return v;\n      },\n      bind: function(mv, f) {\n        if (is_error(mv)) {\n          return mv;\n        } else {\n          return f(mv);\n        }\n      },\n      plus: function() {\n        var mvs;\n\n        mvs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return first(drop_while(is_error(mvs)));\n      }\n    };\n  };\n\n  maybe_t = function(inner, _arg) {\n    var is_error;\n\n    is_error = _arg.is_error;\n    return {\n      result: function(v) {\n        return inner.result(v);\n      },\n      bind: function(mv, f) {\n        if (is_error(mv)) {\n          return mv;\n        } else {\n          return inner.bind(mv, f);\n        }\n      }\n    };\n  };\n\n  aop_m = function() {\n    return {\n      result: function(v) {\n        return v;\n      },\n      bind: function(mv, f) {\n        var _ref2, _ref3;\n\n        if ((_ref2 = f.meta) != null ? (_ref3 = _ref2.concerns) != null ? _ref3.after : void 0 : void 0) {\n          f.meta.concerns.after.map(function(_arg) {\n            var check, handle;\n\n            check = _arg[0], handle = _arg[1];\n            debug('<aop_m>', \"concern found for \" + f.meta.protocol + \"/\" + f.meta.name, mv);\n            if (check(mv)) {\n              return handle(mv);\n            }\n          });\n        }\n        return f(mv);\n      }\n    };\n  };\n\n  aop_t = function(inner) {\n    return {\n      result: function(v) {\n        return inner.result(v);\n      },\n      bind: function(mv, f) {\n        var _ref2, _ref3;\n\n        if ((_ref2 = f.meta) != null ? (_ref3 = _ref2.concerns) != null ? _ref3.after : void 0 : void 0) {\n          return f.meta.concerns.after.map(function(_arg) {\n            var check, handle;\n\n            check = _arg[0], handle = _arg[1];\n            debug('<aop_t>', \"concern found for \" + f.meta.protocol + \"/\" + f.meta.name, mv);\n            if (check(mv)) {\n              return handle(inner.bind(mv, f));\n            }\n          });\n        } else {\n          return inner.bind(mv, f);\n        }\n      }\n    };\n  };\n\n  logger_m = function(log_fn) {\n    var log;\n\n    log = partial(log_fn, '<logger_m>');\n    return {\n      result: function(v) {\n        log(\"Got value:\", {\n          v: v\n        });\n        return v;\n      },\n      bind: function(mv, f) {\n        var r, _ref2, _ref3;\n\n        log(\"Going to call f(mv):\", \"\" + (((_ref2 = f.meta) != null ? _ref2.protocol : void 0) || '-') + \"/\" + (((_ref3 = f.meta) != null ? _ref3.name : void 0) || f), {\n          mv: mv\n        });\n        r = f(mv);\n        return log(\"Got result:\", {\n          r: r\n        });\n      }\n    };\n  };\n\n  logger_t = function(inner, log_fn) {\n    var log;\n\n    log = partial(log_fn, '<logger_t>');\n    return {\n      result: function(v) {\n        var r;\n\n        log(\"Got value:\", {\n          v: v\n        });\n        r = inner.result(v);\n        log(\"Got inner monad's result value:\", {\n          r: r\n        });\n        return r;\n      },\n      bind: function(mv, f) {\n        var r, _ref2, _ref3;\n\n        log(\"Going to call f(mv):\", \"\" + (((_ref2 = f.meta) != null ? _ref2.protocol : void 0) || '-') + \"/\" + (((_ref3 = f.meta) != null ? _ref3.name : void 0) || f), {\n          mv: mv\n        });\n        r = inner.bind(mv, f);\n        log(\"Got result:\", {\n          r: r\n        });\n        return r;\n      }\n    };\n  };\n\n  cont_m = function() {\n    return {\n      result: function(v) {\n        return function(c) {\n          return c(v);\n        };\n      },\n      bind: function(mv, f) {\n        return function(c) {\n          return mv((function(v) {\n            return (f(v))(c);\n          }));\n        };\n      }\n    };\n  };\n\n  cont_t = function(inner) {\n    return {\n      result: function(v) {\n        return function(c) {\n          return c(inner.result(v));\n        };\n      },\n      bind: function(mv, f) {\n        return function(c) {\n          var get_h;\n\n          get_h = function(v) {\n            var inner_bind_res;\n\n            inner_bind_res = inner.bind(v, f);\n            if (is_function(inner_bind_res)) {\n              return inner_bind_res;\n            } else {\n              return function(c) {\n                return c(inner_bind_res);\n              };\n            }\n          };\n          return mv((function(v) {\n            return (get_h(v))(c);\n          }));\n        };\n      }\n    };\n  };\n\n  lift_sync = function(arity, f) {\n    ' Lifts a function:\\nf: arg1 -> ... -> argN\\nto a function:\\nf1: (arg1 -> ... -> argN) -> cont';\n    var g;\n\n    g = function() {\n      var args, h;\n\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      h = function(c) {\n        var res;\n\n        res = f.apply(null, args.slice(0, arity));\n        return c(res);\n      };\n      return metabolize(f, h);\n    };\n    return metabolize(f, g);\n  };\n\n  lift_async = function(arity, f) {\n    ' Lifts a function:\\nf: arg1 -> ... -> argN -> cb\\nto a function:\\nf1: (arg1 -> ... argN) -> cont';\n    var g;\n\n    g = function() {\n      var args, h;\n\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      h = function(c) {\n        return f.apply(null, args.slice(0, arity - 1).concat([c]));\n      };\n      return metabolize(f, h);\n    };\n    return metabolize(f, g);\n  };\n\n  module.exports = {\n    domonad: domonad,\n    identity_m: identity_m,\n    maybe_m: maybe_m,\n    maybe_t: maybe_t,\n    aop_m: aop_m,\n    aop_t: aop_t,\n    error_m: error_m,\n    error_t: error_t,\n    cont_m: cont_m,\n    cont_t: cont_t,\n    logger_m: logger_m,\n    logger_t: logger_t,\n    lift_sync: lift_sync,\n    lift_async: lift_async,\n    is_null: is_null\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435898505,"type":"commonjs","path":"npm://libmonad"},"console-logger":{"name":"console-logger","sources":"\n\n/*ZB: console-logger */\nrequire.define('console-logger', {\n\n/*ZB:  console-logger/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var DEBUG, ERROR, INFO, LOGCFG, LOGTIME, LOG_LEVELS, NOTICE, RE1, RE2, SHOWLOG, UNK_NS, WARN, and_, bool, console, e, filter, get_browser_cfg, get_config, get_cookie, get_cookie_hash, get_cookies, get_location_hash, get_namespaced_logger, hash_level, hash_ns, in_browser, in_nodejs, is_array, is_object, log, log_cfg, log_level_enabled, log_ns_enabled, merge, nullog, or_, parse_config_hash, partial, root, say, slice, submerge, trimLeft, trimRight, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  root = typeof process !== \"undefined\" && process !== null ? process : typeof window !== \"undefined\" && window !== null ? window : {};\n\n  in_browser = typeof window !== \"undefined\" && window !== null ? true : false;\n\n  in_nodejs = typeof process !== \"undefined\" && process !== null ? true : false;\n\n  _ref = (function() {\n    try {\n      get_config = require('config').get_config;\n      return [get_config('ENV.LOG.cs_log_show_hash'), get_config('ENV.LOG.cs_log_show_time')];\n    } catch (_error) {\n      e = _error;\n      return ['showlog', 'logtime'];\n    }\n  })(), SHOWLOG = _ref[0], LOGTIME = _ref[1];\n\n  if (!root.console) {\n    root.console = {\n      log: function() {},\n      info: function() {},\n      warn: function() {},\n      error: function() {},\n      assert: function() {},\n      dir: function() {},\n      clear: function() {},\n      profile: function() {},\n      profileEnd: function() {}\n    };\n  }\n\n  console = root.console;\n\n  if (Function.prototype.bind && console && typeof console.log == \"object\") {\n    [\n      \"log\",\"info\",\"warn\",\"error\",\"assert\",\"dir\",\"clear\",\"profile\",\"profileEnd\"\n    ].forEach(function (method) {\n        console[method] = this.bind(console[method], console);\n    }, Function.prototype.call);\n}\nif (Function.prototype.bind && console && typeof console.debug == \"object\") {\n    [\n      \"debug\"\n    ].forEach(function (method) {\n        console[method] = this.bind(console[method], console);\n    }, Function.prototype.call);\n}\n;\n\n  _ref1 = require('libprotein'), partial = _ref1.partial, or_ = _ref1.or_, and_ = _ref1.and_, bool = _ref1.bool, is_object = _ref1.is_object, is_array = _ref1.is_array;\n\n  LOGCFG = (function() {\n    try {\n      log_cfg = get_config('ENV.LOG');\n      if (log_cfg) {\n        return log_cfg;\n      } else {\n        return null;\n      }\n    } catch (_error) {\n      e = _error;\n      if (in_nodejs && (is_object(process.ENV)) && (is_object(process.ENV.LOG))) {\n        return process.ENV.LOG;\n      } else if (in_browser && (is_object(window.ENV)) && (is_object(window.ENV.LOG))) {\n        return window.ENV.LOG;\n      } else {\n        return null;\n      }\n    }\n  })();\n\n  trimLeft = function(s) {\n    return s.replace(/^\\s+/, \"\");\n  };\n\n  trimRight = function(s) {\n    return s.replace(/\\s+$/, \"\");\n  };\n\n  RE1 = /^\\s*\\$Version=(?:\"1\"|1);\\s*(.*)/;\n\n  RE2 = /(?:^|\\s+)([!#$%&'*+\\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\\-.0-9A-Z^`a-z|~]*|\"(?:[\\x20-\\x7E\\x80\\xFF]|\\\\[\\x00-\\x7F])*\")(?=\\s*[,;]|$)/g;\n\n  get_cookies = function() {\n    var c, cookies, v;\n\n    c = document.cookie;\n    v = 0;\n    cookies = {};\n    if (document.cookie.match(RE1)) {\n      c = RegExp.$1;\n      v = 1;\n    }\n    if (v === 0) {\n      c.split(/[,;]/).map(function(cookie) {\n        var name, parts;\n\n        parts = cookie.split('=', 2);\n        name = decodeURIComponent(trimLeft(parts[0]));\n        return cookies[name] = parts.length > 1 ? decodeURIComponent(trimRight(parts[1])) : null;\n      });\n    } else {\n      c.match(RE2).map(function(name, maybe_value) {\n        return cookies[name] = maybe_value.charAt(0) === '\"' ? maybe_value.substr(1, -1).replace(/\\\\(.)/g, \"$1\") : maybe_value;\n      });\n    }\n    return cookies;\n  };\n\n  get_cookie = function(name) {\n    return get_cookies()[name];\n  };\n\n  filter = function(list, f) {\n    var i, _i, _len, _results;\n\n    _results = [];\n    for (_i = 0, _len = list.length; _i < _len; _i++) {\n      i = list[_i];\n      if ((f(i)) === true) {\n        _results.push(i);\n      }\n    }\n    return _results;\n  };\n\n  slice = function(str, start, stop) {\n    return str.substr(start, stop);\n  };\n\n  parse_config_hash = function(hash) {\n    var grep, parts;\n\n    if (hash) {\n      parts = hash.split(';');\n      grep = function(pp, prefix) {\n        var r;\n\n        prefix = prefix + '=';\n        r = filter(pp, function(p) {\n          return (slice(p, 0, prefix.length)) === prefix;\n        }).map(function(q) {\n          return (slice(q, prefix.length)).split('|');\n        });\n        if (r.length > 0) {\n          return r.reduce(function(a, b) {\n            return a.concat(b);\n          });\n        } else {\n          return null;\n        }\n      };\n      return {\n        enabled: __indexOf.call(parts, SHOWLOG) >= 0,\n        logtime: __indexOf.call(parts, LOGTIME) >= 0,\n        ns: grep(parts, 'ns'),\n        level: grep(parts, 'level')\n      };\n    } else {\n      return {\n        enabled: false,\n        logtime: false,\n        ns: null,\n        level: null\n      };\n    }\n  };\n\n  get_cookie_hash = function() {\n    return get_cookie(SHOWLOG);\n  };\n\n  get_location_hash = function() {\n    return document.location.hash.slice(1);\n  };\n\n  submerge = function(a, b) {\n    if (a === null && b === null) {\n      return null;\n    } else if (a === null && b !== null) {\n      return b;\n    } else if (a !== null && b === null) {\n      return a;\n    } else {\n      return a.concat(b);\n    }\n  };\n\n  merge = function(a, b) {\n    return {\n      enabled: a.enabled || b.enabled,\n      logtime: a.logtime || b.logtime,\n      ns: submerge(a.ns, b.ns),\n      level: submerge(a.level, b.level)\n    };\n  };\n\n  get_browser_cfg = function() {\n    return merge(parse_config_hash(get_location_hash()), parse_config_hash(get_cookie_hash()));\n  };\n\n  hash_level = function(level) {\n    var cfg, _ref2;\n\n    if (in_browser) {\n      cfg = get_browser_cfg();\n      if (cfg.level === null) {\n        return true;\n      }\n      if (_ref2 = level.toLowerCase(), __indexOf.call(cfg.level.map(function(i) {\n        return i.toLowerCase();\n      }), _ref2) >= 0) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n\n  hash_ns = function(ns) {\n    var cfg;\n\n    if (in_browser) {\n      cfg = get_browser_cfg();\n      if (cfg.ns === null) {\n        return true;\n      }\n      if (__indexOf.call(cfg.ns, ns) >= 0) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n\n  INFO = 'INFO';\n\n  WARN = 'WARN';\n\n  ERROR = 'ERROR';\n\n  DEBUG = 'DEBUG';\n\n  NOTICE = 'NOTICE';\n\n  LOG_LEVELS = [INFO, WARN, ERROR, DEBUG, NOTICE];\n\n  UNK_NS = 'UNK_NS';\n\n  say = function(log_time, log_level, log_ns, msgs) {\n    var m;\n\n    m = [(log_time ? \"[\" + ((new Date).valueOf()) + \"]\" : \"\"), (log_level ? \"[\" + log_level + \"]\" : '[NOTICE]'), (log_ns ? \"[\" + log_ns + \"]\" : \"[\" + UNK_NS + \"]\")].concat(msgs);\n    switch (log_level) {\n      case ERROR:\n        return console != null ? typeof console.error === \"function\" ? console.error.apply(console, m) : void 0 : void 0;\n      case INFO:\n        return console != null ? console.info.apply(console, m) : void 0;\n      case DEBUG:\n        if ((console != null ? console.debug : void 0) != null) {\n          return console != null ? console.debug.apply(console, m) : void 0;\n        } else {\n          return console != null ? console.log.apply(console, m) : void 0;\n        }\n        break;\n      case WARN:\n        return console != null ? console.warn.apply(console, m) : void 0;\n      default:\n        return console != null ? console.log.apply(console, m) : void 0;\n    }\n  };\n\n  log_level_enabled = function(log_level) {\n    var cfg_level, _ref2;\n\n    cfg_level = LOGCFG ? ((_ref2 = LOGCFG.level) != null ? _ref2[log_level] : void 0) === true : true;\n    if (in_browser) {\n      return hash_level(log_level);\n    } else {\n      return cfg_level;\n    }\n  };\n\n  log_ns_enabled = function(log_ns) {\n    var cfg_ns, _ref2;\n\n    cfg_ns = LOGCFG ? ((_ref2 = LOGCFG.ns) != null ? _ref2[log_ns] : void 0) === true : false;\n    if (in_browser) {\n      return hash_ns(log_ns);\n    } else {\n      return cfg_ns;\n    }\n  };\n\n  log = function() {\n    var browser_cfg, enabled, log_level, log_ns, log_time, msg, _ref2;\n\n    log_level = arguments[0], log_ns = arguments[1], msg = 3 <= arguments.length ? __slice.call(arguments, 2) : [];\n    _ref2 = LOGCFG.enabled != null ? in_browser ? (browser_cfg = get_browser_cfg(), [browser_cfg.enabled || LOGCFG.enabled, browser_cfg.logtime || LOGCFG.logtime]) : [LOGCFG.enabled, LOGCFG.logtime] : [true, false], enabled = _ref2[0], log_time = _ref2[1];\n    if (!enabled) {\n      return;\n    }\n    if ((log_ns_enabled(log_ns)) && (log_level_enabled(log_level))) {\n      return say(log_time, log_level, log_ns, msg);\n    }\n  };\n\n  nullog = function() {};\n\n  get_namespaced_logger = function(log_ns) {\n    return {\n      info: partial(log, INFO, log_ns),\n      warn: partial(log, WARN, log_ns),\n      error: partial(log, ERROR, log_ns),\n      debug: partial(log, DEBUG, log_ns),\n      notice: partial(log, NOTICE, log_ns),\n      nullog: nullog\n    };\n  };\n\n  module.exports = {\n    info: partial(log, INFO, UNK_NS),\n    warn: partial(log, WARN, UNK_NS),\n    error: partial(log, ERROR, UNK_NS),\n    debug: partial(log, DEBUG, UNK_NS),\n    notice: partial(log, NOTICE, UNK_NS),\n    nullog: nullog,\n    ns: get_namespaced_logger,\n    protocols: {\n      definitions: {\n        ILogger: [\n          [\n            'info', [], {\n              varargs: true\n            }\n          ], [\n            'warn', [], {\n              varargs: true\n            }\n          ], [\n            'error', [], {\n              varargs: true\n            }\n          ], [\n            'debug', [], {\n              varargs: true\n            }\n          ], [\n            'notice', [], {\n              varargs: true\n            }\n          ], [\n            'nullog', [], {\n              varargs: true\n            }\n          ]\n        ]\n      },\n      implementations: {\n        ILogger: get_namespaced_logger\n      }\n    }\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435898938,"type":"commonjs","path":"npm://console-logger@0.0.109"},"idom-jquery":{"name":"idom-jquery","sources":"\n\n/*ZB: dc-idom */\nrequire.define('dc-idom', {\n\n/*ZB:  dc-idom/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var $, IDom, debug, dispatch_impl, error, in_subtree, info, is_array, is_function, jqidom, warn, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  dispatch_impl = require('libprotocol').dispatch_impl;\n\n  _ref = dispatch_impl('ILogger', 'IDom'), info = _ref.info, warn = _ref.warn, error = _ref.error, debug = _ref.debug;\n\n  _ref1 = require('libprotein'), is_array = _ref1.is_array, is_function = _ref1.is_function;\n\n  $ = require('commonjs-jquery');\n\n  IDom = [\n    ['set-html!', ['new_content']], ['html', ['new_content']], ['get-html', []], ['setValue', ['new_value']], ['setText', ['text']], ['getValue', []], ['alert', ['msg']], ['click', ['handler']], ['click-once', ['handler']], ['globalclick', ['handler']], ['keyDown', ['handler']], ['keyUp', ['handler']], ['globalKeyDown', ['handler']], ['on_change', ['handler']], ['change', ['handler']], ['appendContent', ['content']], ['kill', []], ['kill-9', []], ['stop_event', ['e']], ['setAttr', ['attr', 'value']], ['getAttr', ['attr']], ['dbclick', ['e']], ['focusout', ['e']], ['focus', []], ['select', []], ['mouse_enter', ['handler']], ['mouseout', ['handler']], ['get_by_attr', ['attr']], ['get_by_id', ['id']], ['getData', ['attr', 'node']], ['get_id', ['node']], ['disable', []], ['enable', []], ['canWrite', []], ['readonly', []], ['on_dom_ready', ['f']], ['one', ['sel']], ['document', []], ['get_root_node', []], ['add_event_listener', ['event_name', 'handler']], ['trigger', ['event', 'args']], ['on_document_loaded', ['f']], ['addClass', ['cls']], ['removeClass', ['cls']], ['toggleClass', ['from_to']], ['toggleText', ['x', 'y']], ['data', []], [\n      'data-key', ['key'], {\n        doc: \"Returns key from data attrs\"\n      }\n    ], ['target', ['ev']], ['current-target', ['ev']], ['is_in', ['subtree', 'ev']], ['parent', []], ['text!', ['text']], ['append-to', ['to_sel', 'which_sel']], ['click!', ['orig_ev']], ['get_form_data', []], ['preventDefault', ['ev']], ['prepend', ['content']], ['click-delegate', ['selector', 'handler']], ['hover-delegate', ['selector', 'handler']], ['delegate', ['action', 'selector', 'handler']], ['global-key', ['keys', 'handler']]\n  ];\n\n  in_subtree = function($node, target) {\n    if (!!$node.find(target).length || ($node.is(target))) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  jqidom = function(node) {\n    var $node;\n\n    $node = $(node);\n    return {\n      'global-key': function(key, h) {\n        var keys;\n\n        keys = is_array(key) ? key : [key];\n        return $(document).bind('keydown', function(ev) {\n          var _ref2;\n\n          if (_ref2 = ev.which, __indexOf.call(keys, _ref2) >= 0) {\n            return h(ev.which);\n          }\n        });\n      },\n      'click-delegate': function(sel, handler) {\n        var real_sel;\n\n        real_sel = is_function(sel) ? sel() : sel;\n        return ($(real_sel)).click(handler);\n      },\n      'hover-delegate': function(sel, handler) {\n        var real_sel;\n\n        real_sel = is_function(sel) ? sel() : sel;\n        return ($(real_sel)).mouseenter(handler);\n      },\n      delegate: function(action, selector, handler) {\n        return $(selector).on(action, handler);\n      },\n      preventDefault: function(ev) {\n        return ev.preventDefault();\n      },\n      get_form_data: function() {\n        return $node.serializeObject();\n      },\n      prepend: function(content) {\n        return $node.prepend(content);\n      },\n      'click!': function(orig_ev) {\n        return $node.click();\n      },\n      mouseout: function(handler) {\n        return $node.mouseleave(handler);\n      },\n      \"append-to\": function(to_sel, which_sel) {\n        return ($(which_sel)).appendTo(to_sel);\n      },\n      \"text!\": function(t) {\n        return $node.text(t);\n      },\n      disable: function() {\n        return $node.attr('disabled', 'disabled');\n      },\n      enable: function() {\n        return $node.removeAttr('disabled');\n      },\n      data: function() {\n        return $node.data();\n      },\n      'data-key': function(key) {\n        return $node.data(key);\n      },\n      parent: function() {\n        return $node.parent();\n      },\n      target: function(ev) {\n        return ev.target;\n      },\n      'current-target': function(ev) {\n        return ev.currentTarget;\n      },\n      is_in: function(subtrees, target_node) {\n        var elid, _i, _len;\n\n        for (_i = 0, _len = subtrees.length; _i < _len; _i++) {\n          elid = subtrees[_i];\n          $node = elid === 'this' ? $node : $(\"#\" + elid);\n          if (in_subtree($node, target_node)) {\n            return true;\n          }\n        }\n        return false;\n      },\n      'set-html!': function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return $node.html(args.join(''));\n      },\n      html: function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return $node.html(args.join(''));\n      },\n      'get-html': function() {\n        return $node.html();\n      },\n      setValue: function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return $node.val(args.join(''));\n      },\n      setText: function(text) {\n        return $node.text(text);\n      },\n      getValue: function() {\n        if (($node.prop('tagName')).toLowerCase() === 'span') {\n          return $node.text();\n        } else {\n          return $node.val();\n        }\n      },\n      setAttr: function(attr, value) {\n        return $node.attr(attr, value);\n      },\n      getAttr: function(name) {\n        return $node.attr(name);\n      },\n      appendContent: function(content) {\n        return $node.append(\"<div>\" + content + \"</div>\");\n      },\n      alert: function() {\n        var args;\n\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return alert.apply(null, args);\n      },\n      click: function(handler) {\n        return $node.click(handler);\n      },\n      'click-once': function(handler) {\n        return $node.one('click', handler);\n      },\n      globalclick: function(handler) {\n        return $(document).click(handler);\n      },\n      kill: function() {\n        return $node.remove();\n      },\n      'kill-9': function() {\n        return $node.remove();\n      },\n      stop_event: function(e) {\n        return $.Event(e).stopPropagation();\n      },\n      keyDown: function(handler) {\n        return $node.bind('keydown', handler);\n      },\n      keyUp: function(handler) {\n        return $node.bind('keyup', handler);\n      },\n      globalKeyDown: function(handler) {\n        return $(document).bind('keydown', handler);\n      },\n      on_change: function(handler) {\n        return $node.bind('onchange', handler);\n      },\n      change: function(handler) {\n        return $node.change(handler);\n      },\n      dbclick: function(handler) {\n        return $node.dblclick(handler);\n      },\n      focusout: function(handler) {\n        return $node.blur(handler);\n      },\n      focus: function() {\n        return $node.focus();\n      },\n      select: function() {\n        return $node.select();\n      },\n      mouse_enter: function(handler) {\n        return $node.mouseenter(handler);\n      },\n      get_by_attr: function(attr) {\n        var e, r1;\n\n        r1 = (function() {\n          try {\n            if ($node.is(attr)) {\n              return [$node];\n            } else {\n              return [];\n            }\n          } catch (_error) {\n            e = _error;\n            return [];\n          }\n        })();\n        return r1.concat(($node.find(attr)).toArray());\n      },\n      get_by_id: function(id) {\n        return $(\"#\" + id);\n      },\n      getData: function(attr, node) {\n        if (node == null) {\n          node = $node;\n        }\n        return ($(node)).data(attr);\n      },\n      get_id: function(node) {\n        if (node == null) {\n          node = $node;\n        }\n        return ($(node)).attr('id');\n      },\n      on_dom_ready: function(f) {\n        return ($(document)).ready(f);\n      },\n      on_document_loaded: function(f) {\n        return ($(window)).load(f);\n      },\n      canWrite: function() {\n        return $node.removeAttr('readonly');\n      },\n      readonly: function() {\n        return $node.attr('readonly', 'readonly');\n      },\n      one: function(sel) {\n        return $(sel);\n      },\n      document: function() {\n        return window.document;\n      },\n      get_root_node: function() {\n        return node;\n      },\n      add_event_listener: function(event_name, handler) {\n        if (node.addEventListener) {\n          return node.addEventListener(event_name, handler);\n        } else if (node.attachEvent) {\n          return node.attachEvent(\"on\" + event_name, handler);\n        } else {\n          error(\"Can't add event listener: no addEventListener nor attachEvent present\", event_name, node);\n          throw \"Can't add event listener: no addEventListener nor attachEvent present\";\n        }\n      },\n      trigger: function(event, args) {\n        return $node.trigger(event, args);\n      },\n      addClass: function(cls) {\n        return $node.addClass(cls);\n      },\n      removeClass: function(cls) {\n        return $node.removeClass(cls);\n      },\n      toggleClass: function(_arg) {\n        var from, to;\n\n        from = _arg[0], to = _arg[1];\n        if ($node.hasClass(from)) {\n          $node.removeClass(from);\n          return $node.addClass(to);\n        } else {\n          $node.removeClass(to);\n          return $node.addClass(from);\n        }\n      },\n      toggleText: function(x, y) {\n        if (x === $node.text()) {\n          return $node.text(y);\n        } else {\n          return $node.text(x);\n        }\n      }\n    };\n  };\n\n  module.exports = {\n    protocols: {\n      definitions: {\n        IDom: IDom\n      },\n      implementations: {\n        IDom: jqidom\n      }\n    }\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384436998844,"type":"commonjs","path":"npm://dc-idom@0.0.23"},"queue-manager":{"name":"queue-manager","sources":"\n\n/*ZB:  */\nrequire.define('', {\n\n/*ZB:  /queue-manager */\n'queue-manager': function(exports, require, module) {(function() {\n(function() {\n  var CSMTS, CSQS, MY_STATE, TConfig, TCustomInit, TDefine, TRunCSM, TRunRaw, TState, Type, debug, error, get_state, info, is_array, is_function, lazy_init_state, partial, run_bootstrap_queue, run_config_ready_queue, run_define_queue, run_doc_load_queue, run_dom_ready_queue, run_init_queue, run_module, run_module_worker, run_queue, schedule, set_config, swap_state, typeclass, valid_queue, value_to_type, warn, watch_ran_queues, watch_state, _ref, _ref1, _ref2, _ref3,\n    __slice = [].slice;\n\n  _ref = require('libprotein'), partial = _ref.partial, is_array = _ref.is_array, is_function = _ref.is_function;\n\n  _ref1 = (require('console-logger')).ns('QueueManager'), debug = _ref1.debug, warn = _ref1.warn, info = _ref1.info, error = _ref1.error;\n\n  _ref2 = require('libstate'), get_state = _ref2.get_state, swap_state = _ref2.swap_state, watch_state = _ref2.watch_state;\n\n  set_config = require('config').set_config;\n\n  MY_STATE = 'queue-manager';\n\n  typeclass = function(x) {\n    return x.constructor;\n  };\n\n  _ref3 = require('api'), CSQS = _ref3.CSQS, CSMTS = _ref3.CSMTS, Type = _ref3.Type, TDefine = _ref3.TDefine, TRunCSM = _ref3.TRunCSM, TConfig = _ref3.TConfig, TRunRaw = _ref3.TRunRaw, TState = _ref3.TState, TCustomInit = _ref3.TCustomInit, valid_queue = _ref3.valid_queue, value_to_type = _ref3.value_to_type;\n\n  watch_ran_queues = function(old_state, new_state) {\n    var i, k, v, _ref4;\n    _ref4 = new_state.q;\n    for (k in _ref4) {\n      v = _ref4[k];\n      if (v.length > 0 && v.has_been_ran === true) {\n        debug(\"Ran queue updated:\", k);\n        while (i = v.shift()) {\n          run_module(AppState, i);\n        }\n      }\n    }\n    return new_state;\n  };\n\n  lazy_init_state = function(state) {\n    var k, v, _base, _base1;\n    state || (state = {});\n    state.q || (state.q = {});\n    for (k in CSQS) {\n      v = CSQS[k];\n      (_base = state.q)[v] || (_base[v] = []);\n      (_base1 = state.q[v]).has_been_ran || (_base1.has_been_ran = false);\n    }\n    watch_state(MY_STATE, watch_ran_queues);\n    return state;\n  };\n\n  schedule = function(qitem, AppState) {\n    if (!(qitem instanceof Type)) {\n      throw new TypeError(\"Type mismatch for queue item\");\n    }\n    return swap_state(MY_STATE, function(old_state) {\n      var new_state;\n      new_state = lazy_init_state(old_state);\n      new_state.q[qitem.value.queue].push(qitem);\n      return new_state;\n    });\n  };\n\n  run_queue = function(queue_name, runner, qs, AppState) {\n    var external_q, full_queue, my_q, my_state, queue_done, queue_size, ran_count;\n    if (!valid_queue(queue_name)) {\n      throw new TypeError(\"Bad queue\");\n    }\n    qs = qs.map(value_to_type);\n    my_state = lazy_init_state(get_state(MY_STATE));\n    my_q = my_state.q[queue_name];\n    swap_state(MY_STATE, function(old_state) {\n      my_state.q[queue_name] = [];\n      my_state.q[queue_name].has_been_ran = true;\n      return my_state;\n    });\n    external_q = qs.filter(function(x) {\n      return x.value.queue === queue_name;\n    });\n    full_queue = my_q.concat(external_q);\n    queue_size = full_queue.length;\n    ran_count = 0;\n    queue_done = function() {\n      ran_count = ran_count + 1;\n      if (ran_count === queue_size) {\n        return debug(\"-- Done [\" + AppState.realm + \":\" + queue_name + \"]\");\n      }\n    };\n    if (queue_size > 0) {\n      debug(\"-- Go [\" + AppState.realm + \":\" + queue_name + \"]\");\n      return full_queue.map(partial(runner, AppState, queue_done));\n    } else {\n      return debug(\"-- Empty [\" + AppState.realm + \":\" + queue_name + \"]\");\n    }\n  };\n\n  run_module = function(AppState, cont, mod) {\n    return setTimeout((function() {\n      return run_module_worker(AppState, cont, mod);\n    }), 0);\n  };\n\n  run_module_worker = function(AppState, cont, mod) {\n    var X, args, e, f, fun, key, mod_name, modbody, modname, module, parsed_mod_body, queue, raw, singleton, sl, stateid, submodname, value, _, _i, _ref10, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n    switch (typeclass(mod)) {\n      case TState:\n        _ref4 = mod.value, stateid = _ref4.stateid, key = _ref4.key, value = _ref4.value;\n        try {\n          swap_state(key, function(old_state) {\n            return value;\n          });\n        } catch (_error) {\n          e = _error;\n          error(\"Failed to set state for \" + key + \"/\" + stateid + \":\", e);\n        }\n        break;\n      case TDefine:\n        _ref5 = mod.value, modname = _ref5.modname, submodname = _ref5.submodname, modbody = _ref5.modbody;\n        try {\n          module = {};\n          parsed_mod_body = JSON.parse(modbody);\n          module[submodname] = function(exports, require, module) {\n            return module.exports = parsed_mod_body;\n          };\n          window.require.define(modname, module);\n        } catch (_error) {\n          e = _error;\n          error(\"Failed to require.define \" + modname + \"/\" + submodname + \":\", e);\n        }\n        break;\n      case TConfig:\n        _ref6 = mod.value, modname = _ref6.modname, key = _ref6.key, value = _ref6.value;\n        try {\n          set_config(key, value, AppState);\n        } catch (_error) {\n          e = _error;\n          error(\"Failed to set config \" + modname + \"/\" + key + \":\", e);\n        }\n        break;\n      case TRunCSM:\n        _ref7 = mod.value, modname = _ref7.modname, args = _ref7.args, singleton = _ref7.singleton;\n        info(\"Initializing \" + AppState.realm + \":\" + modname + \" instance\");\n        sl = require('service-locator');\n        try {\n          _ref8 = modname.split('/'), _ = 2 <= _ref8.length ? __slice.call(_ref8, 0, _i = _ref8.length - 1) : (_i = 0, []), mod_name = _ref8[_i++];\n          X = require(mod_name);\n          sl.provide({\n            name: mod_name,\n            instance: (function(func, args, ctor) {\n              ctor.prototype = func.prototype;\n              var child = new ctor, result = func.apply(child, args);\n              return Object(result) === result ? result : child;\n            })(X, args.concat([AppState]), function(){}),\n            singleton: singleton\n          }, AppState);\n        } catch (_error) {\n          e = _error;\n          error(\"Failed to init \" + AppState.realm + \":\" + mod + \": \" + e);\n        }\n        break;\n      case TRunRaw:\n        _ref9 = mod.value, modname = _ref9.modname, raw = _ref9.raw, singleton = _ref9.singleton;\n        info(\"Initializing \" + AppState.realm + \":\" + modname + \" instance with a literal\");\n        try {\n          f = is_function(raw) ? raw : (warn(\"Usage of string literals in TRunRaw is deprecated!\"), new Function(modname.replace(/[^A-Za-z0-9]/g, '_'), raw));\n          f(AppState);\n        } catch (_error) {\n          e = _error;\n          error(\"Failed to init \" + AppState.realm + \":\" + modname + \" with a literal: \" + e);\n        }\n        break;\n      case TCustomInit:\n        _ref10 = mod.value, modname = _ref10.modname, queue = _ref10.queue, fun = _ref10.fun;\n        info(\"Running custom-init \" + AppState.realm + \":\" + modname);\n        try {\n          fun(AppState);\n        } catch (_error) {\n          e = _error;\n          error(\"Failed running \" + AppState.realm + \":\" + modname + \" of type custom-init: \" + e);\n        }\n        break;\n      default:\n        throw new TypeError(\"Unknown type: \" + mod);\n    }\n    return cont(true);\n  };\n\n  run_bootstrap_queue = partial(run_queue, CSQS.BOOTSTRAP_QUEUE, run_module);\n\n  run_define_queue = partial(run_queue, CSQS.DEFINE_QUEUE, run_module);\n\n  run_init_queue = partial(run_queue, CSQS.INIT_QUEUE, run_module);\n\n  run_dom_ready_queue = partial(run_queue, CSQS.DOM_READY_QUEUE, run_module);\n\n  run_doc_load_queue = partial(run_queue, CSQS.DOC_LOAD_QUEUE, run_module);\n\n  run_config_ready_queue = partial(run_queue, CSQS.CONFIG_READY_QUEUE, run_module);\n\n  module.exports = {\n    CSQS: CSQS,\n    CSMTS: CSMTS,\n    value_to_type: value_to_type,\n    run_bootstrap_queue: run_bootstrap_queue,\n    TCustomInit: TCustomInit,\n    TDefine: TDefine,\n    TRunCSM: TRunCSM,\n    TRunRaw: TRunRaw,\n    TState: TState,\n    schedule: schedule,\n    run_define_queue: run_define_queue,\n    run_init_queue: run_init_queue,\n    run_dom_ready_queue: run_dom_ready_queue,\n    run_doc_load_queue: run_doc_load_queue,\n    run_config_ready_queue: run_config_ready_queue\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435525949,"type":"commonjs","path":"queue-manager.coffee"},"require":{"name":"require","sources":"\n/*ZB:  require */\n(function() {\n  var cache, diranme, expand, modules, partial, require;\n\n  if (!this.require) {\n    modules = {};\n    cache = {};\n    partial = function(fn) {\n      var partial_args;\n      partial_args = Array.prototype.slice.call(arguments);\n      partial_args.shift();\n      return function() {\n        var a, arg, i, new_args, _i, _len, _ref;\n        _ref = [[], 0], new_args = _ref[0], arg = _ref[1];\n        for (i = _i = 0, _len = partial_args.length; _i < _len; i = ++_i) {\n          a = partial_args[i];\n          if (partial_args[i] === void 0) {\n            new_args.push(arguments[arg++]);\n          } else {\n            new_args.push(partial_args[i]);\n          }\n        }\n        return fn.apply(this, new_args);\n      };\n    };\n    require = function(name, root, ns) {\n      var e, fn, module, ns_module, ns_path, path, top_level_module;\n      path = expand(root, name);\n      ns_path = \"\" + ns + \"/\" + (expand('', name));\n      top_level_module = modules[path] || modules[expand(path, './index')];\n      if (ns && !top_level_module) {\n        path = ns_path;\n      }\n      ns_module = modules[ns_path] || modules[expand(ns_path, './index')];\n      if (ns && top_level_module && ns_module) {\n        path = \"\" + ns + \"/\" + (expand('', name));\n      }\n      module = cache[path] || cache[expand(path, './index')];\n      if (module) {\n        return module.exports;\n      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {\n        module = {\n          id: path,\n          exports: {}\n        };\n        try {\n          cache[path] = module;\n          fn(module.exports, module);\n          return module.exports;\n        } catch (_error) {\n          e = _error;\n          delete cache[path];\n          throw e;\n        }\n      } else {\n        throw \"module '\" + name + \"' is not found\";\n      }\n    };\n    expand = function(root, name) {\n      var i, part, parts, results, _i, _ref;\n      results = [];\n      if (/^\\.\\.?(\\/|$)/.test(name)) {\n        parts = [root, name].join('/').split('/');\n      } else {\n        parts = name.split('/');\n      }\n      for (i = _i = 0, _ref = parts.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n        part = parts[i];\n        if (part === '..') {\n          results.pop();\n        } else if (part !== '.' && part !== '') {\n          results.push(part);\n        }\n      }\n      return results.join('/');\n    };\n    diranme = function(path) {\n      return path.split('/').slice(0).join('/');\n    };\n    this.require = function(name) {\n      return require(name, '');\n    };\n    this.require.modules = function() {\n      return modules;\n    };\n    this.require.cache = function() {\n      return cache;\n    };\n    this.require.define = function(ns, bundle) {\n      var key, value, _key, _require;\n      _require = partial(require, void 0, void 0, ns);\n      for (key in bundle) {\n        value = bundle[key];\n        _key = ns ? \"\" + ns + \"/\" + key : key;\n        modules[_key] = partial(value, void 0, _require, void 0);\n        void 0;\n      }\n      return void 0;\n    };\n  }\n\n}).call(this);\n;","mtime":1384435525847,"type":"plainjs","path":"require.coffee"},"bootstrap":{"name":"bootstrap","sources":"\n/*ZB:  bootstrap */\n(function() {\n  var __slice = [].slice;\n\n  window.is_debug = true;\n\n  window.protolog = (function() {\n    var can_log;\n    can_log = typeof console !== \"undefined\" && console !== null ? true : false;\n    return {\n      debug: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        if (can_log) {\n          return console.log([\"<DEBUG>\"].concat(args));\n        }\n      }\n    };\n  })();\n\n  window.AppState = {\n    stateid: 1,\n    realm: 'dna-playground',\n    config: {\n      ENV: {\n        DEFAULT_PROTOCOLS: [\"IDom\", \"IHelper\"],\n        LOG: {\n          cs_log_show_hash: \"showlog\",\n          cs_log_show_time: \"logtime\",\n          enabled: true,\n          logtime: false,\n          level: {\n            DEBUG: true,\n            ERROR: true,\n            INFO: true,\n            NOTICE: true,\n            WARN: true\n          },\n          ns: {}\n        },\n        ROOT_NS: \"window\",\n        csq_mimetype: \"text/csq-def\"\n      }\n    },\n    modstate: {},\n    services: {},\n    stateid: 1\n  };\n\n}).call(this);\n;","mtime":1384437802512,"type":"plainjs","path":"bootstrap.coffee"},"api":{"name":"api","sources":"\n\n/*ZB:  */\nrequire.define('', {\n\n/*ZB:  /api */\n'api': function(exports, require, module) {(function() {\n(function() {\n  var CSMTS, CSQS, TConfig, TCustomInit, TDefine, TRunCSM, TRunRaw, TState, Type, valid_queue, value_to_type,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  CSQS = {\n    DEFINE_QUEUE: 'define-queue',\n    INIT_QUEUE: 'init-queue',\n    DOM_READY_QUEUE: 'dom-ready-queue',\n    DOC_LOAD_QUEUE: 'doc-loaded-queue',\n    CONFIG_READY_QUEUE: 'cfg-ready-queue',\n    BOOTSTRAP_QUEUE: 'bootstrap-queue'\n  };\n\n  CSMTS = {\n    CSM: 'csm',\n    RAW: 'raw',\n    CUSTOM_INIT: 'custom-init',\n    DEFINE: 'define',\n    STATE: 'state',\n    CONFIG: 'config'\n  };\n\n  valid_queue = function(q) {\n    var k, v;\n    return __indexOf.call((function() {\n      var _results;\n      _results = [];\n      for (k in CSQS) {\n        if (!__hasProp.call(CSQS, k)) continue;\n        v = CSQS[k];\n        _results.push(v);\n      }\n      return _results;\n    })(), q) >= 0;\n  };\n\n  value_to_type = function(v) {\n    if (v instanceof Type) {\n      return v;\n    } else {\n      switch (v.type) {\n        case CSMTS.CSM:\n          return new TRunCSM(v);\n        case CSMTS.RAW:\n          return new TRunRaw(v);\n        case CSMTS.DEFINE:\n          return new TDefine(v);\n        case CSMTS.STATE:\n          return new TState(v);\n        case CSMTS.CONFIG:\n          return new TConfig(v);\n        case CSMTS.CUSTOM_INIT:\n          return new TCustomInit(v);\n        default:\n          throw new TypeError(\"Unknown type: \" + v);\n      }\n    }\n  };\n\n  Type = (function() {\n    function Type() {}\n\n    Type.prototype._name = 'Type';\n\n    Type.prototype.toString = function() {\n      return \"\" + this._name + \" \" + this.value;\n    };\n\n    return Type;\n\n  })();\n\n  TRunRaw = (function(_super) {\n    __extends(TRunRaw, _super);\n\n    function TRunRaw(_arg) {\n      var modname, queue, raw, singleton, _ref;\n      _ref = _arg != null ? _arg : {}, modname = _ref.modname, queue = _ref.queue, raw = _ref.raw, singleton = _ref.singleton;\n      if (!valid_queue(queue)) {\n        throw \"Bad cs queue: \" + queue;\n      }\n      if (!(modname && queue && raw)) {\n        throw \"Bad type constructor arguments\";\n      }\n      this._name = 'TRunRaw';\n      this.value = {\n        type: CSMTS.RAW,\n        modname: modname,\n        raw: raw,\n        queue: queue,\n        singleton: singleton || false\n      };\n    }\n\n    return TRunRaw;\n\n  })(Type);\n\n  TRunCSM = (function(_super) {\n    __extends(TRunCSM, _super);\n\n    function TRunCSM(_arg) {\n      var args, modname, queue, singleton, _ref;\n      _ref = _arg != null ? _arg : {}, modname = _ref.modname, queue = _ref.queue, args = _ref.args, singleton = _ref.singleton;\n      if (!valid_queue(queue)) {\n        throw \"Bad cs queue: \" + queue;\n      }\n      if (!(modname && queue && args)) {\n        throw \"Bad type constructor arguments\";\n      }\n      this._name = 'TRunCSM';\n      this.value = {\n        type: CSMTS.CSM,\n        modname: modname,\n        args: args,\n        queue: queue,\n        singleton: singleton || false\n      };\n    }\n\n    return TRunCSM;\n\n  })(Type);\n\n  TState = (function(_super) {\n    __extends(TState, _super);\n\n    function TState(_arg) {\n      var key, queue, stateid, value, _ref;\n      _ref = _arg != null ? _arg : {}, stateid = _ref.stateid, key = _ref.key, value = _ref.value, queue = _ref.queue;\n      if (!(stateid && key)) {\n        throw \"Bad type constructor arguments\";\n      }\n      if (queue && !valid_queue(queue)) {\n        throw \"Bad cs queue: \" + queue;\n      }\n      this._name = 'TState';\n      this.value = {\n        type: CSMTS.STATE,\n        stateid: stateid,\n        key: key,\n        value: value,\n        queue: queue || CSQS.DEFINE_QUEUE\n      };\n    }\n\n    return TState;\n\n  })(Type);\n\n  TDefine = (function(_super) {\n    __extends(TDefine, _super);\n\n    function TDefine(_arg) {\n      var modbody, modname, queue, submodname, _ref;\n      _ref = _arg != null ? _arg : {}, modname = _ref.modname, submodname = _ref.submodname, modbody = _ref.modbody, queue = _ref.queue;\n      if (!(modname && submodname && modbody)) {\n        throw \"Bad type constructor arguments\";\n      }\n      if (queue && !valid_queue(queue)) {\n        throw \"Bad cs queue: \" + queue;\n      }\n      this._name = 'TDefine';\n      this.value = {\n        type: CSMTS.DEFINE,\n        modname: modname,\n        submodname: submodname,\n        modbody: modbody,\n        queue: queue || CSQS.DEFINE_QUEUE\n      };\n    }\n\n    return TDefine;\n\n  })(Type);\n\n  TConfig = (function(_super) {\n    __extends(TConfig, _super);\n\n    function TConfig(_arg) {\n      var key, modname, queue, value, _ref;\n      _ref = _arg != null ? _arg : {}, modname = _ref.modname, key = _ref.key, value = _ref.value, queue = _ref.queue;\n      if (!(modname && key)) {\n        throw \"Bad type constructor arguments\";\n      }\n      if (queue && !valid_queue(queue)) {\n        throw \"Bad cs queue: \" + queue;\n      }\n      if (key.slice(0, 3) !== 'CS.') {\n        throw \"Bad config key: \" + key + \". You can only override a CS. subdomain\";\n      }\n      this._name = 'TConfig';\n      this.value = {\n        type: CSMTS.CONFIG,\n        modname: modname,\n        key: key,\n        value: value,\n        queue: queue || CSQS.CONFIG_READY_QUEUE\n      };\n    }\n\n    return TConfig;\n\n  })(Type);\n\n  TCustomInit = (function(_super) {\n    __extends(TCustomInit, _super);\n\n    function TCustomInit(_arg) {\n      var fun, modname, queue, _ref;\n      _ref = _arg != null ? _arg : {}, modname = _ref.modname, queue = _ref.queue, fun = _ref.fun;\n      if (!valid_queue(queue)) {\n        throw \"Bad cs queue: \" + queue;\n      }\n      if (!(modname && queue && fun)) {\n        throw \"Bad type constructor arguments\";\n      }\n      this._name = 'TCustomInit';\n      this.value = {\n        modname: modname,\n        queue: queue,\n        fun: fun,\n        type: CSMTS.CUSTOM_INIT\n      };\n    }\n\n    return TCustomInit;\n\n  })(Type);\n\n  module.exports = {\n    CSQS: CSQS,\n    CSMTS: CSMTS,\n    Type: Type,\n    TRunCSM: TRunCSM,\n    TRunRaw: TRunRaw,\n    TState: TState,\n    TDefine: TDefine,\n    TConfig: TConfig,\n    TCustomInit: TCustomInit,\n    valid_queue: valid_queue,\n    value_to_type: value_to_type\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384435525904,"type":"commonjs","path":"api.coffee"},"ihelper":{"name":"ihelper","sources":"\n\n/*ZB: dc-helper */\nrequire.define('dc-helper', {\n\n/*ZB:  dc-helper/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var STOP, Spine, debug, dispatch_impl, error, info, is_nan, make_lambda, named_waits, stack, warn, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  _ref = require('libprotein'), make_lambda = _ref.make_lambda, is_nan = _ref.is_nan;\n\n  dispatch_impl = require('libprotocol').dispatch_impl;\n\n  _ref1 = dispatch_impl('ILogger', 'IHelper'), info = _ref1.info, warn = _ref1.warn, error = _ref1.error, debug = _ref1.debug;\n\n  Spine = require('spine');\n\n  named_waits = {};\n\n  STOP = null;\n\n  stack = [];\n\n  module.exports = {\n    protocols: {\n      definitions: {\n        IHelper: [\n          ['len', ['array']], ['add', ['vector']], ['drop', ['items_vec', 'cur_item']], ['swap', ['items_vec', 'cur_item']], ['inc', ['val']], ['dec', ['val']], ['parseint', ['val']], ['proxyinfo', ['a']], ['->->->', ['a']], [\n            'say', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'info', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'warn', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'error', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'debug', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], ['not', ['a']], ['stop!', []], ['stop?', ['patrn', 'val']], [\n            'wait', ['timeout'], {\n              async: true\n            }\n          ], [\n            'named-wait', ['timeout', 'name'], {\n              async: true\n            }\n          ], ['cancel-wait', ['name']], ['preventOnEnter', ['event']], ['random', []], ['push-to-google', ['vec']], ['###', ['blk', 'args']], ['wrap', ['tpl', 'pattern', 'value']], ['true', []], ['false', []], ['the-undefined', []], ['spine-fire', ['event-name']], ['match', ['predicate', 'val']], ['slice', ['[start,count]', 'str']], ['push', ['i']], ['pop', []], ['make-obj', ['key-vals']], ['obj->json', ['obj']]\n        ]\n      },\n      implementations: {\n        IHelper: function(node) {\n          return {\n            'slice': function(_arg, str) {\n              var count, start;\n\n              start = _arg[0], count = _arg[1];\n              return str.substr(start, count);\n            },\n            'push': function(i) {\n              return stack.push(i);\n            },\n            'pop': function() {\n              return stack.pop();\n            },\n            'match': function(predicate, value) {\n              var real_predicate;\n\n              real_predicate = make_lambda(predicate);\n              if (real_predicate(value)) {\n                return value;\n              } else {\n                return STOP;\n              }\n            },\n            'spine-fire': function(event_name) {\n              return Spine.trigger(event_name);\n            },\n            \"true\": function() {\n              return true;\n            },\n            \"false\": function() {\n              return false;\n            },\n            'the-undefined': function() {\n              return void 0;\n            },\n            wrap: function(t, p, v) {\n              return t.replace(p, v);\n            },\n            '###': function(block, args) {\n              return args;\n            },\n            'push-to-google': function(p) {\n              debug('push-to-google', p);\n              return push_to_google.apply(null, p);\n            },\n            random: function() {\n              return Math.random();\n            },\n            len: function(array) {\n              return array.length || 0;\n            },\n            wait: function(timeout, cont) {\n              debug(\"waiting \" + timeout + \"ms\");\n              return setTimeout(function() {\n                debug(\"waiting done\");\n                return cont();\n              }, timeout);\n            },\n            'named-wait': function(timeout, name, _, cont) {\n              debug(\"named-wait\", timeout, name);\n              return named_waits[name] = setTimeout(function() {\n                debug(debug(\"named-wait done\", timeout, name));\n                return cont();\n              }, timeout);\n            },\n            'cancel-wait': function(name) {\n              if (named_waits[name]) {\n                debug(\"cancelling named timeout\", name);\n                return clearTimeout(named_waits[name]);\n              }\n            },\n            not: function(a) {\n              return !a;\n            },\n            \"stop!\": function() {\n              return STOP;\n            },\n            \"stop?\": function(p, v) {\n              if (p === v) {\n                return STOP;\n              } else {\n                return v;\n              }\n            },\n            add: function(vec) {\n              return vec.reduce(function(a, b) {\n                return (parseInt(a, 10)) + (parseInt(b, 10));\n              });\n            },\n            drop: function(items, item) {\n              var item_is_in_items;\n\n              item_is_in_items = is_nan(item) ? !!(items.filter(function(i) {\n                return is_nan(i);\n              })).length : __indexOf.call(items, item) >= 0;\n              if (item_is_in_items) {\n                return STOP;\n              } else {\n                return item;\n              }\n            },\n            swap: function(_arg, item) {\n              var from, to;\n\n              from = _arg[0], to = _arg[1];\n              if (((is_nan(item)) && (is_nan(from))) || (item === from)) {\n                return to;\n              } else {\n                return item;\n              }\n            },\n            '->->->': function(a) {\n              debug(\"[->->->]\", a);\n              return a;\n            },\n            proxyinfo: function(a) {\n              console.log(\"%c[proxy:@\" + node.id + \"] \", 'background: #222; color: #bada55', \"incoming: \" + a + \", type: \" + (typeof a));\n              return a;\n            },\n            info: info,\n            error: error,\n            warn: warn,\n            debug: function() {\n              var a;\n\n              a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n              return debug.apply(null, a);\n            },\n            say: info,\n            inc: function(v) {\n              return parseInt(v, 10) + 1;\n            },\n            dec: function(v) {\n              return parseInt(v, 10) - 1;\n            },\n            parseint: function(v) {\n              return parseInt(v);\n            },\n            preventOnEnter: function(e) {\n              if (e.keyCode === 13) {\n                e.preventDefault();\n              }\n              return e;\n            },\n            'make-obj': function(keyvals) {\n              var key, obj, val, _i, _len, _ref2;\n\n              obj = {};\n              for (_i = 0, _len = keyvals.length; _i < _len; _i++) {\n                _ref2 = keyvals[_i], key = _ref2[0], val = _ref2[1];\n                obj[key] = val;\n              }\n              return obj;\n            },\n            'obj->json': function(obj) {\n              return JSON.stringify(obj);\n            }\n          };\n        }\n      }\n    }\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384436082207,"type":"commonjs","path":"npm://dc-helper@0.0.15"},"dc-helper":{"name":"dc-helper","sources":"\n\n/*ZB: dc-helper */\nrequire.define('dc-helper', {\n\n/*ZB:  dc-helper/index */\n'index': function(exports, require, module) {(function() {\n// Generated by CoffeeScript 1.6.2\n(function() {\n  var STOP, debug, dispatch_impl, error, info, is_nan, make_lambda, named_waits, stack, warn, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  _ref = require('libprotein'), make_lambda = _ref.make_lambda, is_nan = _ref.is_nan;\n\n  dispatch_impl = require('libprotocol').dispatch_impl;\n\n  _ref1 = dispatch_impl('ILogger', 'IHelper'), info = _ref1.info, warn = _ref1.warn, error = _ref1.error, debug = _ref1.debug;\n\n  named_waits = {};\n\n  STOP = null;\n\n  stack = [];\n\n  module.exports = {\n    protocols: {\n      definitions: {\n        IHelper: [\n          ['len', ['array']], ['add', ['vector']], ['drop', ['items_vec', 'cur_item']], ['swap', ['items_vec', 'cur_item']], ['inc', ['val']], ['dec', ['val']], ['parseint', ['val']], ['proxyinfo', ['a']], ['->->->', ['a']], [\n            'say', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'info', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'warn', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'error', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], [\n            'debug', ['msgs', 'more'], {\n              vargs: true\n            }\n          ], ['not', ['a']], ['stop!', []], ['stop?', ['patrn', 'val']], [\n            'wait', ['timeout'], {\n              async: true\n            }\n          ], [\n            'named-wait', ['timeout', 'name'], {\n              async: true\n            }\n          ], ['cancel-wait', ['name']], ['preventOnEnter', ['event']], ['random', []], ['push-to-google', ['vec']], ['###', ['blk', 'args']], ['wrap', ['tpl', 'pattern', 'value']], ['true', []], ['false', []], ['the-undefined', []], ['spine-fire', ['event-name']], ['match', ['predicate', 'val']], ['slice', ['[start,count]', 'str']], ['push', ['i']], ['pop', []], ['make-obj', ['key-vals']], ['obj->json', ['obj']]\n        ]\n      },\n      implementations: {\n        IHelper: function(node) {\n          return {\n            'slice': function(_arg, str) {\n              var count, start;\n\n              start = _arg[0], count = _arg[1];\n              return str.substr(start, count);\n            },\n            'push': function(i) {\n              return stack.push(i);\n            },\n            'pop': function() {\n              return stack.pop();\n            },\n            'match': function(predicate, value) {\n              var real_predicate;\n\n              real_predicate = make_lambda(predicate);\n              if (real_predicate(value)) {\n                return value;\n              } else {\n                return STOP;\n              }\n            },\n            'spine-fire': function(event_name) {\n              return Spine.trigger(event_name);\n            },\n            \"true\": function() {\n              return true;\n            },\n            \"false\": function() {\n              return false;\n            },\n            'the-undefined': function() {\n              return void 0;\n            },\n            wrap: function(t, p, v) {\n              return t.replace(p, v);\n            },\n            '###': function(block, args) {\n              return args;\n            },\n            'push-to-google': function(p) {\n              debug('push-to-google', p);\n              return push_to_google.apply(null, p);\n            },\n            random: function() {\n              return Math.random();\n            },\n            len: function(array) {\n              return array.length || 0;\n            },\n            wait: function(timeout, cont) {\n              debug(\"waiting \" + timeout + \"ms\");\n              return setTimeout(function() {\n                debug(\"waiting done\");\n                return cont();\n              }, timeout);\n            },\n            'named-wait': function(timeout, name, _, cont) {\n              debug(\"named-wait\", timeout, name);\n              return named_waits[name] = setTimeout(function() {\n                debug(debug(\"named-wait done\", timeout, name));\n                return cont();\n              }, timeout);\n            },\n            'cancel-wait': function(name) {\n              if (named_waits[name]) {\n                debug(\"cancelling named timeout\", name);\n                return clearTimeout(named_waits[name]);\n              }\n            },\n            not: function(a) {\n              return !a;\n            },\n            \"stop!\": function() {\n              return STOP;\n            },\n            \"stop?\": function(p, v) {\n              if (p === v) {\n                return STOP;\n              } else {\n                return v;\n              }\n            },\n            add: function(vec) {\n              return vec.reduce(function(a, b) {\n                return (parseInt(a, 10)) + (parseInt(b, 10));\n              });\n            },\n            drop: function(items, item) {\n              var item_is_in_items;\n\n              item_is_in_items = is_nan(item) ? !!(items.filter(function(i) {\n                return is_nan(i);\n              })).length : __indexOf.call(items, item) >= 0;\n              if (item_is_in_items) {\n                return STOP;\n              } else {\n                return item;\n              }\n            },\n            swap: function(_arg, item) {\n              var from, to;\n\n              from = _arg[0], to = _arg[1];\n              if (((is_nan(item)) && (is_nan(from))) || (item === from)) {\n                return to;\n              } else {\n                return item;\n              }\n            },\n            '->->->': function(a) {\n              debug(\"[->->->]\", a);\n              return a;\n            },\n            proxyinfo: function(a) {\n              console.log(\"%c[proxy:@\" + node.id + \"] \", 'background: #222; color: #bada55', \"incoming: \" + a + \", type: \" + (typeof a));\n              return a;\n            },\n            info: info,\n            error: error,\n            warn: warn,\n            debug: function() {\n              var a;\n\n              a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n              return debug.apply(null, a);\n            },\n            say: info,\n            inc: function(v) {\n              return parseInt(v, 10) + 1;\n            },\n            dec: function(v) {\n              return parseInt(v, 10) - 1;\n            },\n            parseint: function(v) {\n              return parseInt(v);\n            },\n            preventOnEnter: function(e) {\n              if (e.keyCode === 13) {\n                e.preventDefault();\n              }\n              return e;\n            },\n            'make-obj': function(keyvals) {\n              var key, obj, val, _i, _len, _ref2;\n\n              obj = {};\n              for (_i = 0, _len = keyvals.length; _i < _len; _i++) {\n                _ref2 = keyvals[_i], key = _ref2[0], val = _ref2[1];\n                obj[key] = val;\n              }\n              return obj;\n            },\n            'obj->json': function(obj) {\n              return JSON.stringify(obj);\n            }\n          };\n        }\n      }\n    }\n  };\n\n}).call(this);\n\n}).call(this);}\n});","mtime":1384437081783,"type":"commonjs","path":"npm://dc-helper@0.0.15"}}