// Generated by CoffeeScript 1.6.2
(function() {
  var BQ, BUILTIN, DNA_DATATYPES, DNA_EXTEND, DNA_ID_PREFIX, DNA_PRIMITIVES, DNA_SUBSCRIBE, FLOAT, FUNCTION, HASHMAP, INTEGER, KEYWORD, MY_STATE, Math, NAN, NESTED_EXPR, NULL, PARTIAL_FN, QUOTED_NESTED_EXPR, RE, STRING, THIS, VECTOR, X, bind_handlers_to_event, bool, complement, compose3, cont_m, cont_t, create_cell, create_cell_by_id, debug, default_handlers_cont, dispatch_handler, dispatch_impl, distinct, domonad, error, find_cell, fun_with_meta, get_arity, get_cell, get_method_ns, get_primitive_value_handler, get_protocol, get_state, get_value_handler, info, is_array, is_async, is_function, is_just_function, is_nested_expr, is_null, is_object, is_partial_function, is_value, lazy_init_state, lift, lift_async, lift_sync, logger_m, logger_t, make_dynamic_handler, make_lambda, make_monadized_handler, make_nested_expr, maybe_m, maybe_t, nullog, observe_dom_added, parse_genome, partial, process_ast_handler_node, process_ast_vector, process_meta, process_subscribe, register_protocol_impl, repeat, save_cell, swap_state, synthesize_cell, synthesize_node, warn, watch_my_state, watch_state, _ref, _ref1, _ref2, _ref3, _ref4,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  DNA_EXTEND = 'extend';

  DNA_SUBSCRIBE = 'subscribe';

  DNA_ID_PREFIX = 'Z';

  NAN = 'NaN';

  NULL = 'null';

  KEYWORD = 'keyword';

  STRING = 'string';

  INTEGER = 'integer';

  FLOAT = 'float';

  VECTOR = 'vector';

  HASHMAP = 'hashmap';

  BQ = 'bq';

  RE = 're';

  FUNCTION = 'fn';

  PARTIAL_FN = 'partial';

  NESTED_EXPR = 'nested';

  QUOTED_NESTED_EXPR = 'quoted-nested';

  DNA_PRIMITIVES = [NAN, NULL, KEYWORD, STRING, INTEGER, FLOAT, RE, BQ];

  DNA_DATATYPES = [NAN, NULL, KEYWORD, STRING, INTEGER, FLOAT, VECTOR, HASHMAP, RE, BQ];

  THIS = 'this';

  BUILTIN = '*builtin*';

  Math = require('../utils/Math.uuid');

  _ref = require('libprotein'), partial = _ref.partial, is_array = _ref.is_array, is_object = _ref.is_object, bool = _ref.bool, make_lambda = _ref.make_lambda, complement = _ref.complement, compose3 = _ref.compose3, distinct = _ref.distinct, repeat = _ref.repeat;

  observe_dom_added = require('dom-mutation-observer').observe_dom_added;

  parse_genome = (require('genome-parser')).parse;

  _ref1 = require('libprotocol'), register_protocol_impl = _ref1.register_protocol_impl, dispatch_impl = _ref1.dispatch_impl, get_protocol = _ref1.get_protocol, is_async = _ref1.is_async, get_arity = _ref1.get_arity;

  _ref2 = require('libmonad'), cont_t = _ref2.cont_t, cont_m = _ref2.cont_m, maybe_t = _ref2.maybe_t, maybe_m = _ref2.maybe_m, logger_t = _ref2.logger_t, logger_m = _ref2.logger_m, domonad = _ref2.domonad, is_null = _ref2.is_null, lift_sync = _ref2.lift_sync, lift_async = _ref2.lift_async;

  _ref3 = dispatch_impl('ILogger', 'DNA'), info = _ref3.info, warn = _ref3.warn, error = _ref3.error, debug = _ref3.debug, nullog = _ref3.nullog;

  _ref4 = require('libstate'), get_state = _ref4.get_state, swap_state = _ref4.swap_state, watch_state = _ref4.watch_state;

  MY_STATE = 'dna';

  watch_my_state = function(old_state, new_state) {
    return debug("state changed", old_state, new_state);
  };

  lazy_init_state = function(state) {
    state || (state = {});
    state.CELLS || (state.CELLS = {});
    watch_state(MY_STATE, watch_my_state);
    return state;
  };

  process_ast_vector = function(vector, cell, ctx, cont) {
    var count, local_cont, res;

    res = [];
    count = vector.length;
    local_cont = function(idx) {
      return function(r) {
        res[idx] = r;
        count--;
        if (count === 0) {
          return cont(res);
        }
      };
    };
    return vector.map(function(ast_node, idx) {
      var c, h;

      h = process_ast_handler_node(cell, ctx, ast_node);
      c = local_cont(idx);
      if (h.meta.async) {
        return h.apply(null, (repeat(void 0, h.meta.arity - 1)).concat([c]));
      } else {
        return c(h.apply(null, repeat(void 0, h.meta.arity)));
      }
    });
  };

  default_handlers_cont = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  };

  is_value = function(type) {
    return __indexOf.call(DNA_DATATYPES, type) >= 0;
  };

  is_function = function(type) {
    return type === FUNCTION || type === PARTIAL_FN;
  };

  is_just_function = function(type) {
    return type === FUNCTION;
  };

  is_partial_function = function(type) {
    return type === PARTIAL_FN;
  };

  is_nested_expr = function(type) {
    return type === NESTED_EXPR;
  };

  lift = function(h) {
    if (h.meta.async) {
      return lift_async(h.meta.arity, h);
    } else {
      return lift_sync(h.meta.arity, h);
    }
  };

  get_method_ns = function(name, cell) {
    var method_invariants;

    method_invariants = cell.receptors[name];
    if ((method_invariants != null ? method_invariants.length : void 0) > 0) {
      return method_invariants[0].ns;
    } else {
      error("No such method: " + name + " in the cell:", cell);
      throw "Method missing in cell";
    }
  };

  dispatch_handler = function(ns, name, cell) {
    var method_from_given_ns, method_invariants;

    method_invariants = cell.receptors[name];
    if (method_invariants) {
      if (ns) {
        method_from_given_ns = (method_invariants.filter(function(m) {
          return m.ns === ns;
        }))[0];
        if (method_from_given_ns) {
          return method_from_given_ns.impl;
        } else {
          error("Method not found: " + ns + "/" + name + " in cell", cell);
          throw "Method not found: " + ns + "/" + name + " in cell id=`" + cell.id + "`";
        }
      } else {
        if (method_invariants.length === 1) {
          return method_invariants[0].impl;
        } else {
          error("More then one method with name `" + name + "` found in cell and namespace not set", cell);
          throw "More then one method with name `" + name + "` found in cell id=`" + cell.id + "` and namespace not set";
        }
      }
    } else {
      error("Method with name `" + name + "` not found in cell", {
        ns: ns,
        name: name,
        cell: cell
      });
      throw "Method with name `" + name + "` not found in cell id=`" + cell.id + "`";
    }
  };

  save_cell = function(cell) {
    return swap_state(MY_STATE, function(old_state) {
      var new_state;

      new_state = lazy_init_state(old_state);
      new_state.CELLS[cell.id] = cell;
      return new_state;
    });
  };

  get_cell = function(id) {
    return (lazy_init_state(get_state(MY_STATE))).CELLS[id];
  };

  find_cell = function(scope_id, this_cell, ctx) {
    var cell;

    if ((scope_id === THIS || !scope_id) && this_cell) {
      return this_cell;
    } else if (cell = get_cell(scope_id)) {
      return cell;
    } else if (cell = create_cell_by_id(scope_id, ctx, this_cell.synthesis_id)) {
      return cell;
    } else {
      return null;
    }
  };

  create_cell_by_id = function(id, ctx, synthesis_id) {
    var node;

    if (node = ctx.dom_parser.get_by_id(id)) {
      return create_cell(ctx, synthesis_id, node);
    } else {
      return null;
    }
  };

  fun_with_meta = function(fn, meta) {
    fn.meta = meta;
    return fn;
  };

  get_primitive_value_handler = function(type, value) {
    switch (type) {
      case NAN:
        return fun_with_meta((function() {
          return NaN;
        }), {
          arity: 0,
          async: false,
          protocol: BUILTIN,
          name: "NaN"
        });
      case NULL:
        return fun_with_meta((function() {
          return null;
        }), {
          arity: 0,
          async: false,
          protocol: BUILTIN,
          name: "null"
        });
      case KEYWORD:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          protocol: BUILTIN,
          name: ":Keyword " + value
        });
      case STRING:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "String '" + value + "'"
        });
      case INTEGER:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "Integer '" + value + "'"
        });
      case FLOAT:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "Float '" + value + "'"
        });
      case BQ:
        return fun_with_meta((function() {
          return make_lambda(value);
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "`Lambda '" + value + "'"
        });
      case RE:
        return fun_with_meta((function() {
          return function(a) {
            return value.test(a);
          };
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "/Regexp/ '" + value + "'"
        });
      default:
        throw "Unknown primitive type: " + type + "/" + value;
    }
  };

  get_value_handler = function(type, value, cell, ctx) {
    switch (type) {
      case NAN:
      case NULL:
      case KEYWORD:
      case STRING:
      case INTEGER:
      case FLOAT:
      case BQ:
      case RE:
        return get_primitive_value_handler(type, value);
      case VECTOR:
        return fun_with_meta(function(cont) {
          return process_ast_vector(value, cell, ctx, function(res) {
            return cont(res);
          });
        }, {
          async: true,
          arity: 1,
          protocol: BUILTIN,
          name: "Vector"
        });
      case HASHMAP:
        return fun_with_meta(function(key) {
          if (key) {
            return value[key];
          } else {
            return value;
          }
        }, {
          arity: 1,
          async: false,
          protocol: BUILTIN,
          name: "Hashmap"
        });
      default:
        throw "Unknown type: " + type;
    }
  };

  make_nested_expr = function(ctx, current_cell, handler) {
    return fun_with_meta(function(arg, cont) {
      var f;

      f = make_monadized_handler(ctx, current_cell, cont, handler);
      return f(arg);
    }, {
      async: true,
      arity: 2,
      protocol: BUILTIN,
      name: NESTED_EXPR
    });
  };

  process_ast_handler_node = function(current_cell, ctx, handler) {
    var USE_LAZY_PARTIAL_ARGS, arity, h, vargs, _get_cell, _ref5;

    _get_cell = function(id) {
      var cell;

      cell = find_cell(id, current_cell, ctx);
      if (!cell) {
        error("Unknown cell referenced in handler", id, handler);
        throw "Unknown cell referenced in handler";
      }
      return cell;
    };
    switch (handler.type) {
      case FUNCTION:
        return dispatch_handler(handler.ns, handler.name, _get_cell(handler.scope || THIS));
      case PARTIAL_FN:
        USE_LAZY_PARTIAL_ARGS = true;
        h = dispatch_handler(handler.fn.ns, handler.fn.name, _get_cell(handler.fn.scope || THIS));
        if (USE_LAZY_PARTIAL_ARGS) {
          _ref5 = h.meta, vargs = _ref5.vargs, arity = _ref5.arity;
          return fun_with_meta(function() {
            var accepted_args, args;

            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            accepted_args = args.slice(0, arity);
            return process_ast_vector(handler.args, current_cell, ctx, function(calculated_args) {
              var cont, raw_accepted_args, _i;

              if (h.meta.async) {
                return h.apply(null, calculated_args.concat(accepted_args));
              } else {
                raw_accepted_args = 2 <= accepted_args.length ? __slice.call(accepted_args, 0, _i = accepted_args.length - 1) : (_i = 0, []), cont = accepted_args[_i++];
                return cont(h.apply(null, calculated_args.concat(raw_accepted_args)));
              }
            });
          }, {
            arity: arity,
            async: true,
            name: "partial application of " + h.meta.name,
            protocol: h.meta.protocol
          });
        } else {
          return partial.apply(null, [h].concat(__slice.call(handler.args.map(function(_arg) {
            var type, value;

            type = _arg.type, value = _arg.value;
            if (__indexOf.call(DNA_PRIMITIVES, type) < 0) {
              throw "Only primitive datatypes accepted as partial args";
            }
            return (get_primitive_value_handler(type, value))();
          }))));
        }
        break;
      case NESTED_EXPR:
        return make_nested_expr(ctx, current_cell, handler.value);
      case QUOTED_NESTED_EXPR:
        throw "QUOTED_NESTED_EXPR is not implemented yet";
        break;
      case NAN:
      case NULL:
      case KEYWORD:
      case STRING:
      case INTEGER:
      case FLOAT:
      case VECTOR:
      case HASHMAP:
      case RE:
      case BQ:
        return get_value_handler(handler.type, handler.value, _get_cell(handler.scope || THIS), ctx);
      default:
        error("Unknown expression type: " + handler.type, handler);
        throw "Unknown expression type: " + handler.type;
    }
  };

  process_meta = function(cell, h) {
    return h;
  };

  make_monadized_handler = function(ctx, cell, cont, handlr) {
    var ast_parser, do_meta, lifted_handlers_chain, wrapper_monad;

    ast_parser = partial(process_ast_handler_node, cell, ctx);
    do_meta = partial(process_meta, cell);
    lifted_handlers_chain = handlr.seq.map(compose3(lift, do_meta, ast_parser));
    wrapper_monad = cont_t(logger_t(maybe_m({
      is_error: is_null
    }), nullog));
    return fun_with_meta(function(init_val) {
      return (domonad(wrapper_monad, lifted_handlers_chain, init_val))(cont);
    }, {
      async: true,
      arity: 1,
      name: 'monadized-handler'
    });
  };

  bind_handlers_to_event = function(ctx, cell, handlers, event_node) {
    var args, event_binder, name, ns, scope, type, _ref5;

    _ref5 = event_node.type === 'partial-event' ? {
      type: 'partial-event',
      args: partial(process_ast_vector, event_node.args, cell, ctx),
      name: event_node.event.name,
      ns: event_node.event.ns,
      scope: event_node.event.scope
    } : {
      type: 'event',
      args: [],
      name: event_node.name,
      ns: event_node.ns,
      scope: event_node.scope
    }, type = _ref5.type, args = _ref5.args, name = _ref5.name, ns = _ref5.ns, scope = _ref5.scope;
    event_binder = dispatch_handler(ns, name, find_cell(scope || THIS, cell, ctx));
    return handlers.map(function(handlr) {
      if (event_node.type === 'partial-event') {
        return args(function(processed_args) {
          return event_binder.apply(null, processed_args.concat([handlr]));
        });
      } else {
        return event_binder.apply(null, args.concat([handlr]));
      }
    });
  };

  make_dynamic_handler = function(ctx, cell, cont, handlr) {
    return function() {
      var args, fresh_cell, h;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      fresh_cell = find_cell(cell.id, cell, ctx);
      h = make_monadized_handler(ctx, fresh_cell, cont, handlr);
      return h.apply(null, args);
    };
  };

  process_subscribe = function(cell) {
    var genes, genome_string;

    if (cell.subscriptions_processed) {
      return;
    }
    cell.subscriptions_processed = true;
    genome_string = cell.ctx.dom_parser.getData(DNA_SUBSCRIBE, cell.node);
    if (bool(genome_string)) {
      genes = parse_genome(genome_string);
      return genes.map(function(gene) {
        return gene.events.map(partial(bind_handlers_to_event, cell.ctx, cell, gene.handlers.map(partial(make_dynamic_handler, cell.ctx, cell, default_handlers_cont))));
      });
    }
  };

  synthesize_cell = function(node, ctx, synthesis_id) {
    var all_the_protocols, extended_protocols, proto_cell;

    if (!node.id) {
      node.id = (ctx.dom_parser.get_id(node)) || DNA_ID_PREFIX + Math.uuid();
    }
    proto_cell = {
      id: node.id,
      node: node,
      receptors: {},
      impls: {},
      ctx: ctx,
      synthesis_id: synthesis_id
    };
    extended_protocols = (extended_protocols = ctx.dom_parser.getData(DNA_EXTEND, node)) ? (extended_protocols.split(' ')).filter(function(i) {
      return !!i;
    }) : [];
    all_the_protocols = distinct(extended_protocols.concat(ctx.default_protocols));
    all_the_protocols.map(function(protocol) {
      var p;

      p = get_protocol(protocol);
      proto_cell.impls[protocol] = dispatch_impl(protocol, node);
      if (!is_object(proto_cell.impls[protocol])) {
        error("Bad protocol implementation for DNA: " + protocol, proto_cell.impls[protocol]);
        throw "Bad protocol implementation for DNA: " + protocol + " :: " + proto_cell.impls[protocol];
      }
      if (p && proto_cell.impls[protocol]) {
        return p.map(function(_arg) {
          var args, m, name;

          name = _arg[0], args = _arg[1];
          m = {
            name: name,
            ns: protocol,
            impl: proto_cell.impls[protocol][name]
          };
          if (proto_cell.receptors[name]) {
            return proto_cell.receptors[name].push(m);
          } else {
            return proto_cell.receptors[name] = [m];
          }
        });
      }
    });
    return proto_cell;
  };

  create_cell = function(ctx, synthesis_id, node) {
    var cell, maybe_id, old_cell, sid;

    maybe_id = node.id;
    sid = maybe_id && (old_cell = get_cell(maybe_id)) ? (debug("Reinstantiating cell with id " + maybe_id), old_cell.synthesis_id + 1) : synthesis_id;
    cell = synthesize_cell(node, ctx, sid);
    save_cell(cell);
    return cell;
  };

  synthesize_node = function(ctx) {
    var START_TIME, active_nodes, creator, new_cells, root_node, synthesis_id;

    START_TIME = new Date;
    synthesis_id = 0;
    root_node = ctx.dom_parser.get_root_node();
    active_nodes = ctx.dom_parser.get_by_attr("[data-" + DNA_EXTEND + "], [data-" + DNA_SUBSCRIBE + "]");
    creator = partial(create_cell, ctx, synthesis_id);
    new_cells = active_nodes.map(creator);
    return new_cells.map(process_subscribe);
  };

  X = {
    get_cells: function() {
      return (lazy_init_state(get_state(MY_STATE))).CELLS;
    },
    get_cell: get_cell,
    forget_cell: function(id) {
      return swap_state(MY_STATE, function(old_state) {
        var new_state;

        new_state = lazy_init_state(old_state);
        delete new_state.CELLS[id];
        return new_state;
      });
    },
    start_synthesis: function(root_node, default_protocols) {
      var ctx;

      if (!root_node) {
        error("Root node not specified");
        throw "Root node not specified";
      }
      info('Synthesis started');
      ctx = {
        dom_parser: dispatch_impl('IDom', root_node),
        default_protocols: default_protocols
      };
      observe_dom_added(root_node, function(new_dom) {
        return setTimeout(function() {
          return synthesize_node({
            dom_parser: dispatch_impl('IDom', new_dom),
            default_protocols: default_protocols
          });
        }, 10);
      });
      return synthesize_node(ctx);
    },
    synthesize_node: function(node, default_protocols) {
      return synthesize_node({
        dom_parser: dispatch_impl('IDom', node),
        default_protocols: default_protocols
      });
    },
    get_bound_method: function(cell, method_proto, method_name) {
      var method_impl, method_inv;

      method_inv = cell.receptors[method_name];
      if (!method_inv) {
        throw "No method " + method_name + "@" + cell.id;
      }
      if (method_proto === void 0 && method_inv.length === 1) {
        return method_inv[0].impl;
      } else {
        method_impl = method_inv.filter(function(m) {
          return m.ns === method_proto;
        });
        if (method_impl.length !== 1) {
          throw "No method " + method_proto + "/" + method_name + "@" + cell.id;
        }
        return method_impl[0].impl;
      }
    },
    call: function() {
      var args, cellid, m, meth_name, meth_spec, mspec, ns, _ref5, _ref6;

      mspec = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _ref5 = mspec.split('@'), meth_spec = _ref5[0], cellid = _ref5[1];
      _ref6 = meth_spec.split('/'), ns = _ref6[0], meth_name = _ref6[1];
      m = X.get_bound_method(X.get_cell(cellid), ns, meth_name);
      return m.apply(null, args);
    }
  };

  module.exports = X;

}).call(this);
