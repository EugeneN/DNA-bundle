// Generated by CoffeeScript 1.6.2
(function() {
  var DEBUG, ERROR, INFO, LOGCFG, LOGTIME, LOG_LEVELS, NOTICE, RE1, RE2, SHOWLOG, UNK_NS, WARN, and_, bool, console, e, filter, get_browser_cfg, get_config, get_cookie, get_cookie_hash, get_cookies, get_location_hash, get_namespaced_logger, hash_level, hash_ns, in_browser, in_nodejs, is_array, is_object, log, log_cfg, log_level_enabled, log_ns_enabled, merge, nullog, or_, parse_config_hash, partial, root, say, slice, submerge, trimLeft, trimRight, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  root = typeof process !== "undefined" && process !== null ? process : typeof window !== "undefined" && window !== null ? window : {};

  in_browser = typeof window !== "undefined" && window !== null ? true : false;

  in_nodejs = typeof process !== "undefined" && process !== null ? true : false;

  _ref = (function() {
    try {
      get_config = require('config').get_config;
      return [get_config('ENV.LOG.cs_log_show_hash'), get_config('ENV.LOG.cs_log_show_time')];
    } catch (_error) {
      e = _error;
      return ['showlog', 'logtime'];
    }
  })(), SHOWLOG = _ref[0], LOGTIME = _ref[1];

  if (!root.console) {
    root.console = {
      log: function() {},
      info: function() {},
      warn: function() {},
      error: function() {},
      assert: function() {},
      dir: function() {},
      clear: function() {},
      profile: function() {},
      profileEnd: function() {}
    };
  }

  console = root.console;

  if (Function.prototype.bind && console && typeof console.log == "object") {
    [
      "log","info","warn","error","assert","dir","clear","profile","profileEnd"
    ].forEach(function (method) {
        console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
}
if (Function.prototype.bind && console && typeof console.debug == "object") {
    [
      "debug"
    ].forEach(function (method) {
        console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
}
;

  _ref1 = require('libprotein'), partial = _ref1.partial, or_ = _ref1.or_, and_ = _ref1.and_, bool = _ref1.bool, is_object = _ref1.is_object, is_array = _ref1.is_array;

  LOGCFG = (function() {
    try {
      log_cfg = get_config('ENV.LOG');
      if (log_cfg) {
        return log_cfg;
      } else {
        return null;
      }
    } catch (_error) {
      e = _error;
      if (in_nodejs && (is_object(process.ENV)) && (is_object(process.ENV.LOG))) {
        return process.ENV.LOG;
      } else if (in_browser && (is_object(window.ENV)) && (is_object(window.ENV.LOG))) {
        return window.ENV.LOG;
      } else {
        return null;
      }
    }
  })();

  trimLeft = function(s) {
    return s.replace(/^\s+/, "");
  };

  trimRight = function(s) {
    return s.replace(/\s+$/, "");
  };

  RE1 = /^\s*\$Version=(?:"1"|1);\s*(.*)/;

  RE2 = /(?:^|\s+)([!#$%&'*+\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\-.0-9A-Z^`a-z|~]*|"(?:[\x20-\x7E\x80\xFF]|\\[\x00-\x7F])*")(?=\s*[,;]|$)/g;

  get_cookies = function() {
    var c, cookies, v;

    c = document.cookie;
    v = 0;
    cookies = {};
    if (document.cookie.match(RE1)) {
      c = RegExp.$1;
      v = 1;
    }
    if (v === 0) {
      c.split(/[,;]/).map(function(cookie) {
        var name, parts;

        parts = cookie.split('=', 2);
        name = decodeURIComponent(trimLeft(parts[0]));
        return cookies[name] = parts.length > 1 ? decodeURIComponent(trimRight(parts[1])) : null;
      });
    } else {
      c.match(RE2).map(function(name, maybe_value) {
        return cookies[name] = maybe_value.charAt(0) === '"' ? maybe_value.substr(1, -1).replace(/\\(.)/g, "$1") : maybe_value;
      });
    }
    return cookies;
  };

  get_cookie = function(name) {
    return get_cookies()[name];
  };

  filter = function(list, f) {
    var i, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      i = list[_i];
      if ((f(i)) === true) {
        _results.push(i);
      }
    }
    return _results;
  };

  slice = function(str, start, stop) {
    return str.substr(start, stop);
  };

  parse_config_hash = function(hash) {
    var grep, parts;

    if (hash) {
      parts = hash.split(';');
      grep = function(pp, prefix) {
        var r;

        prefix = prefix + '=';
        r = filter(pp, function(p) {
          return (slice(p, 0, prefix.length)) === prefix;
        }).map(function(q) {
          return (slice(q, prefix.length)).split('|');
        });
        if (r.length > 0) {
          return r.reduce(function(a, b) {
            return a.concat(b);
          });
        } else {
          return null;
        }
      };
      return {
        enabled: __indexOf.call(parts, SHOWLOG) >= 0,
        logtime: __indexOf.call(parts, LOGTIME) >= 0,
        ns: grep(parts, 'ns'),
        level: grep(parts, 'level')
      };
    } else {
      return {
        enabled: false,
        logtime: false,
        ns: null,
        level: null
      };
    }
  };

  get_cookie_hash = function() {
    return get_cookie(SHOWLOG);
  };

  get_location_hash = function() {
    return document.location.hash.slice(1);
  };

  submerge = function(a, b) {
    if (a === null && b === null) {
      return null;
    } else if (a === null && b !== null) {
      return b;
    } else if (a !== null && b === null) {
      return a;
    } else {
      return a.concat(b);
    }
  };

  merge = function(a, b) {
    return {
      enabled: a.enabled || b.enabled,
      logtime: a.logtime || b.logtime,
      ns: submerge(a.ns, b.ns),
      level: submerge(a.level, b.level)
    };
  };

  get_browser_cfg = function() {
    return merge(parse_config_hash(get_location_hash()), parse_config_hash(get_cookie_hash()));
  };

  hash_level = function(level) {
    var cfg, _ref2;

    if (in_browser) {
      cfg = get_browser_cfg();
      if (cfg.level === null) {
        return true;
      }
      if (_ref2 = level.toLowerCase(), __indexOf.call(cfg.level.map(function(i) {
        return i.toLowerCase();
      }), _ref2) >= 0) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  };

  hash_ns = function(ns) {
    var cfg;

    if (in_browser) {
      cfg = get_browser_cfg();
      if (cfg.ns === null) {
        return true;
      }
      if (__indexOf.call(cfg.ns, ns) >= 0) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  };

  INFO = 'INFO';

  WARN = 'WARN';

  ERROR = 'ERROR';

  DEBUG = 'DEBUG';

  NOTICE = 'NOTICE';

  LOG_LEVELS = [INFO, WARN, ERROR, DEBUG, NOTICE];

  UNK_NS = 'UNK_NS';

  say = function(log_time, log_level, log_ns, msgs) {
    var m;

    m = [(log_time ? "[" + ((new Date).valueOf()) + "]" : ""), (log_level ? "[" + log_level + "]" : '[NOTICE]'), (log_ns ? "[" + log_ns + "]" : "[" + UNK_NS + "]")].concat(msgs);
    switch (log_level) {
      case ERROR:
        return console != null ? typeof console.error === "function" ? console.error.apply(console, m) : void 0 : void 0;
      case INFO:
        return console != null ? console.info.apply(console, m) : void 0;
      case DEBUG:
        if ((console != null ? console.debug : void 0) != null) {
          return console != null ? console.debug.apply(console, m) : void 0;
        } else {
          return console != null ? console.log.apply(console, m) : void 0;
        }
        break;
      case WARN:
        return console != null ? console.warn.apply(console, m) : void 0;
      default:
        return console != null ? console.log.apply(console, m) : void 0;
    }
  };

  log_level_enabled = function(log_level) {
    var cfg_level, _ref2;

    cfg_level = LOGCFG ? ((_ref2 = LOGCFG.level) != null ? _ref2[log_level] : void 0) === true : true;
    if (in_browser) {
      return hash_level(log_level);
    } else {
      return cfg_level;
    }
  };

  log_ns_enabled = function(log_ns) {
    var cfg_ns, _ref2;

    cfg_ns = LOGCFG ? ((_ref2 = LOGCFG.ns) != null ? _ref2[log_ns] : void 0) === true : false;
    if (in_browser) {
      return hash_ns(log_ns);
    } else {
      return cfg_ns;
    }
  };

  log = function() {
    var browser_cfg, enabled, log_level, log_ns, log_time, msg, _ref2;

    log_level = arguments[0], log_ns = arguments[1], msg = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    _ref2 = LOGCFG.enabled != null ? in_browser ? (browser_cfg = get_browser_cfg(), [browser_cfg.enabled || LOGCFG.enabled, browser_cfg.logtime || LOGCFG.logtime]) : [LOGCFG.enabled, LOGCFG.logtime] : [true, false], enabled = _ref2[0], log_time = _ref2[1];
    if (!enabled) {
      return;
    }
    if ((log_ns_enabled(log_ns)) && (log_level_enabled(log_level))) {
      return say(log_time, log_level, log_ns, msg);
    }
  };

  nullog = function() {};

  get_namespaced_logger = function(log_ns) {
    return {
      info: partial(log, INFO, log_ns),
      warn: partial(log, WARN, log_ns),
      error: partial(log, ERROR, log_ns),
      debug: partial(log, DEBUG, log_ns),
      notice: partial(log, NOTICE, log_ns),
      nullog: nullog
    };
  };

  module.exports = {
    info: partial(log, INFO, UNK_NS),
    warn: partial(log, WARN, UNK_NS),
    error: partial(log, ERROR, UNK_NS),
    debug: partial(log, DEBUG, UNK_NS),
    notice: partial(log, NOTICE, UNK_NS),
    nullog: nullog,
    ns: get_namespaced_logger,
    protocols: {
      definitions: {
        ILogger: [
          [
            'info', [], {
              varargs: true
            }
          ], [
            'warn', [], {
              varargs: true
            }
          ], [
            'error', [], {
              varargs: true
            }
          ], [
            'debug', [], {
              varargs: true
            }
          ], [
            'notice', [], {
              varargs: true
            }
          ], [
            'nullog', [], {
              varargs: true
            }
          ]
        ]
      },
      implementations: {
        ILogger: get_namespaced_logger
      }
    }
  };

}).call(this);
